{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1505732559000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1505732559000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1505732559000},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1530631785997},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1505732559000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1505732559000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1505732559000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1505732559000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1505732559000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1505732559000},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1530631785998},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1530631785999},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1530631786000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1505732559000},{"_id":"themes/next/_config.yml","hash":"f8b8e4208e9bc499409a0f91609327b93e54698b","modified":1530636160245},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1530631786027},{"_id":"source/404/index.md","hash":"c876884a6f554d50bca145dccb29a9ebb7911d0f","modified":1505734611000},{"_id":"source/_posts/2016-03-25-mysql-int.md","hash":"d546987f25c94890416970df58393031c63a790e","modified":1505734611000},{"_id":"source/_posts/2016-03-28-rm.md","hash":"6be204921204e0f487a8be36a5456f5c5a4fdae0","modified":1505734611000},{"_id":"source/_posts/2016-03-23-kafka-0-9-0.md","hash":"af185ede70c3e1291f0b448ae2910c91c40b8bf6","modified":1505734611000},{"_id":"source/_posts/2016-04-05-float.md","hash":"80f09f2a7e51da64aa3843893b4639f74e9396ef","modified":1505734611000},{"_id":"source/_posts/2016-04-07-sort.md","hash":"6665cc593b698e1499460155012c9eb241fa55f1","modified":1505734611000},{"_id":"source/_posts/2016-04-19-flush.md","hash":"4b1b0781632f388b6bc8c1b928d205c44daba14e","modified":1505734611000},{"_id":"source/_posts/2016-06-12-greatWall.md","hash":"d24c9f8e4602543d52fc2488a26a1671a137b6c6","modified":1505734611000},{"_id":"source/_posts/2016-05-10-mysql-driver.md","hash":"ea5a8d2ff0e7b78b6d5d81d59762a3efab47dc21","modified":1505734611000},{"_id":"source/_posts/2016-06-24-ctags.md","hash":"06d026b4cb31850b92ec34209ebf04b395b610a5","modified":1505734611000},{"_id":"source/_posts/2016-08-08-daemon.md","hash":"f423726d35c725deb0e13b27a538caa4b048593f","modified":1505734611000},{"_id":"source/_posts/2016-07-15-make-tutorial.md","hash":"6715b0a6345191bba6b479a7efb422ab014fb91c","modified":1505734611000},{"_id":"source/_posts/2016-10-27-char-varchar.md","hash":"b3e9b2e2d935737bd5951ca6bc2da481ec35714e","modified":1505734611000},{"_id":"source/_posts/2017-02-15-mysqlnd.md","hash":"2b98e261017b48e63cb9e076ef423859b4040edb","modified":1505734611000},{"_id":"source/_posts/2017-05-27-curl.md","hash":"843a98ce51a482e7d7d9c1e8a6940348e871b637","modified":1505734611000},{"_id":"source/_posts/2017-05-03-flock.md","hash":"19fc1bede565e7d04384d29d7bda1b30319b47fe","modified":1505734611000},{"_id":"source/_posts/2017-01-04-bufferPool.md","hash":"5d9e60c333943348041eb2c091b57cb5d7ad8610","modified":1505734611000},{"_id":"source/_posts/2017-06-07-memcached.md","hash":"381376fbad1b43fa59e414c8699c6d00d995f4e6","modified":1505734611000},{"_id":"source/_posts/2017-07-23-lazy.md","hash":"949a94474ab12743f73c66a051817708c3693c2b","modified":1505734611000},{"_id":"source/_posts/2017-09-13-mysql-binary.md","hash":"c69de3d95909a06070ba482ff996075a14da0d9e","modified":1505734611000},{"_id":"source/about/index.md","hash":"f60ce3d37af81b82f596114a9a5a46d3c52b9768","modified":1505734611000},{"_id":"source/categories/index.md","hash":"6853c380a6bb75a2b8b55677e1f6d82449c4a2d0","modified":1505734611000},{"_id":"source/tags/index.md","hash":"3204446d54eb62d6b1fe6d5f18b22ccd0a638f6a","modified":1505734611000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1505732559000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1505732544000},{"_id":"themes/next/.git/config","hash":"ca83ce520f770c3104c997d323b9f293dd920073","modified":1530631785985},{"_id":"themes/next/.git/index","hash":"2c52553944d621e39963a2ed128a9ebe611b8943","modified":1530631786139},{"_id":"themes/next/.git/packed-refs","hash":"69237944e31c16fe545d1f47b0b1e5b1d99660da","modified":1530631785978},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1505732559000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1530631785997},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1530631785996},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1505732559000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1530631786002},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1505732559000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1505732559000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1505732559000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1505732559000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1505732559000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1505732559000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1505732559000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1505732559000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1505732559000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1530631786004},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1505732559000},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1530631786004},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1530631786005},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1530631786006},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1505732559000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1505732559000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1505732559000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1530631786026},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1530631786026},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1530631786028},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1505732559000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1505732559000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1505732559000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1505732559000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1505732559000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1505732559000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505732559000},{"_id":"source/_posts/2016-03-23-kafka-0-9-0/log_anatomy.png","hash":"7d387eec0de1ebfbcd98a3b0c87aa008b2dbe476","modified":1505734611000},{"_id":"source/_posts/2016-03-23-kafka-0-9-0/consumer-groups.png","hash":"619c852e02b223e8af57e857d50759d1921b5d76","modified":1505734611000},{"_id":"source/_posts/2016-03-23-kafka-0-9-0/producer_consumer.png","hash":"04beb0d4a67d1cf50aa1f4a1a597bd941994fceb","modified":1505734611000},{"_id":"source/_posts/2016-05-10-mysql-driver/5.4.png","hash":"4086048f26fc01de3cbaff94f4206ddce366887a","modified":1505734611000},{"_id":"source/_posts/2016-05-10-mysql-driver/5.3.png","hash":"ad6a69e8ed8e17e7019b1fe693dd1e684b1de3bf","modified":1505734611000},{"_id":"source/_posts/2016-06-12-greatWall/chrome.png","hash":"69385e9b8581006cc0ccf16cf04d753dde8cc770","modified":1505734611000},{"_id":"source/_posts/2017-05-27-curl/1.png","hash":"4d88e4844127c0327e636ee42b459a899ce4634e","modified":1505734611000},{"_id":"source/_posts/2017-05-27-curl/2.png","hash":"19d393956685046d40f77d62f2e3e40f3467d96a","modified":1505734611000},{"_id":"source/_posts/2017-06-07-memcached/mem1.png","hash":"74ce04fc79536c434a3757aaa23db89c18cc55df","modified":1505734611000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1505732544000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1505732544000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1505732544000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1505732544000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1505732544000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1505732544000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1530631766416},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1505732544000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1530631766417},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1505732544000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1505732544000},{"_id":"themes/next/.git/logs/HEAD","hash":"2c821706b23aac72c71dc64eb3207c0e73da4541","modified":1530631785982},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1505732559000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1505732559000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1505732559000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1530631786007},{"_id":"themes/next/layout/_macro/post.swig","hash":"4aa7eda227587e8a33d477c77e7d3ae463c0de18","modified":1530635839286},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1505732559000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1505732559000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1530631786008},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1530631786008},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1530631786009},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1530631786009},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1505732559000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1505732559000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1505732559000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1505732559000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1505732559000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1505732559000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1530631786015},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1505732559000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1505732559000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1505732559000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1505732559000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1505732559000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1505732559000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1530631786029},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1505732559000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1505732559000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1505732559000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1505732559000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1505732559000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1505732559000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1505732559000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1505732559000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1505732559000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1505732559000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1505732559000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1505732559000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1505732559000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1505732559000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1505732559000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1505732559000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1505732559000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1505732559000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1505732559000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1505732559000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1505732559000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1505732559000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1505732559000},{"_id":"source/_posts/2016-06-12-greatWall/issh.jpeg","hash":"9bd511d4d079227d2cb5f52b089bd00665866a49","modified":1505734611000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505732559000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505732559000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505732559000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505732559000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505732559000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505732559000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505732559000},{"_id":"source/_posts/2016-03-25-mysql-int/2.jpg","hash":"1af9519c619878c16f4b436b968e7e2016b79d8e","modified":1505734611000},{"_id":"source/_posts/2016-03-25-mysql-int/1.jpg","hash":"323db9dd7daf825c4cde59b7b6ae0b0e9b77a3c3","modified":1505734611000},{"_id":"themes/next/.git/refs/heads/master","hash":"7999da428ebb87e5a2b27315d8d5123c1ccdfaa5","modified":1530631785982},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1505732559000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1505732559000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1505732559000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1505732559000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1505732559000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1505732559000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1505732559000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1505732559000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1505732559000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1505732559000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1505732559000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1505732559000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1505732559000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1505732559000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1505732559000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1505732559000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1505732559000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1505732559000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1505732559000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1505732559000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1505732559000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1505732559000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1505732559000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1505732559000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1505732559000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1505732559000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1505732559000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1505732559000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1505732559000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1530631786021},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1530631786020},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1505732559000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1505732559000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1505732559000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1505732559000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1505732559000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1505732559000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1505732559000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1505732559000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1505732559000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1530631786060},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1530631786060},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1530631786061},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1530631786060},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1505732559000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1505732559000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1505732559000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1505732559000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1505732559000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1505732559000},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1530631786071},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1530631786071},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1505732559000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1505732559000},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1530631786072},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1505732559000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1505732559000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1505732559000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1530631786084},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1505732559000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1505732559000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1505732559000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1505732559000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1505732559000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1505732559000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1505732559000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1505732559000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1505732559000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1505732559000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1505732559000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1505732559000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1505732559000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1505732559000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1505732559000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1505732559000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1505732559000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1505732559000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1505732559000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1505732559000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1505732559000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1505732559000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1505732559000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1505732559000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1505732559000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1505732559000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1505732559000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1505732559000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1505732559000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1505732559000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1505732559000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1505732559000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1505732559000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1505732559000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1505732559000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1505732559000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1505732559000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1505732559000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1505732559000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1505732559000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"2c821706b23aac72c71dc64eb3207c0e73da4541","modified":1530631785983},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1505732559000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1505732559000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1530631786032},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1530631786032},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1530631786037},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1505732559000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1505732559000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1530631786050},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1530631786050},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1505732559000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1505732559000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1505732559000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1505732559000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1530631786053},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1505732559000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1505732559000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1505732559000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1505732559000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1530631786055},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1505732559000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1505732559000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1505732559000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1505732559000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1530631786057},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1505732559000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1505732559000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1505732559000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1530631786058},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1505732559000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1505732559000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1530631786059},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1505732559000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1530631786072},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1505732559000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1505732559000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1505732559000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1505732559000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1505732559000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1505732559000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1505732559000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1505732559000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1505732559000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1505732559000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1505732559000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1505732559000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1505732559000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1505732559000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1505732559000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1505732559000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1505732559000},{"_id":"source/_posts/2017-05-27-curl/3.png","hash":"d940c49610701508f2a7bb51c49e52fd233ff6e6","modified":1505734611000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1505732559000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1505732559000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1505732559000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1505732559000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1505732559000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1505732559000},{"_id":"themes/next/.git/objects/pack/pack-1d8e82ce6ff9b437c3d366c189c5242fc76cc76f.idx","hash":"f48687362de1bf7d60e09001676ea8317d416584","modified":1505732559000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"2c821706b23aac72c71dc64eb3207c0e73da4541","modified":1530631785980},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1530631786035},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1530631786037},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1530631786038},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1530631786040},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1530631786041},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1530631786041},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1530631786043},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1530631786044},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1530631786045},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1530631786046},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1505732559000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1530631786049},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1505732559000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1505732559000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1505732559000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1505732559000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1505732559000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1505732559000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1505732559000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1505732559000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1505732559000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1505732559000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1505732559000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1505732559000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1505732559000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1505732559000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1505732559000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1505732559000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1505732559000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1505732559000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1505732559000},{"_id":"source/_posts/2017-05-27-curl/4.png","hash":"d6ee9039c8c7ed7ce41ec9c23d3d5da07b8e2ea6","modified":1505734611000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1505732559000},{"_id":"source/_posts/2016-06-24-ctags/1.jpg","hash":"09bfaeda980f073f62e2102ba884b701c525b096","modified":1505734611000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1505732559000},{"_id":"themes/next/.git/objects/pack/pack-1d8e82ce6ff9b437c3d366c189c5242fc76cc76f.pack","hash":"644980f444980987932cc62871b580a1bac29fef","modified":1505732559000},{"_id":"public/atom.xml","hash":"9e5635723440a8917e95ab937d89905a9d3b49a2","modified":1530631801555},{"_id":"public/search.xml","hash":"eccf28f25f9f1ca0fee1ff45e79907f80314cfe2","modified":1530631801566},{"_id":"public/404/index.html","hash":"d15e8bb9157c522335cd1f1edeac2e56b4aba04c","modified":1530636261515},{"_id":"public/about/index.html","hash":"8a5825bbbaf4f10c6d9b8a5493eb13b8b0a7b190","modified":1530636261515},{"_id":"public/categories/index.html","hash":"aef7f7b30cc466d088fec5a07ceffa318c346d07","modified":1530636261516},{"_id":"public/tags/index.html","hash":"617ec59c112b46bda38d755ba6720daacd77788e","modified":1530636261516},{"_id":"public/2017/09/13/mysql-binary/index.html","hash":"87b97a123fdd435c9b678545ae9d843a6dd152f0","modified":1530636261516},{"_id":"public/2017/07/23/lazy/index.html","hash":"4f0385c5984d4f36a0d88c86a70f614eb354daf7","modified":1530636261516},{"_id":"public/2017/06/19/memcached/index.html","hash":"bb05abe46783874b3eea402573c5dd3d4b8049ba","modified":1530636261516},{"_id":"public/2017/05/27/curl/index.html","hash":"576d88b6ad31d48f22b8ccca7c57c271f5ad8b93","modified":1530636261516},{"_id":"public/2017/05/03/flock/index.html","hash":"4c3d4baa525edaa5c05d1a77198451ffe8ce72da","modified":1530636261516},{"_id":"public/2017/02/15/mysqlnd/index.html","hash":"c5f3e038e97afab58cef00b303b58309b077fb1a","modified":1530636261516},{"_id":"public/2017/01/04/bufferPool/index.html","hash":"31c22a8a95de03bb4606417d0e85576356c8bd5b","modified":1530636261516},{"_id":"public/2016/10/27/char-varchar/index.html","hash":"281bbb76dd66ad1d3dc7dc07c34e80a7898fa2a7","modified":1530636261516},{"_id":"public/2016/08/08/daemon/index.html","hash":"f95d3a60ee00e25fcf9f55a281e34316bbc8a73d","modified":1530636261516},{"_id":"public/2016/07/15/make-tutorial/index.html","hash":"e793a018b45d74de8bd2e6bc2aa1e61ca89cda83","modified":1530636261516},{"_id":"public/2016/06/24/ctags/index.html","hash":"f8f0cb6ca75fb811c39f7448236d78c1e50a3c06","modified":1530636261517},{"_id":"public/2016/06/12/greatWall/index.html","hash":"d613841e26673257582cf8d5525a466c73aa83c0","modified":1530636261517},{"_id":"public/2016/05/10/mysql-driver/index.html","hash":"b037c1092d557a81d60fc532b4c86241ee8d3a32","modified":1530636261517},{"_id":"public/2016/04/19/flush/index.html","hash":"f41e7cc2c4777daf8f7126a43157f000400cf0d0","modified":1530636261517},{"_id":"public/2016/04/07/sort/index.html","hash":"8f7ec599bd27ed40e8bdc50fe4e8d94b361fb774","modified":1530636261517},{"_id":"public/2016/04/05/float/index.html","hash":"3b3b9a542ec31949361fbeb5c09fbfce33ed7661","modified":1530636261517},{"_id":"public/2016/03/28/rm/index.html","hash":"a63d381bb46bc9d743a78ac47fe66506098e62d6","modified":1530636261517},{"_id":"public/2016/03/25/mysql-int/index.html","hash":"d91501e075cf8c6d1593af93d78f63b4364ad635","modified":1530636261517},{"_id":"public/2016/03/23/kafka-0-9-0/index.html","hash":"df8e31a0d148003c15cdbab28cafb9d71c1a9001","modified":1530636261517},{"_id":"public/categories/数据库/index.html","hash":"9fc4487662b13836f457b8fe16d4ea9da559cda2","modified":1530636261517},{"_id":"public/categories/运维/index.html","hash":"bfd0020c224a21196145f460b1345309b849ea15","modified":1530636261517},{"_id":"public/categories/大数据/index.html","hash":"e8584d8d1a37e7b3a8b88c55f86f0dc73a695b6b","modified":1530636261517},{"_id":"public/categories/php/index.html","hash":"acd51d2dc07291956c0bb552a2a2125093a070f8","modified":1530636261517},{"_id":"public/categories/算法/index.html","hash":"ab08e9ef53ca428b7449d6c74b56f8a2b843a397","modified":1530636261518},{"_id":"public/categories/网络/index.html","hash":"2a03c3c4a885793f0856e169ec61b39659484694","modified":1530636261518},{"_id":"public/categories/linux/index.html","hash":"748239bd79f06cf6bd21c8d1376381665d6d668c","modified":1530636261518},{"_id":"public/categories/c/index.html","hash":"8df65903466753eb4afa27b4d0f6205e9862d06f","modified":1530636261518},{"_id":"public/categories/缓存/index.html","hash":"0355bdcc38ddb56b4c28f366fd0046052f34c2bb","modified":1530636261518},{"_id":"public/index.html","hash":"005b07a19acb59894109421afc3a543569d0821a","modified":1530636261519},{"_id":"public/page/2/index.html","hash":"a29ac2546b5e1b83e335059fd9adf49b54c89117","modified":1530636261519},{"_id":"public/archives/index.html","hash":"656fd0cbb697cebbad1bedef531db4f3ee3511c1","modified":1530636261518},{"_id":"public/archives/page/2/index.html","hash":"7a85f13fe30f08b5ce317de5103d28a37c92a623","modified":1530636261518},{"_id":"public/archives/2016/index.html","hash":"f0b498a96f3fad363700a8d3b23974531a02f25d","modified":1530636261518},{"_id":"public/archives/2016/page/2/index.html","hash":"553a09814d00f8628dabf83958fc753b9cddfaf5","modified":1530636261518},{"_id":"public/archives/2016/03/index.html","hash":"82474dae936c349daf9730cf5abc6b33b1b86119","modified":1530636261518},{"_id":"public/archives/2016/04/index.html","hash":"0cdf2de06202d5a0a73b9d5b62b8d9f2481b36b8","modified":1530636261518},{"_id":"public/archives/2016/05/index.html","hash":"702dfdab6d2baa24c510ae9e02740907bb05507f","modified":1530636261518},{"_id":"public/archives/2016/06/index.html","hash":"8f8c06328280884864d12737b18f56b7bb534057","modified":1530636261518},{"_id":"public/archives/2016/07/index.html","hash":"73245f049c691d1e7873c05b9388196602f0f35f","modified":1530636261518},{"_id":"public/archives/2016/08/index.html","hash":"534ff7e43960e177927095906efcc0b920c823d3","modified":1530636261518},{"_id":"public/archives/2016/10/index.html","hash":"3cfbbeffc9ccfb04c592ee000136e1d6ff4949f6","modified":1530636261518},{"_id":"public/archives/2017/index.html","hash":"269ece0a13faea9f8c6bab9feeec71d4cf9822f9","modified":1530636261519},{"_id":"public/archives/2017/01/index.html","hash":"4c8cb3f804acb43a863769f27f00b3b57ad38ec8","modified":1530636261519},{"_id":"public/archives/2017/02/index.html","hash":"5c36a27b9278ee35559b9c0ead29951ef21c613b","modified":1530636261519},{"_id":"public/archives/2017/05/index.html","hash":"8817909bd10be88ab43075342ce012681adc82cd","modified":1530636261519},{"_id":"public/archives/2017/06/index.html","hash":"8734770591c06053c118d253dd2ac6d507f324c2","modified":1530636261519},{"_id":"public/archives/2017/07/index.html","hash":"8e3d6dbfff2f1605ee8db1f96e3c630b684035aa","modified":1530636261519},{"_id":"public/archives/2017/09/index.html","hash":"c59f6ebb077e28acf365fb7e4e8baa6a169c5450","modified":1530636261519},{"_id":"public/tags/mysql/index.html","hash":"71a1a8aef40734969c58782f10b89fb31400c3cc","modified":1530636261519},{"_id":"public/tags/linux/index.html","hash":"f8f1d820737dcc88bdd6f407e35aabbe0f1cf3f8","modified":1530636261519},{"_id":"public/tags/kafka/index.html","hash":"9f4147e56c96a800876e87ee32b99626b48d2684","modified":1530636261519},{"_id":"public/tags/翻译/index.html","hash":"8e85719cbf26500165236919e34c2ba476845b9b","modified":1530636261519},{"_id":"public/tags/php/index.html","hash":"044b97ef38663e12ba7cb57deee20dc1e2712a03","modified":1530636261519},{"_id":"public/tags/排序/index.html","hash":"177a1f702872d79845320ecfbad1ec56f3fb559d","modified":1530636261520},{"_id":"public/tags/mac/index.html","hash":"65f8cfdb3ac5ad443c3c43de01e20a156857a19c","modified":1530636261520},{"_id":"public/tags/vim/index.html","hash":"a8a87fd78acf228462e8d16e36688df49e5cb02c","modified":1530636261520},{"_id":"public/tags/mysql-php/index.html","hash":"01be1b303cf125ec63945e22ff0261ccb4b2763e","modified":1530636261520},{"_id":"public/tags/memcached/index.html","hash":"b5bf4ee2d82f17bddd4f5f5931bbecc43308f866","modified":1530636261520},{"_id":"public/tags/python/index.html","hash":"17a2943fa2ef928cd5019bb927f35a1dbc5d9b95","modified":1530636261520},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1530631801590},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1530631801590},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1530631801590},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1530631801590},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1530631801590},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1530631801590},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1530631801590},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1530631801590},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1530631801590},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1530631801590},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1530631801590},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1530631801590},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1530631801590},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1530631801590},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1530631801590},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1530631801590},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1530631801590},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1530631801590},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1530631801591},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1530631801591},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1530631801591},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1530631801591},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1530631801591},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1530631801591},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1530631801591},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1530631801591},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1530631801591},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1530631801591},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1530631801591},{"_id":"public/2017/06/19/memcached/mem1.png","hash":"74ce04fc79536c434a3757aaa23db89c18cc55df","modified":1530631801591},{"_id":"public/2016/05/10/mysql-driver/5.3.png","hash":"ad6a69e8ed8e17e7019b1fe693dd1e684b1de3bf","modified":1530631801591},{"_id":"public/2016/05/10/mysql-driver/5.4.png","hash":"4086048f26fc01de3cbaff94f4206ddce366887a","modified":1530631801592},{"_id":"public/2016/06/12/greatWall/chrome.png","hash":"69385e9b8581006cc0ccf16cf04d753dde8cc770","modified":1530631801592},{"_id":"public/2016/03/23/kafka-0-9-0/consumer-groups.png","hash":"619c852e02b223e8af57e857d50759d1921b5d76","modified":1530631801592},{"_id":"public/2016/03/23/kafka-0-9-0/log_anatomy.png","hash":"7d387eec0de1ebfbcd98a3b0c87aa008b2dbe476","modified":1530631801592},{"_id":"public/2016/03/23/kafka-0-9-0/producer_consumer.png","hash":"04beb0d4a67d1cf50aa1f4a1a597bd941994fceb","modified":1530631801592},{"_id":"public/2017/05/27/curl/1.png","hash":"4d88e4844127c0327e636ee42b459a899ce4634e","modified":1530631801592},{"_id":"public/2017/05/27/curl/2.png","hash":"19d393956685046d40f77d62f2e3e40f3467d96a","modified":1530631801592},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1530631802126},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1530631802133},{"_id":"public/2016/06/12/greatWall/issh.jpeg","hash":"9bd511d4d079227d2cb5f52b089bd00665866a49","modified":1530631802138},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1530631802200},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1530631802200},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1530631802200},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1530631802201},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1530631802201},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1530631802201},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1530631802201},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1530631802201},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1530631802201},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1530631802201},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1530631802201},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1530631802201},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1530631802201},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1530631802201},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1530631802201},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1530631802201},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1530631802201},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1530631802201},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1530631802201},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1530631802202},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1530631802202},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1530631802202},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1530631802202},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1530631802202},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1530631802202},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1530631802202},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1530631802202},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1530631802202},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1530631802202},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1530631802202},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1530631802202},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1530631802202},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1530631802202},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1530631802202},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1530631802202},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1530631802203},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1530631802203},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1530631802203},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1530631802203},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1530631802203},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1530631802203},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1530631802203},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1530631802203},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1530631802203},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1530631802203},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1530631802203},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1530631802203},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1530631802203},{"_id":"public/css/main.css","hash":"9d0dd56d9e21faa2b03a45f88ed064bc20ccdeeb","modified":1530631802203},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1530631802204},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1530631802204},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1530631802204},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1530631802204},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1530631802204},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1530631802204},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1530631802204},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1530631802204},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1530631802204},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1530631802204},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1530631802205},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1530631802205},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1530631802205},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1530631802205},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1530631802205},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1530631802205},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1530631802205},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1530631802205},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1530631802206},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1530631802206},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1530631802206},{"_id":"public/2016/03/25/mysql-int/2.jpg","hash":"1af9519c619878c16f4b436b968e7e2016b79d8e","modified":1530631802206},{"_id":"public/2016/03/25/mysql-int/1.jpg","hash":"323db9dd7daf825c4cde59b7b6ae0b0e9b77a3c3","modified":1530631802206},{"_id":"public/2017/05/27/curl/3.png","hash":"d940c49610701508f2a7bb51c49e52fd233ff6e6","modified":1530631802231},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1530631802235},{"_id":"public/2017/05/27/curl/4.png","hash":"d6ee9039c8c7ed7ce41ec9c23d3d5da07b8e2ea6","modified":1530631802266},{"_id":"public/2016/06/24/ctags/1.jpg","hash":"09bfaeda980f073f62e2102ba884b701c525b096","modified":1530631802271},{"_id":"themes/next/db.json","hash":"7060f588490c6900e7c32ba677ecffa714b15380","modified":1530548384271},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1530631786003},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1530631786004},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1530631786022},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1530631786062},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1530631786066},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1530631786066},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1530631786067},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1530631786017},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1530631786019},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1530631786119},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1530631786120},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1530631786119},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1530631786048},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1530631786049},{"_id":"themes/next/.git/objects/pack/pack-88df782ce6fe81241cc1f463a32af916d4193f78.idx","hash":"bb5ce2ffd2b23aeab4e99d217116d616aeac700b","modified":1530631785946},{"_id":"themes/next/.git/objects/pack/pack-88df782ce6fe81241cc1f463a32af916d4193f78.pack","hash":"66da6ac57fd465b0b8f43f6be7c446eeee84eb9f","modified":1530631785939},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1530631801591},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1530631801591},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1530631801591},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1530631801591},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1530631802203},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1530631802205},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1530631802206},{"_id":"themes/next/._config.yml.swp","hash":"9d193f6489c6eb84c37f3e17c632f58092b939e7","modified":1530636164251},{"_id":"themes/next/source/images/avatar.jpg","hash":"68277da3a707eee1a7407159d397c92399d04866","modified":1530635357602},{"_id":"themes/next/source/images/favicon.ico","hash":"0c83e492694a4f3b65230fb0c4050a2f3f049fb8","modified":1530635529030},{"_id":"public/images/avatar.jpg","hash":"68277da3a707eee1a7407159d397c92399d04866","modified":1530636261523},{"_id":"public/images/favicon.ico","hash":"0c83e492694a4f3b65230fb0c4050a2f3f049fb8","modified":1530636261523}],"Category":[{"name":"数据库","_id":"cj7q4uqz60003kkjepuri48yx"},{"name":"运维","_id":"cj7q4uqza0008kkje90h1q36r"},{"name":"大数据","_id":"cj7q4uqzd000ekkjejqad6utv"},{"name":"php","_id":"cj7q4uqzg000kkkje5dlhmuw8"},{"name":"算法","_id":"cj7q4uqzq000skkje53o0i6dv"},{"name":"网络","_id":"cj7q4uqzv0011kkje9nsofrnb"},{"name":"linux","_id":"cj7q4uqzz0019kkjeq660818q"},{"name":"c","_id":"cj7q4ur03001okkjet1qwz43m"},{"name":"缓存","_id":"cj7q4ur050020kkje37ng7fnc"}],"Data":[],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n\t  <meta name=\"robots\" content=\"all\" />\n\t    <meta name=\"robots\" content=\"index,follow\"/>\n\t\t</head>\n\t\t<body>\n\n\t\t<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n\t\t        charset=\"utf-8\" homePageUrl=\"your site url \"\n\t\t\t\t        homePageName=\"回到我的主页\">\n\t\t\t\t\t\t</script>\n\n\t\t\t\t\t\t</body>\n\t\t\t\t\t\t</html>\n","source":"404/index.md","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n\t  <meta name=\"robots\" content=\"all\" />\n\t    <meta name=\"robots\" content=\"index,follow\"/>\n\t\t</head>\n\t\t<body>\n\n\t\t<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n\t\t        charset=\"utf-8\" homePageUrl=\"your site url \"\n\t\t\t\t        homePageName=\"回到我的主页\">\n\t\t\t\t\t\t</script>\n\n\t\t\t\t\t\t</body>\n\t\t\t\t\t\t</html>\n","date":"2017-09-18T11:36:51.000Z","updated":"2017-09-18T11:36:51.000Z","path":"404/index.html","title":"","comments":1,"layout":"page","_id":"cj7q4uqz00000kkjes5oybdj1","content":"<p>&lt;!DOCTYPE HTML&gt;</p>\n<html><br><head><br>  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"><br>    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"><br>      <meta name=\"robots\" content=\"all\"><br>        <meta name=\"robots\" content=\"index,follow\"><br>        </head><br>        <body><br><br>        <script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"your site url \" homepagename=\"回到我的主页\"><br>                        </script><br><br>                        </body><br>                        </html>\n","site":{"data":{}},"excerpt":"","more":"<p>&lt;!DOCTYPE HTML&gt;</p>\n<html><br><head><br>  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"><br>    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"><br>      <meta name=\"robots\" content=\"all\"><br>        <meta name=\"robots\" content=\"index,follow\"><br>        </head><br>        <body><br><br>        <script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"your site url \" homepagename=\"回到我的主页\"><br>                        </script><br><br>                        </body><br>                        </html>\n"},{"title":"about","date":"2016-03-23T08:52:23.000Z","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-03-23 16:52:23\ncomments: false\n---\n","updated":"2017-09-18T11:36:51.000Z","path":"about/index.html","layout":"page","_id":"cj7q4ur4i002bkkje2mjj5hxr","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2016-03-23T06:38:10.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-03-23 14:38:10\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-09-18T11:36:51.000Z","path":"categories/index.html","layout":"page","_id":"cj7q4ur4j002ckkjeoz65n4yq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2016-03-23T05:28:03.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-03-23 13:28:03\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-09-18T11:36:51.000Z","path":"tags/index.html","layout":"page","_id":"cj7q4ur4k002dkkjecv47vctj","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"关于int(M)后面的参数","date":"2016-03-25T09:00:35.000Z","photos":["http://7xsaff.com1.z0.glb.clouddn.com/2016%2F03%2F25%2F2.jpg","http://7xsaff.com1.z0.glb.clouddn.com/2016%2F03%2F25%2F1.jpg"],"_content":"\n*参看官方文档：http://dev.mysql.com/doc/refman/5.6/en/numeric-type-attributes.html*\n*http://stackoverflow.com/questions/7552223/int11-vs-intanything-else*\n\n在mysql中，int存储需要占用4个字节，无论存的是324123，还是1，与存储数字大小无关。\n\n有符号时，最小值为-2147483648(**注意这里是11位显示宽度**),最大值为2147483648(**此处为10位显示宽度**);\n<!-- more -->\n无符号时（unsigned），最小值为0，最大值为4294967295(**注意这里是10位显示宽度**)。\n\n在mysql创建表中，大家可以发现，假如不指定int的长度时，默认是11。为什么是11呢，不是12，不是10？\n\n这是因为默认mysql会设置为每种类型的‘最长'值长度，比如上面可以看到，有符号类型的int最大显示宽度是11位(有个负号)，所以是11。\n假如你勾选了unsigned，即无符号类型，则为10。\n\n再看看M的意思，官方文档说明是‘display width'显示宽度。原文‘*MySQL supports an extension for optionally specifying the display width of integer data types in parentheses following the base keyword for the type.*’\n\n从字面上看，好像是我存个int(4)，它就只能显示4位数字。其实不然，文档上说‘*The display width does not constrain the range of values that can be stored in the column. Nor does it prevent values wider than the column display width from being displayed correctly*.’，它不是为了限制字段值的存储范围，也不是为了限制那些超过该列指定宽度值的可显示位数。也就是说，设定了int(4)，还是能够存储12345的数字，也能存储数字1。它是为了在值不足M位时左边补足用的，有另外一个参数叫zerofill，默认不指定，则不足M位数时，左补空格；指定了，则补0。比如设置了int(4) zerofill，存储12，mysql会在左边补足0，成为‘0012’；没有设置zerofill，则为‘  12’。**这里要注意的是**，在mysql的cli命令行中，是不用显示宽度的，除非是设置了zerofill，所以一般我们看不到那些补足的空格，但是其他的客户端程序可以。这里面php连接获取值为什么不是‘  12’，我也不知道，还需要再研究，可能是php做了trim。可以参看*https://blogs.oracle.com/jsmyth/entry/what_does_the_11_mean*\n\n还可以发现，mysql最大可以设置的M为255，不知道为什么。。\n","source":"_posts/2016-03-25-mysql-int.md","raw":"---\ntitle: 关于int(M)后面的参数\ndate: 2016-03-25 17:00:35\ntags: mysql\ncategories: 数据库\nphotos:\n- http://7xsaff.com1.z0.glb.clouddn.com/2016%2F03%2F25%2F2.jpg\n- http://7xsaff.com1.z0.glb.clouddn.com/2016%2F03%2F25%2F1.jpg\n \n---\n\n*参看官方文档：http://dev.mysql.com/doc/refman/5.6/en/numeric-type-attributes.html*\n*http://stackoverflow.com/questions/7552223/int11-vs-intanything-else*\n\n在mysql中，int存储需要占用4个字节，无论存的是324123，还是1，与存储数字大小无关。\n\n有符号时，最小值为-2147483648(**注意这里是11位显示宽度**),最大值为2147483648(**此处为10位显示宽度**);\n<!-- more -->\n无符号时（unsigned），最小值为0，最大值为4294967295(**注意这里是10位显示宽度**)。\n\n在mysql创建表中，大家可以发现，假如不指定int的长度时，默认是11。为什么是11呢，不是12，不是10？\n\n这是因为默认mysql会设置为每种类型的‘最长'值长度，比如上面可以看到，有符号类型的int最大显示宽度是11位(有个负号)，所以是11。\n假如你勾选了unsigned，即无符号类型，则为10。\n\n再看看M的意思，官方文档说明是‘display width'显示宽度。原文‘*MySQL supports an extension for optionally specifying the display width of integer data types in parentheses following the base keyword for the type.*’\n\n从字面上看，好像是我存个int(4)，它就只能显示4位数字。其实不然，文档上说‘*The display width does not constrain the range of values that can be stored in the column. Nor does it prevent values wider than the column display width from being displayed correctly*.’，它不是为了限制字段值的存储范围，也不是为了限制那些超过该列指定宽度值的可显示位数。也就是说，设定了int(4)，还是能够存储12345的数字，也能存储数字1。它是为了在值不足M位时左边补足用的，有另外一个参数叫zerofill，默认不指定，则不足M位数时，左补空格；指定了，则补0。比如设置了int(4) zerofill，存储12，mysql会在左边补足0，成为‘0012’；没有设置zerofill，则为‘  12’。**这里要注意的是**，在mysql的cli命令行中，是不用显示宽度的，除非是设置了zerofill，所以一般我们看不到那些补足的空格，但是其他的客户端程序可以。这里面php连接获取值为什么不是‘  12’，我也不知道，还需要再研究，可能是php做了trim。可以参看*https://blogs.oracle.com/jsmyth/entry/what_does_the_11_mean*\n\n还可以发现，mysql最大可以设置的M为255，不知道为什么。。\n","slug":"mysql-int","published":1,"updated":"2017-09-18T11:36:51.000Z","comments":1,"layout":"post","link":"","_id":"cj7q4uqz10001kkjelesv356b","content":"<p><em>参看官方文档：<a href=\"http://dev.mysql.com/doc/refman/5.6/en/numeric-type-attributes.html\" target=\"_blank\" rel=\"external\">http://dev.mysql.com/doc/refman/5.6/en/numeric-type-attributes.html</a></em><br><em><a href=\"http://stackoverflow.com/questions/7552223/int11-vs-intanything-else\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/7552223/int11-vs-intanything-else</a></em></p>\n<p>在mysql中，int存储需要占用4个字节，无论存的是324123，还是1，与存储数字大小无关。</p>\n<p>有符号时，最小值为-2147483648(<strong>注意这里是11位显示宽度</strong>),最大值为2147483648(<strong>此处为10位显示宽度</strong>);<br><a id=\"more\"></a><br>无符号时（unsigned），最小值为0，最大值为4294967295(<strong>注意这里是10位显示宽度</strong>)。</p>\n<p>在mysql创建表中，大家可以发现，假如不指定int的长度时，默认是11。为什么是11呢，不是12，不是10？</p>\n<p>这是因为默认mysql会设置为每种类型的‘最长’值长度，比如上面可以看到，有符号类型的int最大显示宽度是11位(有个负号)，所以是11。<br>假如你勾选了unsigned，即无符号类型，则为10。</p>\n<p>再看看M的意思，官方文档说明是‘display width’显示宽度。原文‘<em>MySQL supports an extension for optionally specifying the display width of integer data types in parentheses following the base keyword for the type.</em>’</p>\n<p>从字面上看，好像是我存个int(4)，它就只能显示4位数字。其实不然，文档上说‘<em>The display width does not constrain the range of values that can be stored in the column. Nor does it prevent values wider than the column display width from being displayed correctly</em>.’，它不是为了限制字段值的存储范围，也不是为了限制那些超过该列指定宽度值的可显示位数。也就是说，设定了int(4)，还是能够存储12345的数字，也能存储数字1。它是为了在值不足M位时左边补足用的，有另外一个参数叫zerofill，默认不指定，则不足M位数时，左补空格；指定了，则补0。比如设置了int(4) zerofill，存储12，mysql会在左边补足0，成为‘0012’；没有设置zerofill，则为‘  12’。<strong>这里要注意的是</strong>，在mysql的cli命令行中，是不用显示宽度的，除非是设置了zerofill，所以一般我们看不到那些补足的空格，但是其他的客户端程序可以。这里面php连接获取值为什么不是‘  12’，我也不知道，还需要再研究，可能是php做了trim。可以参看<em><a href=\"https://blogs.oracle.com/jsmyth/entry/what_does_the_11_mean\" target=\"_blank\" rel=\"external\">https://blogs.oracle.com/jsmyth/entry/what_does_the_11_mean</a></em></p>\n<p>还可以发现，mysql最大可以设置的M为255，不知道为什么。。</p>\n","site":{"data":{}},"excerpt":"<p><em>参看官方文档：<a href=\"http://dev.mysql.com/doc/refman/5.6/en/numeric-type-attributes.html\" target=\"_blank\" rel=\"external\">http://dev.mysql.com/doc/refman/5.6/en/numeric-type-attributes.html</a></em><br><em><a href=\"http://stackoverflow.com/questions/7552223/int11-vs-intanything-else\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/7552223/int11-vs-intanything-else</a></em></p>\n<p>在mysql中，int存储需要占用4个字节，无论存的是324123，还是1，与存储数字大小无关。</p>\n<p>有符号时，最小值为-2147483648(<strong>注意这里是11位显示宽度</strong>),最大值为2147483648(<strong>此处为10位显示宽度</strong>);<br>","more":"<br>无符号时（unsigned），最小值为0，最大值为4294967295(<strong>注意这里是10位显示宽度</strong>)。</p>\n<p>在mysql创建表中，大家可以发现，假如不指定int的长度时，默认是11。为什么是11呢，不是12，不是10？</p>\n<p>这是因为默认mysql会设置为每种类型的‘最长’值长度，比如上面可以看到，有符号类型的int最大显示宽度是11位(有个负号)，所以是11。<br>假如你勾选了unsigned，即无符号类型，则为10。</p>\n<p>再看看M的意思，官方文档说明是‘display width’显示宽度。原文‘<em>MySQL supports an extension for optionally specifying the display width of integer data types in parentheses following the base keyword for the type.</em>’</p>\n<p>从字面上看，好像是我存个int(4)，它就只能显示4位数字。其实不然，文档上说‘<em>The display width does not constrain the range of values that can be stored in the column. Nor does it prevent values wider than the column display width from being displayed correctly</em>.’，它不是为了限制字段值的存储范围，也不是为了限制那些超过该列指定宽度值的可显示位数。也就是说，设定了int(4)，还是能够存储12345的数字，也能存储数字1。它是为了在值不足M位时左边补足用的，有另外一个参数叫zerofill，默认不指定，则不足M位数时，左补空格；指定了，则补0。比如设置了int(4) zerofill，存储12，mysql会在左边补足0，成为‘0012’；没有设置zerofill，则为‘  12’。<strong>这里要注意的是</strong>，在mysql的cli命令行中，是不用显示宽度的，除非是设置了zerofill，所以一般我们看不到那些补足的空格，但是其他的客户端程序可以。这里面php连接获取值为什么不是‘  12’，我也不知道，还需要再研究，可能是php做了trim。可以参看<em><a href=\"https://blogs.oracle.com/jsmyth/entry/what_does_the_11_mean\" target=\"_blank\" rel=\"external\">https://blogs.oracle.com/jsmyth/entry/what_does_the_11_mean</a></em></p>\n<p>还可以发现，mysql最大可以设置的M为255，不知道为什么。。</p>"},{"title":"linux下删除文件，空间不释放","date":"2016-03-28T15:38:02.000Z","_content":"\n*14年9月写在csdn上*\n\n某一天，程序写日志把磁盘给写满了。原因一是程序有死循环，写日志太多了；二是即使用rm把文件删掉了，也没释放空间。\n\n要讨论的就是第二个原因。\n<!---more-->\n\n我们来简单重现下：\n\n1，写一个test\n\n``` php\n<?php\n$a = '111';  \n$f = fopen('1.txt', 'a+');  \nwhile(1){  \n    fwrite($f, $a);  \n    sleep(1);\n}\n```\n\n执行这个程序，它会在本地产生一个1.txt文件，且会一直往里面写。\n\n2，使用ps命令查看，会有进程\n\n``` linux\n8214  8184  0 21:43 pts/0    00:00:00 php test.php\n```\n\n3，我们把1.txt文件删除，会发现8214这个进程还存在\n\n4， 使用lsof -p 8214命令查看其打开的文件，在最后一行会看见：\n``` linux\nCOMMAND  PID    USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME\nphp     8214 xxxxx    3u   REG  202,1     1896 248330 /home/xxxxx/1.txt (deleted)\n```\n\n发现其还在写入，SIZE还在不断上升，why?\n\n这是因为：\n\n>当进程打开了某个文件时，只要该进程保持打开该文件，即使将其删除，它依然存在于磁盘中。这意味着，进程并不知道文件已经被删除，它仍然可以向打开该文件时提供给它的文件描述符进行读取和写入。除了该进程之外，这个文件是不可见的，因为已经删除了其相应的目录索引节点。\n\n5，只能删掉该进程\n\n当然，现在写日志都是按时间来新建文件的，而不是一直往一个文件里写。所以，一般也不会出现这种情况。\n\n>参考: （lsof命令详解）http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316599.html\n\nhttp://blog.163.com/aprilthirty60@126/blog/static/88613578201282703952163/","source":"_posts/2016-03-28-rm.md","raw":"---\ntitle: linux下删除文件，空间不释放\ndate: 2016-03-28 23:38:02\ntags: linux\ncategories: 运维\n---\n\n*14年9月写在csdn上*\n\n某一天，程序写日志把磁盘给写满了。原因一是程序有死循环，写日志太多了；二是即使用rm把文件删掉了，也没释放空间。\n\n要讨论的就是第二个原因。\n<!---more-->\n\n我们来简单重现下：\n\n1，写一个test\n\n``` php\n<?php\n$a = '111';  \n$f = fopen('1.txt', 'a+');  \nwhile(1){  \n    fwrite($f, $a);  \n    sleep(1);\n}\n```\n\n执行这个程序，它会在本地产生一个1.txt文件，且会一直往里面写。\n\n2，使用ps命令查看，会有进程\n\n``` linux\n8214  8184  0 21:43 pts/0    00:00:00 php test.php\n```\n\n3，我们把1.txt文件删除，会发现8214这个进程还存在\n\n4， 使用lsof -p 8214命令查看其打开的文件，在最后一行会看见：\n``` linux\nCOMMAND  PID    USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME\nphp     8214 xxxxx    3u   REG  202,1     1896 248330 /home/xxxxx/1.txt (deleted)\n```\n\n发现其还在写入，SIZE还在不断上升，why?\n\n这是因为：\n\n>当进程打开了某个文件时，只要该进程保持打开该文件，即使将其删除，它依然存在于磁盘中。这意味着，进程并不知道文件已经被删除，它仍然可以向打开该文件时提供给它的文件描述符进行读取和写入。除了该进程之外，这个文件是不可见的，因为已经删除了其相应的目录索引节点。\n\n5，只能删掉该进程\n\n当然，现在写日志都是按时间来新建文件的，而不是一直往一个文件里写。所以，一般也不会出现这种情况。\n\n>参考: （lsof命令详解）http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316599.html\n\nhttp://blog.163.com/aprilthirty60@126/blog/static/88613578201282703952163/","slug":"rm","published":1,"updated":"2017-09-18T11:36:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7q4uqz40002kkjej99rhnzd","content":"<p><em>14年9月写在csdn上</em></p>\n<p>某一天，程序写日志把磁盘给写满了。原因一是程序有死循环，写日志太多了；二是即使用rm把文件删掉了，也没释放空间。</p>\n<p>要讨论的就是第二个原因。<br><a id=\"more\"></a></p>\n<p>我们来简单重现下：</p>\n<p>1，写一个test</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\">$a = <span class=\"string\">'111'</span>;  </div><div class=\"line\">$f = fopen(<span class=\"string\">'1.txt'</span>, <span class=\"string\">'a+'</span>);  </div><div class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;  </div><div class=\"line\">    fwrite($f, $a);  </div><div class=\"line\">    sleep(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>执行这个程序，它会在本地产生一个1.txt文件，且会一直往里面写。</p>\n<p>2，使用ps命令查看，会有进程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">8214  8184  0 21:43 pts/0    00:00:00 php test.php</div></pre></td></tr></table></figure>\n<p>3，我们把1.txt文件删除，会发现8214这个进程还存在</p>\n<p>4， 使用lsof -p 8214命令查看其打开的文件，在最后一行会看见：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">COMMAND  PID    USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME</div><div class=\"line\">php     8214 xxxxx    3u   REG  202,1     1896 248330 /home/xxxxx/1.txt (deleted)</div></pre></td></tr></table></figure></p>\n<p>发现其还在写入，SIZE还在不断上升，why?</p>\n<p>这是因为：</p>\n<blockquote>\n<p>当进程打开了某个文件时，只要该进程保持打开该文件，即使将其删除，它依然存在于磁盘中。这意味着，进程并不知道文件已经被删除，它仍然可以向打开该文件时提供给它的文件描述符进行读取和写入。除了该进程之外，这个文件是不可见的，因为已经删除了其相应的目录索引节点。</p>\n</blockquote>\n<p>5，只能删掉该进程</p>\n<p>当然，现在写日志都是按时间来新建文件的，而不是一直往一个文件里写。所以，一般也不会出现这种情况。</p>\n<blockquote>\n<p>参考: （lsof命令详解）<a href=\"http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316599.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316599.html</a></p>\n</blockquote>\n<p><a href=\"http://blog.163.com/aprilthirty60@126/blog/static/88613578201282703952163/\" target=\"_blank\" rel=\"external\">http://blog.163.com/aprilthirty60@126/blog/static/88613578201282703952163/</a></p>\n","site":{"data":{}},"excerpt":"<p><em>14年9月写在csdn上</em></p>\n<p>某一天，程序写日志把磁盘给写满了。原因一是程序有死循环，写日志太多了；二是即使用rm把文件删掉了，也没释放空间。</p>\n<p>要讨论的就是第二个原因。<br>","more":"</p>\n<p>我们来简单重现下：</p>\n<p>1，写一个test</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\">$a = <span class=\"string\">'111'</span>;  </div><div class=\"line\">$f = fopen(<span class=\"string\">'1.txt'</span>, <span class=\"string\">'a+'</span>);  </div><div class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;  </div><div class=\"line\">    fwrite($f, $a);  </div><div class=\"line\">    sleep(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>执行这个程序，它会在本地产生一个1.txt文件，且会一直往里面写。</p>\n<p>2，使用ps命令查看，会有进程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">8214  8184  0 21:43 pts/0    00:00:00 php test.php</div></pre></td></tr></table></figure>\n<p>3，我们把1.txt文件删除，会发现8214这个进程还存在</p>\n<p>4， 使用lsof -p 8214命令查看其打开的文件，在最后一行会看见：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">COMMAND  PID    USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME</div><div class=\"line\">php     8214 xxxxx    3u   REG  202,1     1896 248330 /home/xxxxx/1.txt (deleted)</div></pre></td></tr></table></figure></p>\n<p>发现其还在写入，SIZE还在不断上升，why?</p>\n<p>这是因为：</p>\n<blockquote>\n<p>当进程打开了某个文件时，只要该进程保持打开该文件，即使将其删除，它依然存在于磁盘中。这意味着，进程并不知道文件已经被删除，它仍然可以向打开该文件时提供给它的文件描述符进行读取和写入。除了该进程之外，这个文件是不可见的，因为已经删除了其相应的目录索引节点。</p>\n</blockquote>\n<p>5，只能删掉该进程</p>\n<p>当然，现在写日志都是按时间来新建文件的，而不是一直往一个文件里写。所以，一般也不会出现这种情况。</p>\n<blockquote>\n<p>参考: （lsof命令详解）<a href=\"http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316599.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316599.html</a></p>\n</blockquote>\n<p><a href=\"http://blog.163.com/aprilthirty60@126/blog/static/88613578201282703952163/\" target=\"_blank\" rel=\"external\">http://blog.163.com/aprilthirty60@126/blog/static/88613578201282703952163/</a></p>"},{"title":"kafka-0.9.0","date":"2016-03-23T07:03:04.000Z","_content":"\n*原文：<http://kafka.apache.org/documentation.html>*\n\n>自己翻译的kafka官方文档（哈哈），持续更新中。。。\n\n<!-- more -->\n\n## 开始\n\n### 介绍\n\nkafka是一个分布式的(distributed)，分区的(partitioned)，可复制的(replicated) commit log 服务。它提供了作为一个消息系统的常用功能，但又有独一无二的设计。\n\n什么意思呢？\n\n首先，让我们回顾一些基本的消息术语：\n\n-\tkafka维持消息流分类的称作topics.\n\n-\t我们称处理发布消息到kafka topic的为producers.\n\n-\t我们称处理从topics中订阅并且处理已发布的消息流为consumers.\n\n所以，以一个高层次来说，producers通过网络发送消息给kafka集群，集群轮流把它们提供给consumers，如下图：\n\n{% asset_img producer_consumer.png %}\n\n客户端和服务器之间的交流是以一个单一，高性能，跨语言的tcp协议完成。我们为kafka提供了一个java客户端，但是客户端可以是很多其他语言。\n\n**topics 和 logs**\n\n让我们首先投入到kafka提供的高级抽象概念－topic\n\n一个topic就是一个种类或者是已发布消息的名称。对于每一个topic，kafka集群(cluster)维持一个分区日志如下图：\n\n{% asset_img log_anatomy.png %}\n\n每一区都是一系列顺序的，不可改变的消息，消息被连续添加到一个commit log。在分区里的消息都被赋予一个序列id号称作offset，在相应区里面是唯一的。\n\n在一个可以配置的时间段里，kafka保留所有已发布的消息，无论它们是否被消费。例如，如果日志保留时间设置为2天，那么一个消息在发布后的两天内对于消费者是有效的，之后它将会被丢弃从而释放空间。在数据大小方面而言，kafka的性能持续有效，所以保留大量数据没有问题。\n\n事实上，在日志中以每一个消费者的方式保留的唯一元数据是消费者的位置，称作“offset”。这个偏移量由消费者控制：当消费者读消息的时候将线性推进它的偏移量，但是事实上该位置由消费者控制，它可以以任何顺序消费消息。例如，一个消费者可以重置到一个旧的偏移量重新执行。\n\n这些混合的特征意味着kafka消费者非常廉价，它们可以在集群或者其他消费者之间来或去，而没有太多影响。例如，当一些现存的消费者在消费一些主题内容时，你可以用我们的命令行工具来“tail”出这些内容而不会改变什么。\n\n在日志服务中的分区有以下几个目的：首先，它们允许日志按大小比例适应每一个服务器。每一个分区必须适应绑定它的服务器，但是一个主题可能有很多分区，所以它可以随意处理很多数据。第二，它们以相似的单位行动，跟多的是以位。\n\n**Distribution 分布式**\n\n日志分区分布在kafka集群中的各个服务器上，每一个服务器处理来自一串分区的请求和数据。为了容错，每一个分区会在配置数量的服务器间复制。\n\n每一个分区都有一个服务器作为“leader”－领导者，0或多个服务器当作“followers”－追随者。领导者处理所有来自分区的读和写请求，而追随者被动的从领导者那复制。如果领导者失败了，其中一个追随者将自动成为领导者。（这里有一个疑问，是随机一个follower称为leader吗？）在集群内，每一个服务器在一些分区中扮演一个领导者，而在其他分区中扮演一个追随者，所以可以平衡运行。\n\n**Producers 生产者**\n\n生产者们发布数据到它们选择的主题里。生产者在主题里有责任选择消息分配到哪个分区里。这可以在仅仅一个循环内进行平衡加载，或者根据某些语义分区函数完成（根据消息中的一些key）。更多分区用法在第二章。\n\n**Consumers 消费者**\n\n传统消息有2个模块：*queuing*和*publish-subscribe*。在一个队列里，一个消费者池从一个服务器中读取消息，然后消息到达它们中的一个；而在publish-subscribe模式中，消息被广播到所有消费者中。kafka提出一个单一的消费者抽象概念，概括了这2个模块－*consumer group*消费组\n\n消费者用消费组名称作标签，每一个发布到主题的消息会被转发给订阅消费组中的消费实例。消费实例可以是单独进程，或者单独机器。\n\n如果所有的消费实例都属于同个消费组，那么这就像是一个传统的队列在各个消费者间负载均衡。\n\n如果所有的消费实例都属于不同的消费组，那么这就像是pub-sub模块，所有消息广播到所有消费者中。\n\n更通常的，但是，我们发现topics主题有小数目的consumer groups消费群体，用于每个“logical subscriber”逻辑订阅者。每一组由许多可扩展和容错的消费实例组成，就是pub-sub语义上是消费群中的订阅者而不是一个单一的进程。\n\nkafka也比传统消息系统更强的排序保证。\n\n一个传统队列在服务器上顺序保留了消息，如果多个消费者从队列里消费，那么服务器会顺序处理保存的消息。但是，虽然服务器顺序分发消息，但是消息还是被异步转发给消费者，所以它们可能不是顺序到达不同的消费者。这明显意味着，消息的顺序性在并行消费面前失效了。消息系统经常通过一个“exclusive consumer”独家消费的概念来解决这个问题，即只允许一个进程从服务器消费，但是这意味着在进程中没有并行。\n\n{% asset_img consumer-groups.png %}\n*一个2个服务器的kafka集群，用2个消费群组绑定了4个分区(p0-p3)。消费群A有2个消费实例，消费群B有4个。*\n\nkafka在这方面做的更好。通过一个在主题中的并行(parallelism)概念－分区，kafka不仅可以保证顺序，而且还可以在消费进程池里面负载均衡。这个通过赋予消费群里的消费者主题分区实现，在一个组里面每一个分区被一个消费者消费。通过这个，我们保证消费者是分区里的唯一读取者并且顺序消费数据。所以有很多这样的分区仍在很多消费者实例中负载均衡。但是要注意，在一个消费群里面不可能有比分区更多的消费实例。\n\nkafka只在一个分区内提供全序消息，而不是在分类里的分区之间。对于大部分应用来说，预分区通过key分区数据的能力已经足够了。但是，如果你请求一个全序消息，这只能在一个只有一个分区的分类里实现，虽然这意味着一个消费者处理一个消费群。\n\n**Guarantees 保证**\n\n高级kafka给出以下保证：\n\n- 生产者发送消息到一个指定的分类分区将会被顺序添加。那就是说，如果消息m1和m2被同样的生产者发送，m1先发送，然后m1将会比m2低一点偏移，在日志中出现的更早。\n- 一个消费实例顺序看到在日志中存储的消息。\n- 对于一个分类冗余因子n，我们将容忍n-1个服务器丢失提交给日志的信息。\n\n更多这些保证的详细信息会在文档的设计部分给出。\n\n### 使用案例\n\n以下是一些apache kafka常见使用案例的描述。要查看这些领域的更多概述，请看这个[blog](https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying).\n\n**messaging消息传递**\n\n作为一个传统消息代理的替代者，kafka运作的很好。消息代理基于很多种原因使用（从数据生产者中解耦，缓存还没处理的消息等等）。与大部分消息系统对比，kafka有更好的吞吐量，内置分区，冗余和容错机制，使得它能够很好的置身于大规模消息处理的应用中。\n\n以我们的经验，消息传递使用通常相当于低吞吐量，但是端对端低延时，基于kafka提供的高持久保证。\n\n在这个领域，kafka可以比得上传统的消息系统比如[ActiveMQ](http://activemq.apache.org/)或者[RabbitMQ](https://www.rabbitmq.com/)。\n\n**网站行为轨迹**\n\nkafka的最初用途是可以重建一个用户的行为轨迹线作为一组实时的发布－订阅feed。这意味着网站活动（比如pv，搜索，或者其他可获得的用户行为）会以每个行为类型一个topic分类的发布到中央topic。这些feed被一系列用途使用，包括实时进程、实时监控、加载进hadoop或者离线数据仓库系统做离线处理和报告。\n\n活跃的轨迹通常包含了高容量的每个用户pv产生的活跃信息。\n\n**Metrics度量**\n\nkafka经常被用来运转中监控数据，这需要从分布式应用中，生产集中运转中的数据feed，然后汇总统计。\n\n**日志聚合**\n\n很多朋友用kafka作为日志聚合的一个解决替代方案。典型的，日志聚合线下收集物理日志文件，然后把它们放入一个集中的地方（一个文件系统或者HDFS）来处理。kafka理论上远离了文件细节，给了一个更干净的文件抽象概念，甚至数据作为信息流。这对多种数据源和分布式数据消费有着低延迟和更好的支持。相比于日志中心系统比如scribe和flume，kafka同样提供高性能，强持久冗余保证和更低的端对端延迟。\n\n**流式处理**\n\n很多用户都是最终阶段处理那些从分类消费而来的未经处理的数据，然后汇总，丰富，或者转换进新的kafka分类作进一步的消费。例如一个文章推荐处理流程可能是先从rss feed流中爬文章内容，然后发布到'articles'分类中；更进一步的处理可能是规范化或者对内容去重，扔到一个放干净文章内容的分类里；最后一步可能是匹配这些内容给相关用户。这创建了一个有别于个别分类的实时数据流曲线图。[Storm](https://storm.apache.org/)和[Samza](http://samza.apache.org/)是实现这些转换的流行框架。\n\n**事件源**\n\n事件源是一种状态改变以时间顺序记录的一种应用设计方式。用这种方式，kafka以非常大的存储日志数据支持使的它成为一个应用极好的后端。\n\n**日志提交**\n\nkafka可以以一种外在的日志提交为分布式系统服务。这个日志帮助在节点之间复制数据，和作为一种预同步机制为那些失败节点恢复数据。kafka的这个[log compaction](http://kafka.apache.org/documentation.html#compaction)特点帮助支持了这个用例。在这个用法上kafka和[Apache BookKeeper](http://zookeeper.apache.org/bookkeeper/)项目类似。\n\n### 快速开始\n\n这部分指导假定你是从新开始，没有kafka或者zookeeper数据。\n\n**第一步：下载源代码**\n\n[下载](https://www.apache.org/dyn/closer.cgi?path=/kafka/0.9.0.0/kafka_2.11-0.9.0.0.tgz)0.9.0.0版本，然后解压它。\n\n    > tar -xzf kafka_2.11-0.9.0.0.tgz\n    > cd kafka_2.11-0.9.0.0\n\n**第二步：启动服务**\n\nkafka用了zookeeper，所以你需要首先启动zookeeper服务。你可以用kafka包里面的简单脚本来启动一个快速简便的单一节点zookeeper实例。\n\n    > bin/zookeeper-server-start.sh config/zookeeper.properties\n    [2013-04-22 15:01:37,495] INFO Reading configuration from: config/zookeeper.properties (org.apache.zookeeper.server.quorum.QuorumPeerConfig)\n...\n\n现在启动kafka服务：\n\n    > bin/kafka-server-start.sh config/server.properties\n    [2013-04-22 15:01:47,028] INFO Verifying properties (kafka.utils.VerifiableProperties)\n[2013-04-22 15:01:47,051] INFO Property socket.send.buffer.bytes is overridden to 1048576 (kafka.utils.VerifiableProperties)\n...\n\n**第三步：创建一个分类**\n\n让我们创建一个名叫\"test\"的分类，仅有一个分区和复制：\n\n    > bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test\n\n现在我们可以看见这个分类，如果执行了列出分类的命令：\n\n    > bin/kafka-topics.sh --list --zookeeper localhost:2181\n    test\n    \n或者不手动创建分类，你可以配置你的服务器，当一个不存在的分类发布时自动创建这个分类。\n\n**第四步：发送一些消息**\n\nkafka自带一个命令行客户端，这个可以从一个文件或者表格式得到输入，然后作为消息发送到kafka集群。默认的，每一行作为一个单独的消息被送出。\n\n运行生产者，然后输入一些消息进控制台发送到服务器。\n\n    > bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test\n    This is a message\n    This is another message\n    \n**第五步：启动一个消费者**\n\nkafka也有一个消费者命令行，将消息转储到标准输出。\n\n    > bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginning\n    This is a message\n    This is another message\n    \n如果你在不同终端运行着以上命令，那么你应当可以输入消息到生产者终端，然后在消费者终端出现这些消息。\n\n所有的命令后工具都有额外的选项；不带参数运行命令将会显示出更多用法的详细信息。\n\n**第六步：设置多服务器集群**\n\n到目前为止，我们已经执行了一个单一服务器，但是这没什么意思。对于kafka，一个单一服务器仅仅是集群中的一个，所以启动更多的服务器实例将没有太多改变。但是为了感受一下，我们还是扩充我们的集群到3个节点（还是在我们的本地机器上）。\n\n首先我们为每一个broker服务器生成一个配置文件：\n\n    > cp config/server.properties config/server-1.properties\n    > cp config/server.properties config/server-2.properties\n    \n现在编辑这些新的文件，设置如下内容：\n\n    config/server-1.properties:\n    broker.id=1\n    port=9093\n    log.dir=/tmp/kafka-logs-1\n    \n    config/server-2.properties:\n    broker.id=2\n    port=9094\n    log.dir=/tmp/kafka-logs-2\n    \n在集群的每一个节点中，这个broker.id是唯一和永久的名字。我们修改了端口和日志目录，因为我们是在相同的机器上运行这些，并且想让服务器都注册到相同的端口，彼此覆盖数据。\n\n我们已经有了zookeeper，我们的单一节点也启动了，所以我们只要启动下面两个新节点：\n\n    > bin/kafka-server-start.sh config/server-1.properties &\n    ...\n    > bin/kafka-server-start.sh config/server-2.properties &\n    ...\n    \n现在创建一个新的具有3个冗余因子的分类：\n\n    > bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic my-replicated-topic\n\n好了，我们有了一个集群，但是我们如何知道每一个broker服务器在干什么呢？","source":"_posts/2016-03-23-kafka-0-9-0.md","raw":"---\ntitle: kafka-0.9.0\ndate: 2016-03-23 15:03:04\ntags: \n- kafka\n- 翻译\ncategories: 大数据\n---\n\n*原文：<http://kafka.apache.org/documentation.html>*\n\n>自己翻译的kafka官方文档（哈哈），持续更新中。。。\n\n<!-- more -->\n\n## 开始\n\n### 介绍\n\nkafka是一个分布式的(distributed)，分区的(partitioned)，可复制的(replicated) commit log 服务。它提供了作为一个消息系统的常用功能，但又有独一无二的设计。\n\n什么意思呢？\n\n首先，让我们回顾一些基本的消息术语：\n\n-\tkafka维持消息流分类的称作topics.\n\n-\t我们称处理发布消息到kafka topic的为producers.\n\n-\t我们称处理从topics中订阅并且处理已发布的消息流为consumers.\n\n所以，以一个高层次来说，producers通过网络发送消息给kafka集群，集群轮流把它们提供给consumers，如下图：\n\n{% asset_img producer_consumer.png %}\n\n客户端和服务器之间的交流是以一个单一，高性能，跨语言的tcp协议完成。我们为kafka提供了一个java客户端，但是客户端可以是很多其他语言。\n\n**topics 和 logs**\n\n让我们首先投入到kafka提供的高级抽象概念－topic\n\n一个topic就是一个种类或者是已发布消息的名称。对于每一个topic，kafka集群(cluster)维持一个分区日志如下图：\n\n{% asset_img log_anatomy.png %}\n\n每一区都是一系列顺序的，不可改变的消息，消息被连续添加到一个commit log。在分区里的消息都被赋予一个序列id号称作offset，在相应区里面是唯一的。\n\n在一个可以配置的时间段里，kafka保留所有已发布的消息，无论它们是否被消费。例如，如果日志保留时间设置为2天，那么一个消息在发布后的两天内对于消费者是有效的，之后它将会被丢弃从而释放空间。在数据大小方面而言，kafka的性能持续有效，所以保留大量数据没有问题。\n\n事实上，在日志中以每一个消费者的方式保留的唯一元数据是消费者的位置，称作“offset”。这个偏移量由消费者控制：当消费者读消息的时候将线性推进它的偏移量，但是事实上该位置由消费者控制，它可以以任何顺序消费消息。例如，一个消费者可以重置到一个旧的偏移量重新执行。\n\n这些混合的特征意味着kafka消费者非常廉价，它们可以在集群或者其他消费者之间来或去，而没有太多影响。例如，当一些现存的消费者在消费一些主题内容时，你可以用我们的命令行工具来“tail”出这些内容而不会改变什么。\n\n在日志服务中的分区有以下几个目的：首先，它们允许日志按大小比例适应每一个服务器。每一个分区必须适应绑定它的服务器，但是一个主题可能有很多分区，所以它可以随意处理很多数据。第二，它们以相似的单位行动，跟多的是以位。\n\n**Distribution 分布式**\n\n日志分区分布在kafka集群中的各个服务器上，每一个服务器处理来自一串分区的请求和数据。为了容错，每一个分区会在配置数量的服务器间复制。\n\n每一个分区都有一个服务器作为“leader”－领导者，0或多个服务器当作“followers”－追随者。领导者处理所有来自分区的读和写请求，而追随者被动的从领导者那复制。如果领导者失败了，其中一个追随者将自动成为领导者。（这里有一个疑问，是随机一个follower称为leader吗？）在集群内，每一个服务器在一些分区中扮演一个领导者，而在其他分区中扮演一个追随者，所以可以平衡运行。\n\n**Producers 生产者**\n\n生产者们发布数据到它们选择的主题里。生产者在主题里有责任选择消息分配到哪个分区里。这可以在仅仅一个循环内进行平衡加载，或者根据某些语义分区函数完成（根据消息中的一些key）。更多分区用法在第二章。\n\n**Consumers 消费者**\n\n传统消息有2个模块：*queuing*和*publish-subscribe*。在一个队列里，一个消费者池从一个服务器中读取消息，然后消息到达它们中的一个；而在publish-subscribe模式中，消息被广播到所有消费者中。kafka提出一个单一的消费者抽象概念，概括了这2个模块－*consumer group*消费组\n\n消费者用消费组名称作标签，每一个发布到主题的消息会被转发给订阅消费组中的消费实例。消费实例可以是单独进程，或者单独机器。\n\n如果所有的消费实例都属于同个消费组，那么这就像是一个传统的队列在各个消费者间负载均衡。\n\n如果所有的消费实例都属于不同的消费组，那么这就像是pub-sub模块，所有消息广播到所有消费者中。\n\n更通常的，但是，我们发现topics主题有小数目的consumer groups消费群体，用于每个“logical subscriber”逻辑订阅者。每一组由许多可扩展和容错的消费实例组成，就是pub-sub语义上是消费群中的订阅者而不是一个单一的进程。\n\nkafka也比传统消息系统更强的排序保证。\n\n一个传统队列在服务器上顺序保留了消息，如果多个消费者从队列里消费，那么服务器会顺序处理保存的消息。但是，虽然服务器顺序分发消息，但是消息还是被异步转发给消费者，所以它们可能不是顺序到达不同的消费者。这明显意味着，消息的顺序性在并行消费面前失效了。消息系统经常通过一个“exclusive consumer”独家消费的概念来解决这个问题，即只允许一个进程从服务器消费，但是这意味着在进程中没有并行。\n\n{% asset_img consumer-groups.png %}\n*一个2个服务器的kafka集群，用2个消费群组绑定了4个分区(p0-p3)。消费群A有2个消费实例，消费群B有4个。*\n\nkafka在这方面做的更好。通过一个在主题中的并行(parallelism)概念－分区，kafka不仅可以保证顺序，而且还可以在消费进程池里面负载均衡。这个通过赋予消费群里的消费者主题分区实现，在一个组里面每一个分区被一个消费者消费。通过这个，我们保证消费者是分区里的唯一读取者并且顺序消费数据。所以有很多这样的分区仍在很多消费者实例中负载均衡。但是要注意，在一个消费群里面不可能有比分区更多的消费实例。\n\nkafka只在一个分区内提供全序消息，而不是在分类里的分区之间。对于大部分应用来说，预分区通过key分区数据的能力已经足够了。但是，如果你请求一个全序消息，这只能在一个只有一个分区的分类里实现，虽然这意味着一个消费者处理一个消费群。\n\n**Guarantees 保证**\n\n高级kafka给出以下保证：\n\n- 生产者发送消息到一个指定的分类分区将会被顺序添加。那就是说，如果消息m1和m2被同样的生产者发送，m1先发送，然后m1将会比m2低一点偏移，在日志中出现的更早。\n- 一个消费实例顺序看到在日志中存储的消息。\n- 对于一个分类冗余因子n，我们将容忍n-1个服务器丢失提交给日志的信息。\n\n更多这些保证的详细信息会在文档的设计部分给出。\n\n### 使用案例\n\n以下是一些apache kafka常见使用案例的描述。要查看这些领域的更多概述，请看这个[blog](https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying).\n\n**messaging消息传递**\n\n作为一个传统消息代理的替代者，kafka运作的很好。消息代理基于很多种原因使用（从数据生产者中解耦，缓存还没处理的消息等等）。与大部分消息系统对比，kafka有更好的吞吐量，内置分区，冗余和容错机制，使得它能够很好的置身于大规模消息处理的应用中。\n\n以我们的经验，消息传递使用通常相当于低吞吐量，但是端对端低延时，基于kafka提供的高持久保证。\n\n在这个领域，kafka可以比得上传统的消息系统比如[ActiveMQ](http://activemq.apache.org/)或者[RabbitMQ](https://www.rabbitmq.com/)。\n\n**网站行为轨迹**\n\nkafka的最初用途是可以重建一个用户的行为轨迹线作为一组实时的发布－订阅feed。这意味着网站活动（比如pv，搜索，或者其他可获得的用户行为）会以每个行为类型一个topic分类的发布到中央topic。这些feed被一系列用途使用，包括实时进程、实时监控、加载进hadoop或者离线数据仓库系统做离线处理和报告。\n\n活跃的轨迹通常包含了高容量的每个用户pv产生的活跃信息。\n\n**Metrics度量**\n\nkafka经常被用来运转中监控数据，这需要从分布式应用中，生产集中运转中的数据feed，然后汇总统计。\n\n**日志聚合**\n\n很多朋友用kafka作为日志聚合的一个解决替代方案。典型的，日志聚合线下收集物理日志文件，然后把它们放入一个集中的地方（一个文件系统或者HDFS）来处理。kafka理论上远离了文件细节，给了一个更干净的文件抽象概念，甚至数据作为信息流。这对多种数据源和分布式数据消费有着低延迟和更好的支持。相比于日志中心系统比如scribe和flume，kafka同样提供高性能，强持久冗余保证和更低的端对端延迟。\n\n**流式处理**\n\n很多用户都是最终阶段处理那些从分类消费而来的未经处理的数据，然后汇总，丰富，或者转换进新的kafka分类作进一步的消费。例如一个文章推荐处理流程可能是先从rss feed流中爬文章内容，然后发布到'articles'分类中；更进一步的处理可能是规范化或者对内容去重，扔到一个放干净文章内容的分类里；最后一步可能是匹配这些内容给相关用户。这创建了一个有别于个别分类的实时数据流曲线图。[Storm](https://storm.apache.org/)和[Samza](http://samza.apache.org/)是实现这些转换的流行框架。\n\n**事件源**\n\n事件源是一种状态改变以时间顺序记录的一种应用设计方式。用这种方式，kafka以非常大的存储日志数据支持使的它成为一个应用极好的后端。\n\n**日志提交**\n\nkafka可以以一种外在的日志提交为分布式系统服务。这个日志帮助在节点之间复制数据，和作为一种预同步机制为那些失败节点恢复数据。kafka的这个[log compaction](http://kafka.apache.org/documentation.html#compaction)特点帮助支持了这个用例。在这个用法上kafka和[Apache BookKeeper](http://zookeeper.apache.org/bookkeeper/)项目类似。\n\n### 快速开始\n\n这部分指导假定你是从新开始，没有kafka或者zookeeper数据。\n\n**第一步：下载源代码**\n\n[下载](https://www.apache.org/dyn/closer.cgi?path=/kafka/0.9.0.0/kafka_2.11-0.9.0.0.tgz)0.9.0.0版本，然后解压它。\n\n    > tar -xzf kafka_2.11-0.9.0.0.tgz\n    > cd kafka_2.11-0.9.0.0\n\n**第二步：启动服务**\n\nkafka用了zookeeper，所以你需要首先启动zookeeper服务。你可以用kafka包里面的简单脚本来启动一个快速简便的单一节点zookeeper实例。\n\n    > bin/zookeeper-server-start.sh config/zookeeper.properties\n    [2013-04-22 15:01:37,495] INFO Reading configuration from: config/zookeeper.properties (org.apache.zookeeper.server.quorum.QuorumPeerConfig)\n...\n\n现在启动kafka服务：\n\n    > bin/kafka-server-start.sh config/server.properties\n    [2013-04-22 15:01:47,028] INFO Verifying properties (kafka.utils.VerifiableProperties)\n[2013-04-22 15:01:47,051] INFO Property socket.send.buffer.bytes is overridden to 1048576 (kafka.utils.VerifiableProperties)\n...\n\n**第三步：创建一个分类**\n\n让我们创建一个名叫\"test\"的分类，仅有一个分区和复制：\n\n    > bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test\n\n现在我们可以看见这个分类，如果执行了列出分类的命令：\n\n    > bin/kafka-topics.sh --list --zookeeper localhost:2181\n    test\n    \n或者不手动创建分类，你可以配置你的服务器，当一个不存在的分类发布时自动创建这个分类。\n\n**第四步：发送一些消息**\n\nkafka自带一个命令行客户端，这个可以从一个文件或者表格式得到输入，然后作为消息发送到kafka集群。默认的，每一行作为一个单独的消息被送出。\n\n运行生产者，然后输入一些消息进控制台发送到服务器。\n\n    > bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test\n    This is a message\n    This is another message\n    \n**第五步：启动一个消费者**\n\nkafka也有一个消费者命令行，将消息转储到标准输出。\n\n    > bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginning\n    This is a message\n    This is another message\n    \n如果你在不同终端运行着以上命令，那么你应当可以输入消息到生产者终端，然后在消费者终端出现这些消息。\n\n所有的命令后工具都有额外的选项；不带参数运行命令将会显示出更多用法的详细信息。\n\n**第六步：设置多服务器集群**\n\n到目前为止，我们已经执行了一个单一服务器，但是这没什么意思。对于kafka，一个单一服务器仅仅是集群中的一个，所以启动更多的服务器实例将没有太多改变。但是为了感受一下，我们还是扩充我们的集群到3个节点（还是在我们的本地机器上）。\n\n首先我们为每一个broker服务器生成一个配置文件：\n\n    > cp config/server.properties config/server-1.properties\n    > cp config/server.properties config/server-2.properties\n    \n现在编辑这些新的文件，设置如下内容：\n\n    config/server-1.properties:\n    broker.id=1\n    port=9093\n    log.dir=/tmp/kafka-logs-1\n    \n    config/server-2.properties:\n    broker.id=2\n    port=9094\n    log.dir=/tmp/kafka-logs-2\n    \n在集群的每一个节点中，这个broker.id是唯一和永久的名字。我们修改了端口和日志目录，因为我们是在相同的机器上运行这些，并且想让服务器都注册到相同的端口，彼此覆盖数据。\n\n我们已经有了zookeeper，我们的单一节点也启动了，所以我们只要启动下面两个新节点：\n\n    > bin/kafka-server-start.sh config/server-1.properties &\n    ...\n    > bin/kafka-server-start.sh config/server-2.properties &\n    ...\n    \n现在创建一个新的具有3个冗余因子的分类：\n\n    > bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic my-replicated-topic\n\n好了，我们有了一个集群，但是我们如何知道每一个broker服务器在干什么呢？","slug":"kafka-0-9-0","published":1,"updated":"2017-09-18T11:36:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7q4uqz80005kkjefvashcbz","content":"<p><em>原文：<a href=\"http://kafka.apache.org/documentation.html\" target=\"_blank\" rel=\"external\">http://kafka.apache.org/documentation.html</a></em></p>\n<blockquote>\n<p>自己翻译的kafka官方文档（哈哈），持续更新中。。。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>kafka是一个分布式的(distributed)，分区的(partitioned)，可复制的(replicated) commit log 服务。它提供了作为一个消息系统的常用功能，但又有独一无二的设计。</p>\n<p>什么意思呢？</p>\n<p>首先，让我们回顾一些基本的消息术语：</p>\n<ul>\n<li><p>kafka维持消息流分类的称作topics.</p>\n</li>\n<li><p>我们称处理发布消息到kafka topic的为producers.</p>\n</li>\n<li><p>我们称处理从topics中订阅并且处理已发布的消息流为consumers.</p>\n</li>\n</ul>\n<p>所以，以一个高层次来说，producers通过网络发送消息给kafka集群，集群轮流把它们提供给consumers，如下图：</p>\n<img src=\"/2016/03/23/kafka-0-9-0/producer_consumer.png\" alt=\"producer_consumer.png\" title=\"\">\n<p>客户端和服务器之间的交流是以一个单一，高性能，跨语言的tcp协议完成。我们为kafka提供了一个java客户端，但是客户端可以是很多其他语言。</p>\n<p><strong>topics 和 logs</strong></p>\n<p>让我们首先投入到kafka提供的高级抽象概念－topic</p>\n<p>一个topic就是一个种类或者是已发布消息的名称。对于每一个topic，kafka集群(cluster)维持一个分区日志如下图：</p>\n<img src=\"/2016/03/23/kafka-0-9-0/log_anatomy.png\" alt=\"log_anatomy.png\" title=\"\">\n<p>每一区都是一系列顺序的，不可改变的消息，消息被连续添加到一个commit log。在分区里的消息都被赋予一个序列id号称作offset，在相应区里面是唯一的。</p>\n<p>在一个可以配置的时间段里，kafka保留所有已发布的消息，无论它们是否被消费。例如，如果日志保留时间设置为2天，那么一个消息在发布后的两天内对于消费者是有效的，之后它将会被丢弃从而释放空间。在数据大小方面而言，kafka的性能持续有效，所以保留大量数据没有问题。</p>\n<p>事实上，在日志中以每一个消费者的方式保留的唯一元数据是消费者的位置，称作“offset”。这个偏移量由消费者控制：当消费者读消息的时候将线性推进它的偏移量，但是事实上该位置由消费者控制，它可以以任何顺序消费消息。例如，一个消费者可以重置到一个旧的偏移量重新执行。</p>\n<p>这些混合的特征意味着kafka消费者非常廉价，它们可以在集群或者其他消费者之间来或去，而没有太多影响。例如，当一些现存的消费者在消费一些主题内容时，你可以用我们的命令行工具来“tail”出这些内容而不会改变什么。</p>\n<p>在日志服务中的分区有以下几个目的：首先，它们允许日志按大小比例适应每一个服务器。每一个分区必须适应绑定它的服务器，但是一个主题可能有很多分区，所以它可以随意处理很多数据。第二，它们以相似的单位行动，跟多的是以位。</p>\n<p><strong>Distribution 分布式</strong></p>\n<p>日志分区分布在kafka集群中的各个服务器上，每一个服务器处理来自一串分区的请求和数据。为了容错，每一个分区会在配置数量的服务器间复制。</p>\n<p>每一个分区都有一个服务器作为“leader”－领导者，0或多个服务器当作“followers”－追随者。领导者处理所有来自分区的读和写请求，而追随者被动的从领导者那复制。如果领导者失败了，其中一个追随者将自动成为领导者。（这里有一个疑问，是随机一个follower称为leader吗？）在集群内，每一个服务器在一些分区中扮演一个领导者，而在其他分区中扮演一个追随者，所以可以平衡运行。</p>\n<p><strong>Producers 生产者</strong></p>\n<p>生产者们发布数据到它们选择的主题里。生产者在主题里有责任选择消息分配到哪个分区里。这可以在仅仅一个循环内进行平衡加载，或者根据某些语义分区函数完成（根据消息中的一些key）。更多分区用法在第二章。</p>\n<p><strong>Consumers 消费者</strong></p>\n<p>传统消息有2个模块：<em>queuing</em>和<em>publish-subscribe</em>。在一个队列里，一个消费者池从一个服务器中读取消息，然后消息到达它们中的一个；而在publish-subscribe模式中，消息被广播到所有消费者中。kafka提出一个单一的消费者抽象概念，概括了这2个模块－<em>consumer group</em>消费组</p>\n<p>消费者用消费组名称作标签，每一个发布到主题的消息会被转发给订阅消费组中的消费实例。消费实例可以是单独进程，或者单独机器。</p>\n<p>如果所有的消费实例都属于同个消费组，那么这就像是一个传统的队列在各个消费者间负载均衡。</p>\n<p>如果所有的消费实例都属于不同的消费组，那么这就像是pub-sub模块，所有消息广播到所有消费者中。</p>\n<p>更通常的，但是，我们发现topics主题有小数目的consumer groups消费群体，用于每个“logical subscriber”逻辑订阅者。每一组由许多可扩展和容错的消费实例组成，就是pub-sub语义上是消费群中的订阅者而不是一个单一的进程。</p>\n<p>kafka也比传统消息系统更强的排序保证。</p>\n<p>一个传统队列在服务器上顺序保留了消息，如果多个消费者从队列里消费，那么服务器会顺序处理保存的消息。但是，虽然服务器顺序分发消息，但是消息还是被异步转发给消费者，所以它们可能不是顺序到达不同的消费者。这明显意味着，消息的顺序性在并行消费面前失效了。消息系统经常通过一个“exclusive consumer”独家消费的概念来解决这个问题，即只允许一个进程从服务器消费，但是这意味着在进程中没有并行。</p>\n<img src=\"/2016/03/23/kafka-0-9-0/consumer-groups.png\" alt=\"consumer-groups.png\" title=\"\">\n<p><em>一个2个服务器的kafka集群，用2个消费群组绑定了4个分区(p0-p3)。消费群A有2个消费实例，消费群B有4个。</em></p>\n<p>kafka在这方面做的更好。通过一个在主题中的并行(parallelism)概念－分区，kafka不仅可以保证顺序，而且还可以在消费进程池里面负载均衡。这个通过赋予消费群里的消费者主题分区实现，在一个组里面每一个分区被一个消费者消费。通过这个，我们保证消费者是分区里的唯一读取者并且顺序消费数据。所以有很多这样的分区仍在很多消费者实例中负载均衡。但是要注意，在一个消费群里面不可能有比分区更多的消费实例。</p>\n<p>kafka只在一个分区内提供全序消息，而不是在分类里的分区之间。对于大部分应用来说，预分区通过key分区数据的能力已经足够了。但是，如果你请求一个全序消息，这只能在一个只有一个分区的分类里实现，虽然这意味着一个消费者处理一个消费群。</p>\n<p><strong>Guarantees 保证</strong></p>\n<p>高级kafka给出以下保证：</p>\n<ul>\n<li>生产者发送消息到一个指定的分类分区将会被顺序添加。那就是说，如果消息m1和m2被同样的生产者发送，m1先发送，然后m1将会比m2低一点偏移，在日志中出现的更早。</li>\n<li>一个消费实例顺序看到在日志中存储的消息。</li>\n<li>对于一个分类冗余因子n，我们将容忍n-1个服务器丢失提交给日志的信息。</li>\n</ul>\n<p>更多这些保证的详细信息会在文档的设计部分给出。</p>\n<h3 id=\"使用案例\"><a href=\"#使用案例\" class=\"headerlink\" title=\"使用案例\"></a>使用案例</h3><p>以下是一些apache kafka常见使用案例的描述。要查看这些领域的更多概述，请看这个<a href=\"https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying\" target=\"_blank\" rel=\"external\">blog</a>.</p>\n<p><strong>messaging消息传递</strong></p>\n<p>作为一个传统消息代理的替代者，kafka运作的很好。消息代理基于很多种原因使用（从数据生产者中解耦，缓存还没处理的消息等等）。与大部分消息系统对比，kafka有更好的吞吐量，内置分区，冗余和容错机制，使得它能够很好的置身于大规模消息处理的应用中。</p>\n<p>以我们的经验，消息传递使用通常相当于低吞吐量，但是端对端低延时，基于kafka提供的高持久保证。</p>\n<p>在这个领域，kafka可以比得上传统的消息系统比如<a href=\"http://activemq.apache.org/\" target=\"_blank\" rel=\"external\">ActiveMQ</a>或者<a href=\"https://www.rabbitmq.com/\" target=\"_blank\" rel=\"external\">RabbitMQ</a>。</p>\n<p><strong>网站行为轨迹</strong></p>\n<p>kafka的最初用途是可以重建一个用户的行为轨迹线作为一组实时的发布－订阅feed。这意味着网站活动（比如pv，搜索，或者其他可获得的用户行为）会以每个行为类型一个topic分类的发布到中央topic。这些feed被一系列用途使用，包括实时进程、实时监控、加载进hadoop或者离线数据仓库系统做离线处理和报告。</p>\n<p>活跃的轨迹通常包含了高容量的每个用户pv产生的活跃信息。</p>\n<p><strong>Metrics度量</strong></p>\n<p>kafka经常被用来运转中监控数据，这需要从分布式应用中，生产集中运转中的数据feed，然后汇总统计。</p>\n<p><strong>日志聚合</strong></p>\n<p>很多朋友用kafka作为日志聚合的一个解决替代方案。典型的，日志聚合线下收集物理日志文件，然后把它们放入一个集中的地方（一个文件系统或者HDFS）来处理。kafka理论上远离了文件细节，给了一个更干净的文件抽象概念，甚至数据作为信息流。这对多种数据源和分布式数据消费有着低延迟和更好的支持。相比于日志中心系统比如scribe和flume，kafka同样提供高性能，强持久冗余保证和更低的端对端延迟。</p>\n<p><strong>流式处理</strong></p>\n<p>很多用户都是最终阶段处理那些从分类消费而来的未经处理的数据，然后汇总，丰富，或者转换进新的kafka分类作进一步的消费。例如一个文章推荐处理流程可能是先从rss feed流中爬文章内容，然后发布到’articles’分类中；更进一步的处理可能是规范化或者对内容去重，扔到一个放干净文章内容的分类里；最后一步可能是匹配这些内容给相关用户。这创建了一个有别于个别分类的实时数据流曲线图。<a href=\"https://storm.apache.org/\" target=\"_blank\" rel=\"external\">Storm</a>和<a href=\"http://samza.apache.org/\" target=\"_blank\" rel=\"external\">Samza</a>是实现这些转换的流行框架。</p>\n<p><strong>事件源</strong></p>\n<p>事件源是一种状态改变以时间顺序记录的一种应用设计方式。用这种方式，kafka以非常大的存储日志数据支持使的它成为一个应用极好的后端。</p>\n<p><strong>日志提交</strong></p>\n<p>kafka可以以一种外在的日志提交为分布式系统服务。这个日志帮助在节点之间复制数据，和作为一种预同步机制为那些失败节点恢复数据。kafka的这个<a href=\"http://kafka.apache.org/documentation.html#compaction\" target=\"_blank\" rel=\"external\">log compaction</a>特点帮助支持了这个用例。在这个用法上kafka和<a href=\"http://zookeeper.apache.org/bookkeeper/\" target=\"_blank\" rel=\"external\">Apache BookKeeper</a>项目类似。</p>\n<h3 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h3><p>这部分指导假定你是从新开始，没有kafka或者zookeeper数据。</p>\n<p><strong>第一步：下载源代码</strong></p>\n<p><a href=\"https://www.apache.org/dyn/closer.cgi?path=/kafka/0.9.0.0/kafka_2.11-0.9.0.0.tgz\" target=\"_blank\" rel=\"external\">下载</a>0.9.0.0版本，然后解压它。</p>\n<pre><code>&gt; tar -xzf kafka_2.11-0.9.0.0.tgz\n&gt; cd kafka_2.11-0.9.0.0\n</code></pre><p><strong>第二步：启动服务</strong></p>\n<p>kafka用了zookeeper，所以你需要首先启动zookeeper服务。你可以用kafka包里面的简单脚本来启动一个快速简便的单一节点zookeeper实例。</p>\n<pre><code>&gt; bin/zookeeper-server-start.sh config/zookeeper.properties\n[2013-04-22 15:01:37,495] INFO Reading configuration from: config/zookeeper.properties (org.apache.zookeeper.server.quorum.QuorumPeerConfig)\n</code></pre><p>…</p>\n<p>现在启动kafka服务：</p>\n<pre><code>&gt; bin/kafka-server-start.sh config/server.properties\n[2013-04-22 15:01:47,028] INFO Verifying properties (kafka.utils.VerifiableProperties)\n</code></pre><p>[2013-04-22 15:01:47,051] INFO Property socket.send.buffer.bytes is overridden to 1048576 (kafka.utils.VerifiableProperties)<br>…</p>\n<p><strong>第三步：创建一个分类</strong></p>\n<p>让我们创建一个名叫”test”的分类，仅有一个分区和复制：</p>\n<pre><code>&gt; bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test\n</code></pre><p>现在我们可以看见这个分类，如果执行了列出分类的命令：</p>\n<pre><code>&gt; bin/kafka-topics.sh --list --zookeeper localhost:2181\ntest\n</code></pre><p>或者不手动创建分类，你可以配置你的服务器，当一个不存在的分类发布时自动创建这个分类。</p>\n<p><strong>第四步：发送一些消息</strong></p>\n<p>kafka自带一个命令行客户端，这个可以从一个文件或者表格式得到输入，然后作为消息发送到kafka集群。默认的，每一行作为一个单独的消息被送出。</p>\n<p>运行生产者，然后输入一些消息进控制台发送到服务器。</p>\n<pre><code>&gt; bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test\nThis is a message\nThis is another message\n</code></pre><p><strong>第五步：启动一个消费者</strong></p>\n<p>kafka也有一个消费者命令行，将消息转储到标准输出。</p>\n<pre><code>&gt; bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginning\nThis is a message\nThis is another message\n</code></pre><p>如果你在不同终端运行着以上命令，那么你应当可以输入消息到生产者终端，然后在消费者终端出现这些消息。</p>\n<p>所有的命令后工具都有额外的选项；不带参数运行命令将会显示出更多用法的详细信息。</p>\n<p><strong>第六步：设置多服务器集群</strong></p>\n<p>到目前为止，我们已经执行了一个单一服务器，但是这没什么意思。对于kafka，一个单一服务器仅仅是集群中的一个，所以启动更多的服务器实例将没有太多改变。但是为了感受一下，我们还是扩充我们的集群到3个节点（还是在我们的本地机器上）。</p>\n<p>首先我们为每一个broker服务器生成一个配置文件：</p>\n<pre><code>&gt; cp config/server.properties config/server-1.properties\n&gt; cp config/server.properties config/server-2.properties\n</code></pre><p>现在编辑这些新的文件，设置如下内容：</p>\n<pre><code>config/server-1.properties:\nbroker.id=1\nport=9093\nlog.dir=/tmp/kafka-logs-1\n\nconfig/server-2.properties:\nbroker.id=2\nport=9094\nlog.dir=/tmp/kafka-logs-2\n</code></pre><p>在集群的每一个节点中，这个broker.id是唯一和永久的名字。我们修改了端口和日志目录，因为我们是在相同的机器上运行这些，并且想让服务器都注册到相同的端口，彼此覆盖数据。</p>\n<p>我们已经有了zookeeper，我们的单一节点也启动了，所以我们只要启动下面两个新节点：</p>\n<pre><code>&gt; bin/kafka-server-start.sh config/server-1.properties &amp;\n...\n&gt; bin/kafka-server-start.sh config/server-2.properties &amp;\n...\n</code></pre><p>现在创建一个新的具有3个冗余因子的分类：</p>\n<pre><code>&gt; bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic my-replicated-topic\n</code></pre><p>好了，我们有了一个集群，但是我们如何知道每一个broker服务器在干什么呢？</p>\n","site":{"data":{}},"excerpt":"<p><em>原文：<a href=\"http://kafka.apache.org/documentation.html\" target=\"_blank\" rel=\"external\">http://kafka.apache.org/documentation.html</a></em></p>\n<blockquote>\n<p>自己翻译的kafka官方文档（哈哈），持续更新中。。。</p>\n</blockquote>","more":"<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>kafka是一个分布式的(distributed)，分区的(partitioned)，可复制的(replicated) commit log 服务。它提供了作为一个消息系统的常用功能，但又有独一无二的设计。</p>\n<p>什么意思呢？</p>\n<p>首先，让我们回顾一些基本的消息术语：</p>\n<ul>\n<li><p>kafka维持消息流分类的称作topics.</p>\n</li>\n<li><p>我们称处理发布消息到kafka topic的为producers.</p>\n</li>\n<li><p>我们称处理从topics中订阅并且处理已发布的消息流为consumers.</p>\n</li>\n</ul>\n<p>所以，以一个高层次来说，producers通过网络发送消息给kafka集群，集群轮流把它们提供给consumers，如下图：</p>\n<img src=\"/2016/03/23/kafka-0-9-0/producer_consumer.png\" alt=\"producer_consumer.png\" title=\"\">\n<p>客户端和服务器之间的交流是以一个单一，高性能，跨语言的tcp协议完成。我们为kafka提供了一个java客户端，但是客户端可以是很多其他语言。</p>\n<p><strong>topics 和 logs</strong></p>\n<p>让我们首先投入到kafka提供的高级抽象概念－topic</p>\n<p>一个topic就是一个种类或者是已发布消息的名称。对于每一个topic，kafka集群(cluster)维持一个分区日志如下图：</p>\n<img src=\"/2016/03/23/kafka-0-9-0/log_anatomy.png\" alt=\"log_anatomy.png\" title=\"\">\n<p>每一区都是一系列顺序的，不可改变的消息，消息被连续添加到一个commit log。在分区里的消息都被赋予一个序列id号称作offset，在相应区里面是唯一的。</p>\n<p>在一个可以配置的时间段里，kafka保留所有已发布的消息，无论它们是否被消费。例如，如果日志保留时间设置为2天，那么一个消息在发布后的两天内对于消费者是有效的，之后它将会被丢弃从而释放空间。在数据大小方面而言，kafka的性能持续有效，所以保留大量数据没有问题。</p>\n<p>事实上，在日志中以每一个消费者的方式保留的唯一元数据是消费者的位置，称作“offset”。这个偏移量由消费者控制：当消费者读消息的时候将线性推进它的偏移量，但是事实上该位置由消费者控制，它可以以任何顺序消费消息。例如，一个消费者可以重置到一个旧的偏移量重新执行。</p>\n<p>这些混合的特征意味着kafka消费者非常廉价，它们可以在集群或者其他消费者之间来或去，而没有太多影响。例如，当一些现存的消费者在消费一些主题内容时，你可以用我们的命令行工具来“tail”出这些内容而不会改变什么。</p>\n<p>在日志服务中的分区有以下几个目的：首先，它们允许日志按大小比例适应每一个服务器。每一个分区必须适应绑定它的服务器，但是一个主题可能有很多分区，所以它可以随意处理很多数据。第二，它们以相似的单位行动，跟多的是以位。</p>\n<p><strong>Distribution 分布式</strong></p>\n<p>日志分区分布在kafka集群中的各个服务器上，每一个服务器处理来自一串分区的请求和数据。为了容错，每一个分区会在配置数量的服务器间复制。</p>\n<p>每一个分区都有一个服务器作为“leader”－领导者，0或多个服务器当作“followers”－追随者。领导者处理所有来自分区的读和写请求，而追随者被动的从领导者那复制。如果领导者失败了，其中一个追随者将自动成为领导者。（这里有一个疑问，是随机一个follower称为leader吗？）在集群内，每一个服务器在一些分区中扮演一个领导者，而在其他分区中扮演一个追随者，所以可以平衡运行。</p>\n<p><strong>Producers 生产者</strong></p>\n<p>生产者们发布数据到它们选择的主题里。生产者在主题里有责任选择消息分配到哪个分区里。这可以在仅仅一个循环内进行平衡加载，或者根据某些语义分区函数完成（根据消息中的一些key）。更多分区用法在第二章。</p>\n<p><strong>Consumers 消费者</strong></p>\n<p>传统消息有2个模块：<em>queuing</em>和<em>publish-subscribe</em>。在一个队列里，一个消费者池从一个服务器中读取消息，然后消息到达它们中的一个；而在publish-subscribe模式中，消息被广播到所有消费者中。kafka提出一个单一的消费者抽象概念，概括了这2个模块－<em>consumer group</em>消费组</p>\n<p>消费者用消费组名称作标签，每一个发布到主题的消息会被转发给订阅消费组中的消费实例。消费实例可以是单独进程，或者单独机器。</p>\n<p>如果所有的消费实例都属于同个消费组，那么这就像是一个传统的队列在各个消费者间负载均衡。</p>\n<p>如果所有的消费实例都属于不同的消费组，那么这就像是pub-sub模块，所有消息广播到所有消费者中。</p>\n<p>更通常的，但是，我们发现topics主题有小数目的consumer groups消费群体，用于每个“logical subscriber”逻辑订阅者。每一组由许多可扩展和容错的消费实例组成，就是pub-sub语义上是消费群中的订阅者而不是一个单一的进程。</p>\n<p>kafka也比传统消息系统更强的排序保证。</p>\n<p>一个传统队列在服务器上顺序保留了消息，如果多个消费者从队列里消费，那么服务器会顺序处理保存的消息。但是，虽然服务器顺序分发消息，但是消息还是被异步转发给消费者，所以它们可能不是顺序到达不同的消费者。这明显意味着，消息的顺序性在并行消费面前失效了。消息系统经常通过一个“exclusive consumer”独家消费的概念来解决这个问题，即只允许一个进程从服务器消费，但是这意味着在进程中没有并行。</p>\n<img src=\"/2016/03/23/kafka-0-9-0/consumer-groups.png\" alt=\"consumer-groups.png\" title=\"\">\n<p><em>一个2个服务器的kafka集群，用2个消费群组绑定了4个分区(p0-p3)。消费群A有2个消费实例，消费群B有4个。</em></p>\n<p>kafka在这方面做的更好。通过一个在主题中的并行(parallelism)概念－分区，kafka不仅可以保证顺序，而且还可以在消费进程池里面负载均衡。这个通过赋予消费群里的消费者主题分区实现，在一个组里面每一个分区被一个消费者消费。通过这个，我们保证消费者是分区里的唯一读取者并且顺序消费数据。所以有很多这样的分区仍在很多消费者实例中负载均衡。但是要注意，在一个消费群里面不可能有比分区更多的消费实例。</p>\n<p>kafka只在一个分区内提供全序消息，而不是在分类里的分区之间。对于大部分应用来说，预分区通过key分区数据的能力已经足够了。但是，如果你请求一个全序消息，这只能在一个只有一个分区的分类里实现，虽然这意味着一个消费者处理一个消费群。</p>\n<p><strong>Guarantees 保证</strong></p>\n<p>高级kafka给出以下保证：</p>\n<ul>\n<li>生产者发送消息到一个指定的分类分区将会被顺序添加。那就是说，如果消息m1和m2被同样的生产者发送，m1先发送，然后m1将会比m2低一点偏移，在日志中出现的更早。</li>\n<li>一个消费实例顺序看到在日志中存储的消息。</li>\n<li>对于一个分类冗余因子n，我们将容忍n-1个服务器丢失提交给日志的信息。</li>\n</ul>\n<p>更多这些保证的详细信息会在文档的设计部分给出。</p>\n<h3 id=\"使用案例\"><a href=\"#使用案例\" class=\"headerlink\" title=\"使用案例\"></a>使用案例</h3><p>以下是一些apache kafka常见使用案例的描述。要查看这些领域的更多概述，请看这个<a href=\"https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying\" target=\"_blank\" rel=\"external\">blog</a>.</p>\n<p><strong>messaging消息传递</strong></p>\n<p>作为一个传统消息代理的替代者，kafka运作的很好。消息代理基于很多种原因使用（从数据生产者中解耦，缓存还没处理的消息等等）。与大部分消息系统对比，kafka有更好的吞吐量，内置分区，冗余和容错机制，使得它能够很好的置身于大规模消息处理的应用中。</p>\n<p>以我们的经验，消息传递使用通常相当于低吞吐量，但是端对端低延时，基于kafka提供的高持久保证。</p>\n<p>在这个领域，kafka可以比得上传统的消息系统比如<a href=\"http://activemq.apache.org/\" target=\"_blank\" rel=\"external\">ActiveMQ</a>或者<a href=\"https://www.rabbitmq.com/\" target=\"_blank\" rel=\"external\">RabbitMQ</a>。</p>\n<p><strong>网站行为轨迹</strong></p>\n<p>kafka的最初用途是可以重建一个用户的行为轨迹线作为一组实时的发布－订阅feed。这意味着网站活动（比如pv，搜索，或者其他可获得的用户行为）会以每个行为类型一个topic分类的发布到中央topic。这些feed被一系列用途使用，包括实时进程、实时监控、加载进hadoop或者离线数据仓库系统做离线处理和报告。</p>\n<p>活跃的轨迹通常包含了高容量的每个用户pv产生的活跃信息。</p>\n<p><strong>Metrics度量</strong></p>\n<p>kafka经常被用来运转中监控数据，这需要从分布式应用中，生产集中运转中的数据feed，然后汇总统计。</p>\n<p><strong>日志聚合</strong></p>\n<p>很多朋友用kafka作为日志聚合的一个解决替代方案。典型的，日志聚合线下收集物理日志文件，然后把它们放入一个集中的地方（一个文件系统或者HDFS）来处理。kafka理论上远离了文件细节，给了一个更干净的文件抽象概念，甚至数据作为信息流。这对多种数据源和分布式数据消费有着低延迟和更好的支持。相比于日志中心系统比如scribe和flume，kafka同样提供高性能，强持久冗余保证和更低的端对端延迟。</p>\n<p><strong>流式处理</strong></p>\n<p>很多用户都是最终阶段处理那些从分类消费而来的未经处理的数据，然后汇总，丰富，或者转换进新的kafka分类作进一步的消费。例如一个文章推荐处理流程可能是先从rss feed流中爬文章内容，然后发布到’articles’分类中；更进一步的处理可能是规范化或者对内容去重，扔到一个放干净文章内容的分类里；最后一步可能是匹配这些内容给相关用户。这创建了一个有别于个别分类的实时数据流曲线图。<a href=\"https://storm.apache.org/\" target=\"_blank\" rel=\"external\">Storm</a>和<a href=\"http://samza.apache.org/\" target=\"_blank\" rel=\"external\">Samza</a>是实现这些转换的流行框架。</p>\n<p><strong>事件源</strong></p>\n<p>事件源是一种状态改变以时间顺序记录的一种应用设计方式。用这种方式，kafka以非常大的存储日志数据支持使的它成为一个应用极好的后端。</p>\n<p><strong>日志提交</strong></p>\n<p>kafka可以以一种外在的日志提交为分布式系统服务。这个日志帮助在节点之间复制数据，和作为一种预同步机制为那些失败节点恢复数据。kafka的这个<a href=\"http://kafka.apache.org/documentation.html#compaction\" target=\"_blank\" rel=\"external\">log compaction</a>特点帮助支持了这个用例。在这个用法上kafka和<a href=\"http://zookeeper.apache.org/bookkeeper/\" target=\"_blank\" rel=\"external\">Apache BookKeeper</a>项目类似。</p>\n<h3 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h3><p>这部分指导假定你是从新开始，没有kafka或者zookeeper数据。</p>\n<p><strong>第一步：下载源代码</strong></p>\n<p><a href=\"https://www.apache.org/dyn/closer.cgi?path=/kafka/0.9.0.0/kafka_2.11-0.9.0.0.tgz\" target=\"_blank\" rel=\"external\">下载</a>0.9.0.0版本，然后解压它。</p>\n<pre><code>&gt; tar -xzf kafka_2.11-0.9.0.0.tgz\n&gt; cd kafka_2.11-0.9.0.0\n</code></pre><p><strong>第二步：启动服务</strong></p>\n<p>kafka用了zookeeper，所以你需要首先启动zookeeper服务。你可以用kafka包里面的简单脚本来启动一个快速简便的单一节点zookeeper实例。</p>\n<pre><code>&gt; bin/zookeeper-server-start.sh config/zookeeper.properties\n[2013-04-22 15:01:37,495] INFO Reading configuration from: config/zookeeper.properties (org.apache.zookeeper.server.quorum.QuorumPeerConfig)\n</code></pre><p>…</p>\n<p>现在启动kafka服务：</p>\n<pre><code>&gt; bin/kafka-server-start.sh config/server.properties\n[2013-04-22 15:01:47,028] INFO Verifying properties (kafka.utils.VerifiableProperties)\n</code></pre><p>[2013-04-22 15:01:47,051] INFO Property socket.send.buffer.bytes is overridden to 1048576 (kafka.utils.VerifiableProperties)<br>…</p>\n<p><strong>第三步：创建一个分类</strong></p>\n<p>让我们创建一个名叫”test”的分类，仅有一个分区和复制：</p>\n<pre><code>&gt; bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test\n</code></pre><p>现在我们可以看见这个分类，如果执行了列出分类的命令：</p>\n<pre><code>&gt; bin/kafka-topics.sh --list --zookeeper localhost:2181\ntest\n</code></pre><p>或者不手动创建分类，你可以配置你的服务器，当一个不存在的分类发布时自动创建这个分类。</p>\n<p><strong>第四步：发送一些消息</strong></p>\n<p>kafka自带一个命令行客户端，这个可以从一个文件或者表格式得到输入，然后作为消息发送到kafka集群。默认的，每一行作为一个单独的消息被送出。</p>\n<p>运行生产者，然后输入一些消息进控制台发送到服务器。</p>\n<pre><code>&gt; bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test\nThis is a message\nThis is another message\n</code></pre><p><strong>第五步：启动一个消费者</strong></p>\n<p>kafka也有一个消费者命令行，将消息转储到标准输出。</p>\n<pre><code>&gt; bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginning\nThis is a message\nThis is another message\n</code></pre><p>如果你在不同终端运行着以上命令，那么你应当可以输入消息到生产者终端，然后在消费者终端出现这些消息。</p>\n<p>所有的命令后工具都有额外的选项；不带参数运行命令将会显示出更多用法的详细信息。</p>\n<p><strong>第六步：设置多服务器集群</strong></p>\n<p>到目前为止，我们已经执行了一个单一服务器，但是这没什么意思。对于kafka，一个单一服务器仅仅是集群中的一个，所以启动更多的服务器实例将没有太多改变。但是为了感受一下，我们还是扩充我们的集群到3个节点（还是在我们的本地机器上）。</p>\n<p>首先我们为每一个broker服务器生成一个配置文件：</p>\n<pre><code>&gt; cp config/server.properties config/server-1.properties\n&gt; cp config/server.properties config/server-2.properties\n</code></pre><p>现在编辑这些新的文件，设置如下内容：</p>\n<pre><code>config/server-1.properties:\nbroker.id=1\nport=9093\nlog.dir=/tmp/kafka-logs-1\n\nconfig/server-2.properties:\nbroker.id=2\nport=9094\nlog.dir=/tmp/kafka-logs-2\n</code></pre><p>在集群的每一个节点中，这个broker.id是唯一和永久的名字。我们修改了端口和日志目录，因为我们是在相同的机器上运行这些，并且想让服务器都注册到相同的端口，彼此覆盖数据。</p>\n<p>我们已经有了zookeeper，我们的单一节点也启动了，所以我们只要启动下面两个新节点：</p>\n<pre><code>&gt; bin/kafka-server-start.sh config/server-1.properties &amp;\n...\n&gt; bin/kafka-server-start.sh config/server-2.properties &amp;\n...\n</code></pre><p>现在创建一个新的具有3个冗余因子的分类：</p>\n<pre><code>&gt; bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic my-replicated-topic\n</code></pre><p>好了，我们有了一个集群，但是我们如何知道每一个broker服务器在干什么呢？</p>"},{"title":"浮点数几个易错点","date":"2016-04-05T09:12:46.000Z","photos":["http://7xsaff.com1.z0.glb.clouddn.com/2016/0405/12.pic.jpg"],"description":"决不要将未知的分数强制转换为int类型，这样有时会导致不可预料的结果。","_content":"参看资料:\n>浮点数指南：http://floating-point-gui.de/ (后面我会翻译)\nphp官方文档：\nhttp://php.net/manual/zh/language.types.float.php\nhttp://php.net/manual/zh/language.types.integer.php#language.types.integer.casting\nhttp://php.net/manual/zh/language.types.type-juggling.php\n\n先来看个例子eg1.\n\n``` php\n<?php\n$n = \"19.99\";\nprint intval($n * 100).chr(10);\nprint intval(strval($n*100));\n\t\n```\n\n得出来的结果是：1998和1999\n\n另外一个例子eg2.\n\n``` php\n<?php\necho (int) ((0.1+0.7) * 10);\n\n```\n\n结果是：7\n\n官方文档给出的警告是：\n\n>决不要将未知的分数强制转换为int类型，这样有时会导致不可预料的结果。\n\n在例子1中，$n与100相乘后被转换为了浮点数，实际上是1998.99999999999984368059813278E1，强制转换为整数后就为1998.\n\n例子2也是，未转换前的结果实际是7.9999999999999991118...，强制转换后为7.\n\n所以正如官网上所说:\n\n>永远不要相信浮点数精确到了最后一位，也永远不要直接比较俩浮点数是否相等。\n\n比如下面的例子eg3.\n\n```php\n<?php\n$x = 8 - 6.4;\n$y = 1.6;\nvar_dump($x == $y);\n```\n结果并不相等，因为$x实际已经不是1.6了，而是1.5999999.... var_dump只是给你显示最近的数1.6\n","source":"_posts/2016-04-05-float.md","raw":"---\ntitle: 浮点数几个易错点\ndate: 2016-04-05 17:12:46\ntags: php\ncategories: php\nphotos:\n- http://7xsaff.com1.z0.glb.clouddn.com/2016/0405/12.pic.jpg\ndescription: 决不要将未知的分数强制转换为int类型，这样有时会导致不可预料的结果。\n---\n参看资料:\n>浮点数指南：http://floating-point-gui.de/ (后面我会翻译)\nphp官方文档：\nhttp://php.net/manual/zh/language.types.float.php\nhttp://php.net/manual/zh/language.types.integer.php#language.types.integer.casting\nhttp://php.net/manual/zh/language.types.type-juggling.php\n\n先来看个例子eg1.\n\n``` php\n<?php\n$n = \"19.99\";\nprint intval($n * 100).chr(10);\nprint intval(strval($n*100));\n\t\n```\n\n得出来的结果是：1998和1999\n\n另外一个例子eg2.\n\n``` php\n<?php\necho (int) ((0.1+0.7) * 10);\n\n```\n\n结果是：7\n\n官方文档给出的警告是：\n\n>决不要将未知的分数强制转换为int类型，这样有时会导致不可预料的结果。\n\n在例子1中，$n与100相乘后被转换为了浮点数，实际上是1998.99999999999984368059813278E1，强制转换为整数后就为1998.\n\n例子2也是，未转换前的结果实际是7.9999999999999991118...，强制转换后为7.\n\n所以正如官网上所说:\n\n>永远不要相信浮点数精确到了最后一位，也永远不要直接比较俩浮点数是否相等。\n\n比如下面的例子eg3.\n\n```php\n<?php\n$x = 8 - 6.4;\n$y = 1.6;\nvar_dump($x == $y);\n```\n结果并不相等，因为$x实际已经不是1.6了，而是1.5999999.... var_dump只是给你显示最近的数1.6\n","slug":"float","published":1,"updated":"2017-09-18T11:36:51.000Z","comments":1,"layout":"post","link":"","_id":"cj7q4uqz90006kkjez3mjgzxw","content":"<p>参看资料:</p>\n<blockquote>\n<p>浮点数指南：<a href=\"http://floating-point-gui.de/\" target=\"_blank\" rel=\"external\">http://floating-point-gui.de/</a> (后面我会翻译)<br>php官方文档：<br><a href=\"http://php.net/manual/zh/language.types.float.php\" target=\"_blank\" rel=\"external\">http://php.net/manual/zh/language.types.float.php</a><br><a href=\"http://php.net/manual/zh/language.types.integer.php#language.types.integer.casting\" target=\"_blank\" rel=\"external\">http://php.net/manual/zh/language.types.integer.php#language.types.integer.casting</a><br><a href=\"http://php.net/manual/zh/language.types.type-juggling.php\" target=\"_blank\" rel=\"external\">http://php.net/manual/zh/language.types.type-juggling.php</a></p>\n</blockquote>\n<p>先来看个例子eg1.</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\">$n = <span class=\"string\">\"19.99\"</span>;</div><div class=\"line\"><span class=\"keyword\">print</span> intval($n * <span class=\"number\">100</span>).chr(<span class=\"number\">10</span>);</div><div class=\"line\"><span class=\"keyword\">print</span> intval(strval($n*<span class=\"number\">100</span>));</div></pre></td></tr></table></figure>\n<p>得出来的结果是：1998和1999</p>\n<p>另外一个例子eg2.</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"><span class=\"keyword\">echo</span> (int) ((<span class=\"number\">0.1</span>+<span class=\"number\">0.7</span>) * <span class=\"number\">10</span>);</div></pre></td></tr></table></figure>\n<p>结果是：7</p>\n<p>官方文档给出的警告是：</p>\n<blockquote>\n<p>决不要将未知的分数强制转换为int类型，这样有时会导致不可预料的结果。</p>\n</blockquote>\n<p>在例子1中，$n与100相乘后被转换为了浮点数，实际上是1998.99999999999984368059813278E1，强制转换为整数后就为1998.</p>\n<p>例子2也是，未转换前的结果实际是7.9999999999999991118…，强制转换后为7.</p>\n<p>所以正如官网上所说:</p>\n<blockquote>\n<p>永远不要相信浮点数精确到了最后一位，也永远不要直接比较俩浮点数是否相等。</p>\n</blockquote>\n<p>比如下面的例子eg3.</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\">$x = <span class=\"number\">8</span> - <span class=\"number\">6.4</span>;</div><div class=\"line\">$y = <span class=\"number\">1.6</span>;</div><div class=\"line\">var_dump($x == $y);</div></pre></td></tr></table></figure>\n<p>结果并不相等，因为$x实际已经不是1.6了，而是1.5999999…. var_dump只是给你显示最近的数1.6</p>\n","site":{"data":{}},"excerpt":"","more":"<p>参看资料:</p>\n<blockquote>\n<p>浮点数指南：<a href=\"http://floating-point-gui.de/\" target=\"_blank\" rel=\"external\">http://floating-point-gui.de/</a> (后面我会翻译)<br>php官方文档：<br><a href=\"http://php.net/manual/zh/language.types.float.php\" target=\"_blank\" rel=\"external\">http://php.net/manual/zh/language.types.float.php</a><br><a href=\"http://php.net/manual/zh/language.types.integer.php#language.types.integer.casting\" target=\"_blank\" rel=\"external\">http://php.net/manual/zh/language.types.integer.php#language.types.integer.casting</a><br><a href=\"http://php.net/manual/zh/language.types.type-juggling.php\" target=\"_blank\" rel=\"external\">http://php.net/manual/zh/language.types.type-juggling.php</a></p>\n</blockquote>\n<p>先来看个例子eg1.</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\">$n = <span class=\"string\">\"19.99\"</span>;</div><div class=\"line\"><span class=\"keyword\">print</span> intval($n * <span class=\"number\">100</span>).chr(<span class=\"number\">10</span>);</div><div class=\"line\"><span class=\"keyword\">print</span> intval(strval($n*<span class=\"number\">100</span>));</div></pre></td></tr></table></figure>\n<p>得出来的结果是：1998和1999</p>\n<p>另外一个例子eg2.</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"><span class=\"keyword\">echo</span> (int) ((<span class=\"number\">0.1</span>+<span class=\"number\">0.7</span>) * <span class=\"number\">10</span>);</div></pre></td></tr></table></figure>\n<p>结果是：7</p>\n<p>官方文档给出的警告是：</p>\n<blockquote>\n<p>决不要将未知的分数强制转换为int类型，这样有时会导致不可预料的结果。</p>\n</blockquote>\n<p>在例子1中，$n与100相乘后被转换为了浮点数，实际上是1998.99999999999984368059813278E1，强制转换为整数后就为1998.</p>\n<p>例子2也是，未转换前的结果实际是7.9999999999999991118…，强制转换后为7.</p>\n<p>所以正如官网上所说:</p>\n<blockquote>\n<p>永远不要相信浮点数精确到了最后一位，也永远不要直接比较俩浮点数是否相等。</p>\n</blockquote>\n<p>比如下面的例子eg3.</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\">$x = <span class=\"number\">8</span> - <span class=\"number\">6.4</span>;</div><div class=\"line\">$y = <span class=\"number\">1.6</span>;</div><div class=\"line\">var_dump($x == $y);</div></pre></td></tr></table></figure>\n<p>结果并不相等，因为$x实际已经不是1.6了，而是1.5999999…. var_dump只是给你显示最近的数1.6</p>\n"},{"title":"常见算法排序","date":"2016-04-07T03:19:15.000Z","_content":"\n几种常用的算法php实现。\n<!--more-->\n\n## 冒泡排序\n\n>冒泡排序(bubble sort)是一种交换排序，基本思想是：两两比较**相邻**纪录的关键字，如果反序则交换，直到没有反序的记录为止。(注意：是相邻) 时间复杂度为O(n^2)\n\n代码如下：\n\n```php\n<?php\n\nfunction swap(&$a, &$b)\n{\n    $t = $a; \n    $a = $b; \n    $b = $t; \n}\n\nfunction bubble($array)\n{\n    $length = count($array);\n    $t = ''; \n    $flag = true;\n\n    for ( $i = 0; $i < $length && $flag; ++$i) {\n        $flag = false;\n        for ( $j = $length-1; $j >= $i; $j-- ) { \n            if (!isset($array[$j+1])) continue;\n            if ( $array[$j] > $array[$j+1]) {\n                swap($array[$j], $array[$j+1]);\n                $flag = true;\n            }   \n        }   \n    }\n    return $array;\n}\n\n```\n\n## 简单选择排序\n\n>简单选择排序法(simple selection sort)就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i(1<=i<=n)个记录交换之。 时间复杂度为O(n^2)\n\n代码如下：\n\n```php\n<?php\n\nfunction swap(&$a, &$b)\n{\n    $t = $a; \n    $a = $b; \n    $b = $t; \n}\n\nfunction selectSort($array)\n{\n    $length = count($array);\n    $min = ''; \n\n    for ( $i= 0; $i<$length; ++$i) {\n        $min = $i; \n\n        for ( $j = $i+1; $j < $length; ++$j) {\n            if ( $array[$min] > $array[$j]) {\n                $min = $j; \n            }   \n        }   \n        if ( $i != $min ) { \n            swap($array[$i], $array[$min]);\n        }   \n    }   \n    return $array;\n}\n```\n\n## 插入排序\n\n>直接插入排序(straight insertion sort)，基本操作是将一个记录插入到已经排好序的有序表中，复杂度为O(n^2)，因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。描述如下\n\n1. 从第一个元素开始，该元素可以认为已经被排序\n2. 取出下一个元素，在已经排序的元素序列中从后向前扫描\n3. 如果该元素（已排序）大于新元素，将该元素移到下一位置\n4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置\n5. 将新元素插入到该位置后\n6. 重复步骤2~5\n\n代码如下：\n\n```php\n<?php\n\nfunction insertSort($array)\n{\n    $length = count($array);\n    $tmp = ''; \n\n    for ($i=1; $i<$length; ++$i) {\n        if ($array[$i] < $array[$i-1]) {\n            $tmp = $array[$i];\n            for ($j = $i-1; $j > -1 && $array[$j] > $tmp; --$j) {\n                $array[$j+1] = $array[$j];\n            }   \n            $array[$j+1] = $tmp;\n        }   \n    }   \n    return $array;\n}\n\n```\n\n## 希尔排序\n\n>希尔排序(shell sort)，不稳定排序。\n\n代码如下，增量为n/2：\n\n```php\n<?php\n\nfunction shellSort($array)\n{\n    $length = count($array);\n\n    for ($gap = $length >> 1; $gap > 0; $gap >>= 1) {\n        for ( $i = $gap; $i < count($array); ++$i ) { \n            $tmp = $array[$i];\n            for ( $j = $i - $gap; $j >= 0 && $array[$j] > $tmp; $j -= $gap ) { \n                $array[$j+$gap] = $array[$j];\n            }   \n            $array[$j+$gap] = $tmp;\n        }   \n    }   \n\n    return $array;\n}\n\n```","source":"_posts/2016-04-07-sort.md","raw":"---\ntitle: 常见算法排序\ndate: 2016-04-07 11:19:15\ntags: 排序\ncategories: 算法\n---\n\n几种常用的算法php实现。\n<!--more-->\n\n## 冒泡排序\n\n>冒泡排序(bubble sort)是一种交换排序，基本思想是：两两比较**相邻**纪录的关键字，如果反序则交换，直到没有反序的记录为止。(注意：是相邻) 时间复杂度为O(n^2)\n\n代码如下：\n\n```php\n<?php\n\nfunction swap(&$a, &$b)\n{\n    $t = $a; \n    $a = $b; \n    $b = $t; \n}\n\nfunction bubble($array)\n{\n    $length = count($array);\n    $t = ''; \n    $flag = true;\n\n    for ( $i = 0; $i < $length && $flag; ++$i) {\n        $flag = false;\n        for ( $j = $length-1; $j >= $i; $j-- ) { \n            if (!isset($array[$j+1])) continue;\n            if ( $array[$j] > $array[$j+1]) {\n                swap($array[$j], $array[$j+1]);\n                $flag = true;\n            }   \n        }   \n    }\n    return $array;\n}\n\n```\n\n## 简单选择排序\n\n>简单选择排序法(simple selection sort)就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i(1<=i<=n)个记录交换之。 时间复杂度为O(n^2)\n\n代码如下：\n\n```php\n<?php\n\nfunction swap(&$a, &$b)\n{\n    $t = $a; \n    $a = $b; \n    $b = $t; \n}\n\nfunction selectSort($array)\n{\n    $length = count($array);\n    $min = ''; \n\n    for ( $i= 0; $i<$length; ++$i) {\n        $min = $i; \n\n        for ( $j = $i+1; $j < $length; ++$j) {\n            if ( $array[$min] > $array[$j]) {\n                $min = $j; \n            }   \n        }   \n        if ( $i != $min ) { \n            swap($array[$i], $array[$min]);\n        }   \n    }   \n    return $array;\n}\n```\n\n## 插入排序\n\n>直接插入排序(straight insertion sort)，基本操作是将一个记录插入到已经排好序的有序表中，复杂度为O(n^2)，因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。描述如下\n\n1. 从第一个元素开始，该元素可以认为已经被排序\n2. 取出下一个元素，在已经排序的元素序列中从后向前扫描\n3. 如果该元素（已排序）大于新元素，将该元素移到下一位置\n4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置\n5. 将新元素插入到该位置后\n6. 重复步骤2~5\n\n代码如下：\n\n```php\n<?php\n\nfunction insertSort($array)\n{\n    $length = count($array);\n    $tmp = ''; \n\n    for ($i=1; $i<$length; ++$i) {\n        if ($array[$i] < $array[$i-1]) {\n            $tmp = $array[$i];\n            for ($j = $i-1; $j > -1 && $array[$j] > $tmp; --$j) {\n                $array[$j+1] = $array[$j];\n            }   \n            $array[$j+1] = $tmp;\n        }   \n    }   \n    return $array;\n}\n\n```\n\n## 希尔排序\n\n>希尔排序(shell sort)，不稳定排序。\n\n代码如下，增量为n/2：\n\n```php\n<?php\n\nfunction shellSort($array)\n{\n    $length = count($array);\n\n    for ($gap = $length >> 1; $gap > 0; $gap >>= 1) {\n        for ( $i = $gap; $i < count($array); ++$i ) { \n            $tmp = $array[$i];\n            for ( $j = $i - $gap; $j >= 0 && $array[$j] > $tmp; $j -= $gap ) { \n                $array[$j+$gap] = $array[$j];\n            }   \n            $array[$j+$gap] = $tmp;\n        }   \n    }   \n\n    return $array;\n}\n\n```","slug":"sort","published":1,"updated":"2017-09-18T11:36:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7q4uqza0007kkjehb2lanfe","content":"<p>几种常用的算法php实现。<br><a id=\"more\"></a></p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><blockquote>\n<p>冒泡排序(bubble sort)是一种交换排序，基本思想是：两两比较<strong>相邻</strong>纪录的关键字，如果反序则交换，直到没有反序的记录为止。(注意：是相邻) 时间复杂度为O(n^2)</p>\n</blockquote>\n<p>代码如下：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span><span class=\"params\">(&amp;$a, &amp;$b)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    $t = $a; </div><div class=\"line\">    $a = $b; </div><div class=\"line\">    $b = $t; </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubble</span><span class=\"params\">($array)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    $length = count($array);</div><div class=\"line\">    $t = <span class=\"string\">''</span>; </div><div class=\"line\">    $flag = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> ( $i = <span class=\"number\">0</span>; $i &lt; $length &amp;&amp; $flag; ++$i) &#123;</div><div class=\"line\">        $flag = <span class=\"keyword\">false</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> ( $j = $length<span class=\"number\">-1</span>; $j &gt;= $i; $j-- ) &#123; </div><div class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"keyword\">isset</span>($array[$j+<span class=\"number\">1</span>])) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> ( $array[$j] &gt; $array[$j+<span class=\"number\">1</span>]) &#123;</div><div class=\"line\">                swap($array[$j], $array[$j+<span class=\"number\">1</span>]);</div><div class=\"line\">                $flag = <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125;   </div><div class=\"line\">        &#125;   </div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> $array;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"简单选择排序\"><a href=\"#简单选择排序\" class=\"headerlink\" title=\"简单选择排序\"></a>简单选择排序</h2><blockquote>\n<p>简单选择排序法(simple selection sort)就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i(1&lt;=i&lt;=n)个记录交换之。 时间复杂度为O(n^2)</p>\n</blockquote>\n<p>代码如下：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span><span class=\"params\">(&amp;$a, &amp;$b)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    $t = $a; </div><div class=\"line\">    $a = $b; </div><div class=\"line\">    $b = $t; </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectSort</span><span class=\"params\">($array)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    $length = count($array);</div><div class=\"line\">    $min = <span class=\"string\">''</span>; </div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> ( $i= <span class=\"number\">0</span>; $i&lt;$length; ++$i) &#123;</div><div class=\"line\">        $min = $i; </div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> ( $j = $i+<span class=\"number\">1</span>; $j &lt; $length; ++$j) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> ( $array[$min] &gt; $array[$j]) &#123;</div><div class=\"line\">                $min = $j; </div><div class=\"line\">            &#125;   </div><div class=\"line\">        &#125;   </div><div class=\"line\">        <span class=\"keyword\">if</span> ( $i != $min ) &#123; </div><div class=\"line\">            swap($array[$i], $array[$min]);</div><div class=\"line\">        &#125;   </div><div class=\"line\">    &#125;   </div><div class=\"line\">    <span class=\"keyword\">return</span> $array;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><blockquote>\n<p>直接插入排序(straight insertion sort)，基本操作是将一个记录插入到已经排好序的有序表中，复杂度为O(n^2)，因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。描述如下</p>\n</blockquote>\n<ol>\n<li>从第一个元素开始，该元素可以认为已经被排序</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>\n<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>\n<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>\n<li>将新元素插入到该位置后</li>\n<li>重复步骤2~5</li>\n</ol>\n<p>代码如下：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertSort</span><span class=\"params\">($array)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    $length = count($array);</div><div class=\"line\">    $tmp = <span class=\"string\">''</span>; </div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> ($i=<span class=\"number\">1</span>; $i&lt;$length; ++$i) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> ($array[$i] &lt; $array[$i<span class=\"number\">-1</span>]) &#123;</div><div class=\"line\">            $tmp = $array[$i];</div><div class=\"line\">            <span class=\"keyword\">for</span> ($j = $i<span class=\"number\">-1</span>; $j &gt; <span class=\"number\">-1</span> &amp;&amp; $array[$j] &gt; $tmp; --$j) &#123;</div><div class=\"line\">                $array[$j+<span class=\"number\">1</span>] = $array[$j];</div><div class=\"line\">            &#125;   </div><div class=\"line\">            $array[$j+<span class=\"number\">1</span>] = $tmp;</div><div class=\"line\">        &#125;   </div><div class=\"line\">    &#125;   </div><div class=\"line\">    <span class=\"keyword\">return</span> $array;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h2><blockquote>\n<p>希尔排序(shell sort)，不稳定排序。</p>\n</blockquote>\n<p>代码如下，增量为n/2：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shellSort</span><span class=\"params\">($array)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    $length = count($array);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> ($gap = $length &gt;&gt; <span class=\"number\">1</span>; $gap &gt; <span class=\"number\">0</span>; $gap &gt;&gt;= <span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> ( $i = $gap; $i &lt; count($array); ++$i ) &#123; </div><div class=\"line\">            $tmp = $array[$i];</div><div class=\"line\">            <span class=\"keyword\">for</span> ( $j = $i - $gap; $j &gt;= <span class=\"number\">0</span> &amp;&amp; $array[$j] &gt; $tmp; $j -= $gap ) &#123; </div><div class=\"line\">                $array[$j+$gap] = $array[$j];</div><div class=\"line\">            &#125;   </div><div class=\"line\">            $array[$j+$gap] = $tmp;</div><div class=\"line\">        &#125;   </div><div class=\"line\">    &#125;   </div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> $array;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>几种常用的算法php实现。<br>","more":"</p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><blockquote>\n<p>冒泡排序(bubble sort)是一种交换排序，基本思想是：两两比较<strong>相邻</strong>纪录的关键字，如果反序则交换，直到没有反序的记录为止。(注意：是相邻) 时间复杂度为O(n^2)</p>\n</blockquote>\n<p>代码如下：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span><span class=\"params\">(&amp;$a, &amp;$b)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    $t = $a; </div><div class=\"line\">    $a = $b; </div><div class=\"line\">    $b = $t; </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubble</span><span class=\"params\">($array)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    $length = count($array);</div><div class=\"line\">    $t = <span class=\"string\">''</span>; </div><div class=\"line\">    $flag = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> ( $i = <span class=\"number\">0</span>; $i &lt; $length &amp;&amp; $flag; ++$i) &#123;</div><div class=\"line\">        $flag = <span class=\"keyword\">false</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> ( $j = $length<span class=\"number\">-1</span>; $j &gt;= $i; $j-- ) &#123; </div><div class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"keyword\">isset</span>($array[$j+<span class=\"number\">1</span>])) <span class=\"keyword\">continue</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> ( $array[$j] &gt; $array[$j+<span class=\"number\">1</span>]) &#123;</div><div class=\"line\">                swap($array[$j], $array[$j+<span class=\"number\">1</span>]);</div><div class=\"line\">                $flag = <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125;   </div><div class=\"line\">        &#125;   </div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> $array;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"简单选择排序\"><a href=\"#简单选择排序\" class=\"headerlink\" title=\"简单选择排序\"></a>简单选择排序</h2><blockquote>\n<p>简单选择排序法(simple selection sort)就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i(1&lt;=i&lt;=n)个记录交换之。 时间复杂度为O(n^2)</p>\n</blockquote>\n<p>代码如下：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span><span class=\"params\">(&amp;$a, &amp;$b)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    $t = $a; </div><div class=\"line\">    $a = $b; </div><div class=\"line\">    $b = $t; </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectSort</span><span class=\"params\">($array)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    $length = count($array);</div><div class=\"line\">    $min = <span class=\"string\">''</span>; </div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> ( $i= <span class=\"number\">0</span>; $i&lt;$length; ++$i) &#123;</div><div class=\"line\">        $min = $i; </div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> ( $j = $i+<span class=\"number\">1</span>; $j &lt; $length; ++$j) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> ( $array[$min] &gt; $array[$j]) &#123;</div><div class=\"line\">                $min = $j; </div><div class=\"line\">            &#125;   </div><div class=\"line\">        &#125;   </div><div class=\"line\">        <span class=\"keyword\">if</span> ( $i != $min ) &#123; </div><div class=\"line\">            swap($array[$i], $array[$min]);</div><div class=\"line\">        &#125;   </div><div class=\"line\">    &#125;   </div><div class=\"line\">    <span class=\"keyword\">return</span> $array;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><blockquote>\n<p>直接插入排序(straight insertion sort)，基本操作是将一个记录插入到已经排好序的有序表中，复杂度为O(n^2)，因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。描述如下</p>\n</blockquote>\n<ol>\n<li>从第一个元素开始，该元素可以认为已经被排序</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>\n<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>\n<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>\n<li>将新元素插入到该位置后</li>\n<li>重复步骤2~5</li>\n</ol>\n<p>代码如下：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertSort</span><span class=\"params\">($array)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    $length = count($array);</div><div class=\"line\">    $tmp = <span class=\"string\">''</span>; </div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> ($i=<span class=\"number\">1</span>; $i&lt;$length; ++$i) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> ($array[$i] &lt; $array[$i<span class=\"number\">-1</span>]) &#123;</div><div class=\"line\">            $tmp = $array[$i];</div><div class=\"line\">            <span class=\"keyword\">for</span> ($j = $i<span class=\"number\">-1</span>; $j &gt; <span class=\"number\">-1</span> &amp;&amp; $array[$j] &gt; $tmp; --$j) &#123;</div><div class=\"line\">                $array[$j+<span class=\"number\">1</span>] = $array[$j];</div><div class=\"line\">            &#125;   </div><div class=\"line\">            $array[$j+<span class=\"number\">1</span>] = $tmp;</div><div class=\"line\">        &#125;   </div><div class=\"line\">    &#125;   </div><div class=\"line\">    <span class=\"keyword\">return</span> $array;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h2><blockquote>\n<p>希尔排序(shell sort)，不稳定排序。</p>\n</blockquote>\n<p>代码如下，增量为n/2：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shellSort</span><span class=\"params\">($array)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    $length = count($array);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> ($gap = $length &gt;&gt; <span class=\"number\">1</span>; $gap &gt; <span class=\"number\">0</span>; $gap &gt;&gt;= <span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> ( $i = $gap; $i &lt; count($array); ++$i ) &#123; </div><div class=\"line\">            $tmp = $array[$i];</div><div class=\"line\">            <span class=\"keyword\">for</span> ( $j = $i - $gap; $j &gt;= <span class=\"number\">0</span> &amp;&amp; $array[$j] &gt; $tmp; $j -= $gap ) &#123; </div><div class=\"line\">                $array[$j+$gap] = $array[$j];</div><div class=\"line\">            &#125;   </div><div class=\"line\">            $array[$j+$gap] = $tmp;</div><div class=\"line\">        &#125;   </div><div class=\"line\">    &#125;   </div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> $array;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"flush privilege 本意","date":"2016-04-19T02:15:29.000Z","_content":"\n*官方文档 <http://dev.mysql.com/doc/refman/5.7/en/privilege-changes.html>*\n\n什么时候用flush privilege？它的作用是什么？为什么要用？\n翻译了mysql 5.7的官方文档7.2.6节\n<!--more-->\n\n从字面上看，flush privilege意为刷新权限，以前只是光用这个命令，没有去想这条命令的意义。\n\n当启动mysqld之后，它将所有的权限表内容读进内存中。在那时候，在内存中的表就对控制访问生效了。\n\n如果你用账户管理命令例如grant,revoke,set password, rename user等非直接的修改权限表，mysql服务端会注意到这些改变，并且立即再次的把权限表加载进内存。\n\n如果你用命令例如insert,update,delete直接修改权限表，权限改表将不会生效直到重启服务或者告诉它重载权限表。如果你直接修改了权限表，但是忘记重载了，你的改表将不起作用直到重启服务。这可能导致你疑惑为什么你的改变看起来没有任何不同。\n\n为了告诉服务端重载权限表，运行一个flush-privileges操作。这可以通过发出一个flush privileges声明或者执行一个mysqladmin flush-privileges或者mysqladmin reload命令来完成。\n\n权限表被重载后将会对每一个存在的客户端连接生效，如下：\n\n- 表和列权限改变会对客户端的下一次请求生效\n-  数据库权限改变在下一次客户端执行use db_name声明后生效\n\n        注意\n        \n        客户端应用可能缓存数据库名称；因此，在没有明确改变一个不同的数据库或者刷新权限情况下，这个影响可能不明显。\n        \n- 对于已连接的客户端，全局的权限和密码不受影响。这些改变只对以后的连接有效。\n\n如果服务端加了--skip-grant-tables选项启动，它将不会读取权限表和执行任何访问控制。任何人都可以连接并且做任何事，这是不安全的。因此为了服务端能开始读取表，使访问检查有效，flush privileges刷新权限吧。\n\n\n\n\n\n\n\n","source":"_posts/2016-04-19-flush.md","raw":"---\ntitle: flush privilege 本意\ndate: 2016-04-19 10:15:29\ntags: \n- mysql\n- 翻译\ncategories: \n- 数据库\n---\n\n*官方文档 <http://dev.mysql.com/doc/refman/5.7/en/privilege-changes.html>*\n\n什么时候用flush privilege？它的作用是什么？为什么要用？\n翻译了mysql 5.7的官方文档7.2.6节\n<!--more-->\n\n从字面上看，flush privilege意为刷新权限，以前只是光用这个命令，没有去想这条命令的意义。\n\n当启动mysqld之后，它将所有的权限表内容读进内存中。在那时候，在内存中的表就对控制访问生效了。\n\n如果你用账户管理命令例如grant,revoke,set password, rename user等非直接的修改权限表，mysql服务端会注意到这些改变，并且立即再次的把权限表加载进内存。\n\n如果你用命令例如insert,update,delete直接修改权限表，权限改表将不会生效直到重启服务或者告诉它重载权限表。如果你直接修改了权限表，但是忘记重载了，你的改表将不起作用直到重启服务。这可能导致你疑惑为什么你的改变看起来没有任何不同。\n\n为了告诉服务端重载权限表，运行一个flush-privileges操作。这可以通过发出一个flush privileges声明或者执行一个mysqladmin flush-privileges或者mysqladmin reload命令来完成。\n\n权限表被重载后将会对每一个存在的客户端连接生效，如下：\n\n- 表和列权限改变会对客户端的下一次请求生效\n-  数据库权限改变在下一次客户端执行use db_name声明后生效\n\n        注意\n        \n        客户端应用可能缓存数据库名称；因此，在没有明确改变一个不同的数据库或者刷新权限情况下，这个影响可能不明显。\n        \n- 对于已连接的客户端，全局的权限和密码不受影响。这些改变只对以后的连接有效。\n\n如果服务端加了--skip-grant-tables选项启动，它将不会读取权限表和执行任何访问控制。任何人都可以连接并且做任何事，这是不安全的。因此为了服务端能开始读取表，使访问检查有效，flush privileges刷新权限吧。\n\n\n\n\n\n\n\n","slug":"flush","published":1,"updated":"2017-09-18T11:36:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7q4uqzb000bkkjessyjt17l","content":"<p><em>官方文档 <a href=\"http://dev.mysql.com/doc/refman/5.7/en/privilege-changes.html\" target=\"_blank\" rel=\"external\">http://dev.mysql.com/doc/refman/5.7/en/privilege-changes.html</a></em></p>\n<p>什么时候用flush privilege？它的作用是什么？为什么要用？<br>翻译了mysql 5.7的官方文档7.2.6节<br><a id=\"more\"></a></p>\n<p>从字面上看，flush privilege意为刷新权限，以前只是光用这个命令，没有去想这条命令的意义。</p>\n<p>当启动mysqld之后，它将所有的权限表内容读进内存中。在那时候，在内存中的表就对控制访问生效了。</p>\n<p>如果你用账户管理命令例如grant,revoke,set password, rename user等非直接的修改权限表，mysql服务端会注意到这些改变，并且立即再次的把权限表加载进内存。</p>\n<p>如果你用命令例如insert,update,delete直接修改权限表，权限改表将不会生效直到重启服务或者告诉它重载权限表。如果你直接修改了权限表，但是忘记重载了，你的改表将不起作用直到重启服务。这可能导致你疑惑为什么你的改变看起来没有任何不同。</p>\n<p>为了告诉服务端重载权限表，运行一个flush-privileges操作。这可以通过发出一个flush privileges声明或者执行一个mysqladmin flush-privileges或者mysqladmin reload命令来完成。</p>\n<p>权限表被重载后将会对每一个存在的客户端连接生效，如下：</p>\n<ul>\n<li>表和列权限改变会对客户端的下一次请求生效</li>\n<li><p>数据库权限改变在下一次客户端执行use db_name声明后生效</p>\n<pre><code>注意\n\n客户端应用可能缓存数据库名称；因此，在没有明确改变一个不同的数据库或者刷新权限情况下，这个影响可能不明显。\n</code></pre></li>\n<li><p>对于已连接的客户端，全局的权限和密码不受影响。这些改变只对以后的连接有效。</p>\n</li>\n</ul>\n<p>如果服务端加了–skip-grant-tables选项启动，它将不会读取权限表和执行任何访问控制。任何人都可以连接并且做任何事，这是不安全的。因此为了服务端能开始读取表，使访问检查有效，flush privileges刷新权限吧。</p>\n","site":{"data":{}},"excerpt":"<p><em>官方文档 <a href=\"http://dev.mysql.com/doc/refman/5.7/en/privilege-changes.html\" target=\"_blank\" rel=\"external\">http://dev.mysql.com/doc/refman/5.7/en/privilege-changes.html</a></em></p>\n<p>什么时候用flush privilege？它的作用是什么？为什么要用？<br>翻译了mysql 5.7的官方文档7.2.6节<br>","more":"</p>\n<p>从字面上看，flush privilege意为刷新权限，以前只是光用这个命令，没有去想这条命令的意义。</p>\n<p>当启动mysqld之后，它将所有的权限表内容读进内存中。在那时候，在内存中的表就对控制访问生效了。</p>\n<p>如果你用账户管理命令例如grant,revoke,set password, rename user等非直接的修改权限表，mysql服务端会注意到这些改变，并且立即再次的把权限表加载进内存。</p>\n<p>如果你用命令例如insert,update,delete直接修改权限表，权限改表将不会生效直到重启服务或者告诉它重载权限表。如果你直接修改了权限表，但是忘记重载了，你的改表将不起作用直到重启服务。这可能导致你疑惑为什么你的改变看起来没有任何不同。</p>\n<p>为了告诉服务端重载权限表，运行一个flush-privileges操作。这可以通过发出一个flush privileges声明或者执行一个mysqladmin flush-privileges或者mysqladmin reload命令来完成。</p>\n<p>权限表被重载后将会对每一个存在的客户端连接生效，如下：</p>\n<ul>\n<li>表和列权限改变会对客户端的下一次请求生效</li>\n<li><p>数据库权限改变在下一次客户端执行use db_name声明后生效</p>\n<pre><code>注意\n\n客户端应用可能缓存数据库名称；因此，在没有明确改变一个不同的数据库或者刷新权限情况下，这个影响可能不明显。\n</code></pre></li>\n<li><p>对于已连接的客户端，全局的权限和密码不受影响。这些改变只对以后的连接有效。</p>\n</li>\n</ul>\n<p>如果服务端加了–skip-grant-tables选项启动，它将不会读取权限表和执行任何访问控制。任何人都可以连接并且做任何事，这是不安全的。因此为了服务端能开始读取表，使访问检查有效，flush privileges刷新权限吧。</p>"},{"title":"如何翻墙","date":"2016-06-12T14:26:35.000Z","_content":"\n为了使用google搜索和英文资料。\n<!--more-->\n\n我所了解的有三种方式：\n\n    1. 购买vpn，不过它会代理你的所有网络请求\n    2. 使用蓝灯(lantern)，免费，但是不稳定，而且也是会代理浏览器所有请求\n    3. 自己搭建翻墙代理服务器，关键可以设置哪些使用代理，哪些直接连接，这样就可以同时使用公司vpn\n    \n我现在基本上用的就是第三种：\n\n首先得购买一台国外的服务器，开启了22端口；\n\n然后本地开启一个ssh工具，连接到国外服务器。\nmac上使用的是ssh工具时issh软件，浏览器用chrome，安装SwitchyOmega插件\n如图：打开issh工具，填入所购买服务器的ip，账号密码，还有浏览器插件代理的本地端口，图上为8081\n{% asset_img issh.jpeg %}\n\n最后设置浏览器，连接到本地ssh服务，选择socks5，如图：\n{% asset_img chrome.png %}\n\n使用SwitchyOmega，可以设置很多规则，来让浏览器访问哪些域名通过代理，哪些是直接连接。\n","source":"_posts/2016-06-12-greatWall.md","raw":"---\ntitle: 如何翻墙\ndate: 2016-06-12 22:26:35\ntags: mac\ncategories: 网络\n---\n\n为了使用google搜索和英文资料。\n<!--more-->\n\n我所了解的有三种方式：\n\n    1. 购买vpn，不过它会代理你的所有网络请求\n    2. 使用蓝灯(lantern)，免费，但是不稳定，而且也是会代理浏览器所有请求\n    3. 自己搭建翻墙代理服务器，关键可以设置哪些使用代理，哪些直接连接，这样就可以同时使用公司vpn\n    \n我现在基本上用的就是第三种：\n\n首先得购买一台国外的服务器，开启了22端口；\n\n然后本地开启一个ssh工具，连接到国外服务器。\nmac上使用的是ssh工具时issh软件，浏览器用chrome，安装SwitchyOmega插件\n如图：打开issh工具，填入所购买服务器的ip，账号密码，还有浏览器插件代理的本地端口，图上为8081\n{% asset_img issh.jpeg %}\n\n最后设置浏览器，连接到本地ssh服务，选择socks5，如图：\n{% asset_img chrome.png %}\n\n使用SwitchyOmega，可以设置很多规则，来让浏览器访问哪些域名通过代理，哪些是直接连接。\n","slug":"greatWall","published":1,"updated":"2017-09-18T11:36:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7q4uqzd000ckkjetxx5ye2f","content":"<p>为了使用google搜索和英文资料。<br><a id=\"more\"></a></p>\n<p>我所了解的有三种方式：</p>\n<pre><code>1. 购买vpn，不过它会代理你的所有网络请求\n2. 使用蓝灯(lantern)，免费，但是不稳定，而且也是会代理浏览器所有请求\n3. 自己搭建翻墙代理服务器，关键可以设置哪些使用代理，哪些直接连接，这样就可以同时使用公司vpn\n</code></pre><p>我现在基本上用的就是第三种：</p>\n<p>首先得购买一台国外的服务器，开启了22端口；</p>\n<p>然后本地开启一个ssh工具，连接到国外服务器。<br>mac上使用的是ssh工具时issh软件，浏览器用chrome，安装SwitchyOmega插件<br>如图：打开issh工具，填入所购买服务器的ip，账号密码，还有浏览器插件代理的本地端口，图上为8081<br><img src=\"/2016/06/12/greatWall/issh.jpeg\" alt=\"issh.jpeg\" title=\"\"></p>\n<p>最后设置浏览器，连接到本地ssh服务，选择socks5，如图：<br><img src=\"/2016/06/12/greatWall/chrome.png\" alt=\"chrome.png\" title=\"\"></p>\n<p>使用SwitchyOmega，可以设置很多规则，来让浏览器访问哪些域名通过代理，哪些是直接连接。</p>\n","site":{"data":{}},"excerpt":"<p>为了使用google搜索和英文资料。<br>","more":"</p>\n<p>我所了解的有三种方式：</p>\n<pre><code>1. 购买vpn，不过它会代理你的所有网络请求\n2. 使用蓝灯(lantern)，免费，但是不稳定，而且也是会代理浏览器所有请求\n3. 自己搭建翻墙代理服务器，关键可以设置哪些使用代理，哪些直接连接，这样就可以同时使用公司vpn\n</code></pre><p>我现在基本上用的就是第三种：</p>\n<p>首先得购买一台国外的服务器，开启了22端口；</p>\n<p>然后本地开启一个ssh工具，连接到国外服务器。<br>mac上使用的是ssh工具时issh软件，浏览器用chrome，安装SwitchyOmega插件<br>如图：打开issh工具，填入所购买服务器的ip，账号密码，还有浏览器插件代理的本地端口，图上为8081<br><img src=\"/2016/06/12/greatWall/issh.jpeg\" alt=\"issh.jpeg\" title=\"\"></p>\n<p>最后设置浏览器，连接到本地ssh服务，选择socks5，如图：<br><img src=\"/2016/06/12/greatWall/chrome.png\" alt=\"chrome.png\" title=\"\"></p>\n<p>使用SwitchyOmega，可以设置很多规则，来让浏览器访问哪些域名通过代理，哪些是直接连接。</p>"},{"title":"php从mysql取出int数据，变成了string","date":"2016-05-10T01:41:06.000Z","_content":"\nphp与mysql交互\n<!--more-->\n\n参考资料：\n>http://stackoverflow.com/questions/1197005/how-to-get-numeric-types-from-mysql-using-pdo#answer-1197041\n>http://zhangxugg-163-com.iteye.com/blog/1894990\n>http://dengxi.blog.51cto.com/4804263/1748965\n>http://blog.ulf-wendel.de/2008/pdo_mysqlnd-the-new-features-of-pdo_mysql/\n\n以前一直没注意到php从mysql取出来的数据都是string类型，无论是主键int id还是float。因为php是弱类型的语言，所以其实这也没多大关系。但是这引申出php所使用的mysql驱动等问题。\n\n首先，php是如何与mysql交互的。PHP通过某种api（其实就是扩展），基于某种驱动或lib库与mysql server连接通信。\n\napi有三种：mysql,mysqli和pdo。\n\n        其中mysql扩展已经不被建议使用，它将在5.5被废弃，而在php7中被去除。\n\n驱动有两种：libmysqlclient(MySQL client server library )和mysqlnd(MySQL native driver )。\n\n        在5.3之前，默认使用的都是libmysql.从5.3开始mysqlnd已经内置于php源代码中，并且官方强烈建议使用这个驱动，只要在编译的时候加上就行了，比如：./configure --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --with-mysql=mysqlnd。\n        而从5.4开始，三种api的驱动默认都将为mysqlnd，所以编译的时候不需要指定驱动了，比如：./configure --with-mysqli --with-pdo-mysql --with-mysql。\n\n可以用下面两张图表示：\n5.3之前\n\n{% asset_img 5.3.png %}\n\n5.3之后\n\n{% asset_img 5.4.png %}\n\n更多对mysqlnd的介绍，参考官方手册http://php.net/manual/zh/book.mysqlnd.php\n\n如果使用的是旧的libmysql，那没办法，得不到mysql数据的类型，都会被转换为string。而从5.3开始使用mysqlnd驱动，就可得到，但是使用mysql扩展还是会被转换成string。\n通过mysqli的MYSQLI_OPT_INT_AND_FLOAT_NATIVE参数，例如：\n\n```php\n<?php\n    $mysqli = new mysqli('127.0.0.1', 'root', '', 'test');\n    $query = \"select * from test_int\";\n    $mysqli->options(MYSQLI_OPT_INT_AND_FLOAT_NATIVE, 1); \n    $result = $mysqli->query($query);\n    $info = $result->fetch_array();\n    var_dump($info);\n```\n    \n而通过pdo，例如：\n\n```php\n<?php\n    $pdo = new PDO('mysql:host=127.0.0.1;dbname=test', 'root', '');\n    $pdo->setAttribute(PDO::ATTR_EMULATE_PREPARES, false);\n    $pdo->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, false);\n    foreach ($pdo->query('select * from test_int') as $row) {\n    var_dump($row);\n}\n```\n    \nATTR_EMULATE_PREPARES默认为true，需要指定；而ATTR_STRINGIFY_FETCHES默认就为false。\n\n>需要注意的是：decimal类型的数据，即使有了以上的配置，依然还是输出为string类型。","source":"_posts/2016-05-10-mysql-driver.md","raw":"---\ntitle: php从mysql取出int数据，变成了string\ndate: 2016-05-10 09:41:06\ntags: mysql\ncategories: 数据库\n---\n\nphp与mysql交互\n<!--more-->\n\n参考资料：\n>http://stackoverflow.com/questions/1197005/how-to-get-numeric-types-from-mysql-using-pdo#answer-1197041\n>http://zhangxugg-163-com.iteye.com/blog/1894990\n>http://dengxi.blog.51cto.com/4804263/1748965\n>http://blog.ulf-wendel.de/2008/pdo_mysqlnd-the-new-features-of-pdo_mysql/\n\n以前一直没注意到php从mysql取出来的数据都是string类型，无论是主键int id还是float。因为php是弱类型的语言，所以其实这也没多大关系。但是这引申出php所使用的mysql驱动等问题。\n\n首先，php是如何与mysql交互的。PHP通过某种api（其实就是扩展），基于某种驱动或lib库与mysql server连接通信。\n\napi有三种：mysql,mysqli和pdo。\n\n        其中mysql扩展已经不被建议使用，它将在5.5被废弃，而在php7中被去除。\n\n驱动有两种：libmysqlclient(MySQL client server library )和mysqlnd(MySQL native driver )。\n\n        在5.3之前，默认使用的都是libmysql.从5.3开始mysqlnd已经内置于php源代码中，并且官方强烈建议使用这个驱动，只要在编译的时候加上就行了，比如：./configure --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --with-mysql=mysqlnd。\n        而从5.4开始，三种api的驱动默认都将为mysqlnd，所以编译的时候不需要指定驱动了，比如：./configure --with-mysqli --with-pdo-mysql --with-mysql。\n\n可以用下面两张图表示：\n5.3之前\n\n{% asset_img 5.3.png %}\n\n5.3之后\n\n{% asset_img 5.4.png %}\n\n更多对mysqlnd的介绍，参考官方手册http://php.net/manual/zh/book.mysqlnd.php\n\n如果使用的是旧的libmysql，那没办法，得不到mysql数据的类型，都会被转换为string。而从5.3开始使用mysqlnd驱动，就可得到，但是使用mysql扩展还是会被转换成string。\n通过mysqli的MYSQLI_OPT_INT_AND_FLOAT_NATIVE参数，例如：\n\n```php\n<?php\n    $mysqli = new mysqli('127.0.0.1', 'root', '', 'test');\n    $query = \"select * from test_int\";\n    $mysqli->options(MYSQLI_OPT_INT_AND_FLOAT_NATIVE, 1); \n    $result = $mysqli->query($query);\n    $info = $result->fetch_array();\n    var_dump($info);\n```\n    \n而通过pdo，例如：\n\n```php\n<?php\n    $pdo = new PDO('mysql:host=127.0.0.1;dbname=test', 'root', '');\n    $pdo->setAttribute(PDO::ATTR_EMULATE_PREPARES, false);\n    $pdo->setAttribute(PDO::ATTR_STRINGIFY_FETCHES, false);\n    foreach ($pdo->query('select * from test_int') as $row) {\n    var_dump($row);\n}\n```\n    \nATTR_EMULATE_PREPARES默认为true，需要指定；而ATTR_STRINGIFY_FETCHES默认就为false。\n\n>需要注意的是：decimal类型的数据，即使有了以上的配置，依然还是输出为string类型。","slug":"mysql-driver","published":1,"updated":"2017-09-18T11:36:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7q4uqze000gkkjelcia5pp7","content":"<p>php与mysql交互<br><a id=\"more\"></a></p>\n<p>参考资料：</p>\n<blockquote>\n<p><a href=\"http://stackoverflow.com/questions/1197005/how-to-get-numeric-types-from-mysql-using-pdo#answer-1197041\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/1197005/how-to-get-numeric-types-from-mysql-using-pdo#answer-1197041</a><br><a href=\"http://zhangxugg-163-com.iteye.com/blog/1894990\" target=\"_blank\" rel=\"external\">http://zhangxugg-163-com.iteye.com/blog/1894990</a><br><a href=\"http://dengxi.blog.51cto.com/4804263/1748965\" target=\"_blank\" rel=\"external\">http://dengxi.blog.51cto.com/4804263/1748965</a><br><a href=\"http://blog.ulf-wendel.de/2008/pdo_mysqlnd-the-new-features-of-pdo_mysql/\" target=\"_blank\" rel=\"external\">http://blog.ulf-wendel.de/2008/pdo_mysqlnd-the-new-features-of-pdo_mysql/</a></p>\n</blockquote>\n<p>以前一直没注意到php从mysql取出来的数据都是string类型，无论是主键int id还是float。因为php是弱类型的语言，所以其实这也没多大关系。但是这引申出php所使用的mysql驱动等问题。</p>\n<p>首先，php是如何与mysql交互的。PHP通过某种api（其实就是扩展），基于某种驱动或lib库与mysql server连接通信。</p>\n<p>api有三种：mysql,mysqli和pdo。</p>\n<pre><code>其中mysql扩展已经不被建议使用，它将在5.5被废弃，而在php7中被去除。\n</code></pre><p>驱动有两种：libmysqlclient(MySQL client server library )和mysqlnd(MySQL native driver )。</p>\n<pre><code>在5.3之前，默认使用的都是libmysql.从5.3开始mysqlnd已经内置于php源代码中，并且官方强烈建议使用这个驱动，只要在编译的时候加上就行了，比如：./configure --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --with-mysql=mysqlnd。\n而从5.4开始，三种api的驱动默认都将为mysqlnd，所以编译的时候不需要指定驱动了，比如：./configure --with-mysqli --with-pdo-mysql --with-mysql。\n</code></pre><p>可以用下面两张图表示：<br>5.3之前</p>\n<img src=\"/2016/05/10/mysql-driver/5.3.png\" alt=\"5.3.png\" title=\"\">\n<p>5.3之后</p>\n<img src=\"/2016/05/10/mysql-driver/5.4.png\" alt=\"5.4.png\" title=\"\">\n<p>更多对mysqlnd的介绍，参考官方手册<a href=\"http://php.net/manual/zh/book.mysqlnd.php\" target=\"_blank\" rel=\"external\">http://php.net/manual/zh/book.mysqlnd.php</a></p>\n<p>如果使用的是旧的libmysql，那没办法，得不到mysql数据的类型，都会被转换为string。而从5.3开始使用mysqlnd驱动，就可得到，但是使用mysql扩展还是会被转换成string。<br>通过mysqli的MYSQLI_OPT_INT_AND_FLOAT_NATIVE参数，例如：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\">    $mysqli = <span class=\"keyword\">new</span> mysqli(<span class=\"string\">'127.0.0.1'</span>, <span class=\"string\">'root'</span>, <span class=\"string\">''</span>, <span class=\"string\">'test'</span>);</div><div class=\"line\">    $query = <span class=\"string\">\"select * from test_int\"</span>;</div><div class=\"line\">    $mysqli-&gt;options(MYSQLI_OPT_INT_AND_FLOAT_NATIVE, <span class=\"number\">1</span>); </div><div class=\"line\">    $result = $mysqli-&gt;query($query);</div><div class=\"line\">    $info = $result-&gt;fetch_array();</div><div class=\"line\">    var_dump($info);</div></pre></td></tr></table></figure>\n<p>而通过pdo，例如：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\">    $pdo = <span class=\"keyword\">new</span> PDO(<span class=\"string\">'mysql:host=127.0.0.1;dbname=test'</span>, <span class=\"string\">'root'</span>, <span class=\"string\">''</span>);</div><div class=\"line\">    $pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, <span class=\"keyword\">false</span>);</div><div class=\"line\">    $pdo-&gt;setAttribute(PDO::ATTR_STRINGIFY_FETCHES, <span class=\"keyword\">false</span>);</div><div class=\"line\">    <span class=\"keyword\">foreach</span> ($pdo-&gt;query(<span class=\"string\">'select * from test_int'</span>) <span class=\"keyword\">as</span> $row) &#123;</div><div class=\"line\">    var_dump($row);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ATTR_EMULATE_PREPARES默认为true，需要指定；而ATTR_STRINGIFY_FETCHES默认就为false。</p>\n<blockquote>\n<p>需要注意的是：decimal类型的数据，即使有了以上的配置，依然还是输出为string类型。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>php与mysql交互<br>","more":"</p>\n<p>参考资料：</p>\n<blockquote>\n<p><a href=\"http://stackoverflow.com/questions/1197005/how-to-get-numeric-types-from-mysql-using-pdo#answer-1197041\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/1197005/how-to-get-numeric-types-from-mysql-using-pdo#answer-1197041</a><br><a href=\"http://zhangxugg-163-com.iteye.com/blog/1894990\" target=\"_blank\" rel=\"external\">http://zhangxugg-163-com.iteye.com/blog/1894990</a><br><a href=\"http://dengxi.blog.51cto.com/4804263/1748965\" target=\"_blank\" rel=\"external\">http://dengxi.blog.51cto.com/4804263/1748965</a><br><a href=\"http://blog.ulf-wendel.de/2008/pdo_mysqlnd-the-new-features-of-pdo_mysql/\" target=\"_blank\" rel=\"external\">http://blog.ulf-wendel.de/2008/pdo_mysqlnd-the-new-features-of-pdo_mysql/</a></p>\n</blockquote>\n<p>以前一直没注意到php从mysql取出来的数据都是string类型，无论是主键int id还是float。因为php是弱类型的语言，所以其实这也没多大关系。但是这引申出php所使用的mysql驱动等问题。</p>\n<p>首先，php是如何与mysql交互的。PHP通过某种api（其实就是扩展），基于某种驱动或lib库与mysql server连接通信。</p>\n<p>api有三种：mysql,mysqli和pdo。</p>\n<pre><code>其中mysql扩展已经不被建议使用，它将在5.5被废弃，而在php7中被去除。\n</code></pre><p>驱动有两种：libmysqlclient(MySQL client server library )和mysqlnd(MySQL native driver )。</p>\n<pre><code>在5.3之前，默认使用的都是libmysql.从5.3开始mysqlnd已经内置于php源代码中，并且官方强烈建议使用这个驱动，只要在编译的时候加上就行了，比如：./configure --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --with-mysql=mysqlnd。\n而从5.4开始，三种api的驱动默认都将为mysqlnd，所以编译的时候不需要指定驱动了，比如：./configure --with-mysqli --with-pdo-mysql --with-mysql。\n</code></pre><p>可以用下面两张图表示：<br>5.3之前</p>\n<img src=\"/2016/05/10/mysql-driver/5.3.png\" alt=\"5.3.png\" title=\"\">\n<p>5.3之后</p>\n<img src=\"/2016/05/10/mysql-driver/5.4.png\" alt=\"5.4.png\" title=\"\">\n<p>更多对mysqlnd的介绍，参考官方手册<a href=\"http://php.net/manual/zh/book.mysqlnd.php\" target=\"_blank\" rel=\"external\">http://php.net/manual/zh/book.mysqlnd.php</a></p>\n<p>如果使用的是旧的libmysql，那没办法，得不到mysql数据的类型，都会被转换为string。而从5.3开始使用mysqlnd驱动，就可得到，但是使用mysql扩展还是会被转换成string。<br>通过mysqli的MYSQLI_OPT_INT_AND_FLOAT_NATIVE参数，例如：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\">    $mysqli = <span class=\"keyword\">new</span> mysqli(<span class=\"string\">'127.0.0.1'</span>, <span class=\"string\">'root'</span>, <span class=\"string\">''</span>, <span class=\"string\">'test'</span>);</div><div class=\"line\">    $query = <span class=\"string\">\"select * from test_int\"</span>;</div><div class=\"line\">    $mysqli-&gt;options(MYSQLI_OPT_INT_AND_FLOAT_NATIVE, <span class=\"number\">1</span>); </div><div class=\"line\">    $result = $mysqli-&gt;query($query);</div><div class=\"line\">    $info = $result-&gt;fetch_array();</div><div class=\"line\">    var_dump($info);</div></pre></td></tr></table></figure>\n<p>而通过pdo，例如：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\">    $pdo = <span class=\"keyword\">new</span> PDO(<span class=\"string\">'mysql:host=127.0.0.1;dbname=test'</span>, <span class=\"string\">'root'</span>, <span class=\"string\">''</span>);</div><div class=\"line\">    $pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, <span class=\"keyword\">false</span>);</div><div class=\"line\">    $pdo-&gt;setAttribute(PDO::ATTR_STRINGIFY_FETCHES, <span class=\"keyword\">false</span>);</div><div class=\"line\">    <span class=\"keyword\">foreach</span> ($pdo-&gt;query(<span class=\"string\">'select * from test_int'</span>) <span class=\"keyword\">as</span> $row) &#123;</div><div class=\"line\">    var_dump($row);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ATTR_EMULATE_PREPARES默认为true，需要指定；而ATTR_STRINGIFY_FETCHES默认就为false。</p>\n<blockquote>\n<p>需要注意的是：decimal类型的数据，即使有了以上的配置，依然还是输出为string类型。</p>\n</blockquote>"},{"title":"好用的工具ctags","date":"2016-06-24T07:26:09.000Z","_content":"\n*参考资料http://www.cnblogs.com/feisky/archive/2012/02/07/2341932.html*\n*http://blog.csdn.net/alexdboy/article/details/3871707*\n\n用vim查看代码的时候能够用上\n<!-- more -->\n\nctags的功能：扫描指定的源文件，找出其中所包含的语法元素，并将找到的相关内容记录下来。\n大部分的linux系统上都自带有这个工具，而我的mac上虽然也有自带的，但是却不好用，连version都没有，所以得自己安装一个官方的。\n\n从官网上下载：<http://ctags.sourceforge.net/>  现在版本是5.8\n然后安装：\n    > ./configure\n    > make\n    > make install\nmac自带的地址在/usr/bin/ctags，而自己安装的在/usr/local/bin/ctags，替换下，这样普通用户也能用了。\n\n可以用ctags --list-languages 查看能识别哪些语言\n\n用法：\n    首先，生成标签文件，一般在根目录下，使用命令ctags -R .\n    \n    -R表示recursive，递归,为当前目录及其子目录中的文件生成标签文件。最后一个.表示在当前目录\n 运行完当前目录会多一个文件tags，就是索引文件。\n \n 然后用vim打开文件，ctrl+]找到光标所在位置的标签定义的地方，ctrl+t 回到跳转之前的标签处。\n 比如打开a.php，里面有个search函数，定义在b.php，这时可以把光标移到search处，键盘执行ctrl+]，这时会在当前窗口打开b.php，并且光标处在function search一行，执行ctrl+t，回到上个位置。\n \n     注意：此时运行vim，必须在\"tags\"文件所在的目录下运行。\n     否则，运行它会找不到\"tags\"文件，而需要在vim中用\":set tags=\"命令设定\"tags\"文件的路径。\n     对于一个稍微大点的项目，你可能在任何一个目录下打开vim，\n     这时在.vimrc中增加一行：set tags=tags;/ \n     告诉vim在当前目录找不到tags文件时请到上层目录查找，一直往上级目录，直到找到tags文件为止。\n     \n 这在阅读c代码尤为有用\n \n {% asset_img 1.jpg %}\n    \n    ","source":"_posts/2016-06-24-ctags.md","raw":"---\ntitle: 好用的工具ctags\ndate: 2016-06-24 15:26:09\ntags: vim\ncategories: linux\n---\n\n*参考资料http://www.cnblogs.com/feisky/archive/2012/02/07/2341932.html*\n*http://blog.csdn.net/alexdboy/article/details/3871707*\n\n用vim查看代码的时候能够用上\n<!-- more -->\n\nctags的功能：扫描指定的源文件，找出其中所包含的语法元素，并将找到的相关内容记录下来。\n大部分的linux系统上都自带有这个工具，而我的mac上虽然也有自带的，但是却不好用，连version都没有，所以得自己安装一个官方的。\n\n从官网上下载：<http://ctags.sourceforge.net/>  现在版本是5.8\n然后安装：\n    > ./configure\n    > make\n    > make install\nmac自带的地址在/usr/bin/ctags，而自己安装的在/usr/local/bin/ctags，替换下，这样普通用户也能用了。\n\n可以用ctags --list-languages 查看能识别哪些语言\n\n用法：\n    首先，生成标签文件，一般在根目录下，使用命令ctags -R .\n    \n    -R表示recursive，递归,为当前目录及其子目录中的文件生成标签文件。最后一个.表示在当前目录\n 运行完当前目录会多一个文件tags，就是索引文件。\n \n 然后用vim打开文件，ctrl+]找到光标所在位置的标签定义的地方，ctrl+t 回到跳转之前的标签处。\n 比如打开a.php，里面有个search函数，定义在b.php，这时可以把光标移到search处，键盘执行ctrl+]，这时会在当前窗口打开b.php，并且光标处在function search一行，执行ctrl+t，回到上个位置。\n \n     注意：此时运行vim，必须在\"tags\"文件所在的目录下运行。\n     否则，运行它会找不到\"tags\"文件，而需要在vim中用\":set tags=\"命令设定\"tags\"文件的路径。\n     对于一个稍微大点的项目，你可能在任何一个目录下打开vim，\n     这时在.vimrc中增加一行：set tags=tags;/ \n     告诉vim在当前目录找不到tags文件时请到上层目录查找，一直往上级目录，直到找到tags文件为止。\n     \n 这在阅读c代码尤为有用\n \n {% asset_img 1.jpg %}\n    \n    ","slug":"ctags","published":1,"updated":"2017-09-18T11:36:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7q4uqzf000ikkjeex2qrc3f","content":"<p><em>参考资料<a href=\"http://www.cnblogs.com/feisky/archive/2012/02/07/2341932.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/feisky/archive/2012/02/07/2341932.html</a></em><br><em><a href=\"http://blog.csdn.net/alexdboy/article/details/3871707\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/alexdboy/article/details/3871707</a></em></p>\n<p>用vim查看代码的时候能够用上<br><a id=\"more\"></a></p>\n<p>ctags的功能：扫描指定的源文件，找出其中所包含的语法元素，并将找到的相关内容记录下来。<br>大部分的linux系统上都自带有这个工具，而我的mac上虽然也有自带的，但是却不好用，连version都没有，所以得自己安装一个官方的。</p>\n<p>从官网上下载：<a href=\"http://ctags.sourceforge.net/\" target=\"_blank\" rel=\"external\">http://ctags.sourceforge.net/</a>  现在版本是5.8<br>然后安装：</p>\n<pre><code>&gt; ./configure\n&gt; make\n&gt; make install\n</code></pre><p>mac自带的地址在/usr/bin/ctags，而自己安装的在/usr/local/bin/ctags，替换下，这样普通用户也能用了。</p>\n<p>可以用ctags –list-languages 查看能识别哪些语言</p>\n<p>用法：<br>    首先，生成标签文件，一般在根目录下，使用命令ctags -R .</p>\n<pre><code>-R表示recursive，递归,为当前目录及其子目录中的文件生成标签文件。最后一个.表示在当前目录\n</code></pre><p> 运行完当前目录会多一个文件tags，就是索引文件。</p>\n<p> 然后用vim打开文件，ctrl+]找到光标所在位置的标签定义的地方，ctrl+t 回到跳转之前的标签处。<br> 比如打开a.php，里面有个search函数，定义在b.php，这时可以把光标移到search处，键盘执行ctrl+]，这时会在当前窗口打开b.php，并且光标处在function search一行，执行ctrl+t，回到上个位置。</p>\n<pre><code>注意：此时运行vim，必须在&quot;tags&quot;文件所在的目录下运行。\n否则，运行它会找不到&quot;tags&quot;文件，而需要在vim中用&quot;:set tags=&quot;命令设定&quot;tags&quot;文件的路径。\n对于一个稍微大点的项目，你可能在任何一个目录下打开vim，\n这时在.vimrc中增加一行：set tags=tags;/ \n告诉vim在当前目录找不到tags文件时请到上层目录查找，一直往上级目录，直到找到tags文件为止。\n</code></pre><p> 这在阅读c代码尤为有用</p>\n <img src=\"/2016/06/24/ctags/1.jpg\" alt=\"1.jpg\" title=\"\">\n","site":{"data":{}},"excerpt":"<p><em>参考资料<a href=\"http://www.cnblogs.com/feisky/archive/2012/02/07/2341932.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/feisky/archive/2012/02/07/2341932.html</a></em><br><em><a href=\"http://blog.csdn.net/alexdboy/article/details/3871707\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/alexdboy/article/details/3871707</a></em></p>\n<p>用vim查看代码的时候能够用上<br>","more":"</p>\n<p>ctags的功能：扫描指定的源文件，找出其中所包含的语法元素，并将找到的相关内容记录下来。<br>大部分的linux系统上都自带有这个工具，而我的mac上虽然也有自带的，但是却不好用，连version都没有，所以得自己安装一个官方的。</p>\n<p>从官网上下载：<a href=\"http://ctags.sourceforge.net/\" target=\"_blank\" rel=\"external\">http://ctags.sourceforge.net/</a>  现在版本是5.8<br>然后安装：</p>\n<pre><code>&gt; ./configure\n&gt; make\n&gt; make install\n</code></pre><p>mac自带的地址在/usr/bin/ctags，而自己安装的在/usr/local/bin/ctags，替换下，这样普通用户也能用了。</p>\n<p>可以用ctags –list-languages 查看能识别哪些语言</p>\n<p>用法：<br>    首先，生成标签文件，一般在根目录下，使用命令ctags -R .</p>\n<pre><code>-R表示recursive，递归,为当前目录及其子目录中的文件生成标签文件。最后一个.表示在当前目录\n</code></pre><p> 运行完当前目录会多一个文件tags，就是索引文件。</p>\n<p> 然后用vim打开文件，ctrl+]找到光标所在位置的标签定义的地方，ctrl+t 回到跳转之前的标签处。<br> 比如打开a.php，里面有个search函数，定义在b.php，这时可以把光标移到search处，键盘执行ctrl+]，这时会在当前窗口打开b.php，并且光标处在function search一行，执行ctrl+t，回到上个位置。</p>\n<pre><code>注意：此时运行vim，必须在&quot;tags&quot;文件所在的目录下运行。\n否则，运行它会找不到&quot;tags&quot;文件，而需要在vim中用&quot;:set tags=&quot;命令设定&quot;tags&quot;文件的路径。\n对于一个稍微大点的项目，你可能在任何一个目录下打开vim，\n这时在.vimrc中增加一行：set tags=tags;/ \n告诉vim在当前目录找不到tags文件时请到上层目录查找，一直往上级目录，直到找到tags文件为止。\n</code></pre><p> 这在阅读c代码尤为有用</p>\n <img src=\"/2016/06/24/ctags/1.jpg\" alt=\"1.jpg\" title=\"\">"},{"title":"守护进程","date":"2016-08-08T01:47:48.000Z","_content":"\n守护进程的一些原理和方法。\n<!--more-->\n\n**首先来看几个概念：**\n\n1. 守护进程：daemon，运行在后台的特殊进程，是生存期长的一种进程，它独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。\n2. 前台进程：在多任务操作系统（诸如 UNIX/Linux）中，前台进程是用户当前与之交互的程序（例如，数据输入）。随着用户在程序之间切换，会导致这些程序在不同的时刻处于前台。在层叠的窗口环境中，前台进程是最前面的窗口。在命令行中，默认程序和命令都作为前台进程运行，要在后台运行，需要加&符号。\n3. 进程组：一个或者多个进程的集合。每个进程组有一个组长进程\n4. 会话(session)：一个或多个进程组的集合。一个会话可以有一个控制终端，通常是终端设备。会话通常是一个登录进程创建的，创建会话的进程为会话首进程(session leader)，只有session leader才能控制终端。\n\n**那么，成为一个守护进程的关键是什么？**\n\n脱离终端，不继承标准输入。脱离终端的目的是避免进程在运行过程中的信息在任何终端中显示，并且进程也不会被任何终端所产生的终端信息打断。\n\n**如何命令行启动一个后台进程**\n\n可以参考这篇[Linux 守护进程的启动方法](http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html)。\n这里简单说下里面的nohup，比如：nohup php 1.php 2>&1 &\nnohup表示挂起，标准输入会重定向到/dev/null，并且忽略sigup信号，它并不会让进程变为后台任务，所以需要在命令行末尾加上&符号。\n* 2表示标准错误(stderr)\n* '>'表示重定向\n* 1表示标准输出(stdout)\n* 0表示标准输入(stdin)\n\n2>&1整个意思是：将标准错误重定向到标准输出，在大于号后面必须加上&符号，否则，它只会重定向到一个名为1的文件。\n如果没有2>&1，标准输出会以nohup.out文件输出。\n\n**程序如何实现守护进程呢**\n\n1. 使用umask重设文件创建掩码，通常设为0。这是为了创建文件后，设置更多权限。\n2. 调用fork创建子进程，然后父进程退出。fork得来的子进程复制了父进程的环境，最重要的是这样子进程不是session leader了，也不是进程组的组长进程。这是下面setsid的条件。\n3. setsid创建新会话。这样是为了摆脱控制终端。但是这样子进程就成为了新session的session leader，而只有session leader才能控制终端。假如它打开一个终端设备文件，比如/dev/console，就有可能控制终端。所以也有人会在此时再次fork来保证进程不是session leader，从而没有可能控制终端。还有一种避免取得控制终端的方式是：open后面加上O_NOCTTY参数，比如int fd = open(\"/dev/console\",O_NOCTTY);\n4. 更改当前工作目录到根目录。这个其实只要你的当前工作目录不会被卸载就行。\n5. 关闭不再需要的文件描述符\n6. 有些可能会将0，1，2重定向到/dev/null，使标准输入输出错误无效。\n\n**但是，还留下几个问题**\n\n1. fork之后，父进程退出，子进程脱离了控制终端吗？如果脱离了，那为什么还要setsid呢？如果没有脱离，子进程已经不是session leader了，而只有session leader才能控制终端。\n2. 终端退出时，发生了什么，何时发送signup信号\n\n参考资料：\n*http://stackoverflow.com/questions/881388/what-is-the-reason-for-performing-a-double-fork-when-creating-a-daemon*\n*http://stackoverflow.com/questions/10932592/why-fork-twice/16655124#16655124*\n*http://www.win.tue.nl/~aeb/linux/lk/lk-10.html*\n*http://stackoverflow.com/questions/32780706/does-linux-kill-background-processes-if-we-close-the-terminal-from-which-it-has*\n*http://blog.csdn.net/ithomer/article/details/9288353*\n*《UNIX环境高级编程》*\n\n\n","source":"_posts/2016-08-08-daemon.md","raw":"---\ntitle: 守护进程\ndate: 2016-08-08 09:47:48\ntags: linux \ncategories: linux\n---\n\n守护进程的一些原理和方法。\n<!--more-->\n\n**首先来看几个概念：**\n\n1. 守护进程：daemon，运行在后台的特殊进程，是生存期长的一种进程，它独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。\n2. 前台进程：在多任务操作系统（诸如 UNIX/Linux）中，前台进程是用户当前与之交互的程序（例如，数据输入）。随着用户在程序之间切换，会导致这些程序在不同的时刻处于前台。在层叠的窗口环境中，前台进程是最前面的窗口。在命令行中，默认程序和命令都作为前台进程运行，要在后台运行，需要加&符号。\n3. 进程组：一个或者多个进程的集合。每个进程组有一个组长进程\n4. 会话(session)：一个或多个进程组的集合。一个会话可以有一个控制终端，通常是终端设备。会话通常是一个登录进程创建的，创建会话的进程为会话首进程(session leader)，只有session leader才能控制终端。\n\n**那么，成为一个守护进程的关键是什么？**\n\n脱离终端，不继承标准输入。脱离终端的目的是避免进程在运行过程中的信息在任何终端中显示，并且进程也不会被任何终端所产生的终端信息打断。\n\n**如何命令行启动一个后台进程**\n\n可以参考这篇[Linux 守护进程的启动方法](http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html)。\n这里简单说下里面的nohup，比如：nohup php 1.php 2>&1 &\nnohup表示挂起，标准输入会重定向到/dev/null，并且忽略sigup信号，它并不会让进程变为后台任务，所以需要在命令行末尾加上&符号。\n* 2表示标准错误(stderr)\n* '>'表示重定向\n* 1表示标准输出(stdout)\n* 0表示标准输入(stdin)\n\n2>&1整个意思是：将标准错误重定向到标准输出，在大于号后面必须加上&符号，否则，它只会重定向到一个名为1的文件。\n如果没有2>&1，标准输出会以nohup.out文件输出。\n\n**程序如何实现守护进程呢**\n\n1. 使用umask重设文件创建掩码，通常设为0。这是为了创建文件后，设置更多权限。\n2. 调用fork创建子进程，然后父进程退出。fork得来的子进程复制了父进程的环境，最重要的是这样子进程不是session leader了，也不是进程组的组长进程。这是下面setsid的条件。\n3. setsid创建新会话。这样是为了摆脱控制终端。但是这样子进程就成为了新session的session leader，而只有session leader才能控制终端。假如它打开一个终端设备文件，比如/dev/console，就有可能控制终端。所以也有人会在此时再次fork来保证进程不是session leader，从而没有可能控制终端。还有一种避免取得控制终端的方式是：open后面加上O_NOCTTY参数，比如int fd = open(\"/dev/console\",O_NOCTTY);\n4. 更改当前工作目录到根目录。这个其实只要你的当前工作目录不会被卸载就行。\n5. 关闭不再需要的文件描述符\n6. 有些可能会将0，1，2重定向到/dev/null，使标准输入输出错误无效。\n\n**但是，还留下几个问题**\n\n1. fork之后，父进程退出，子进程脱离了控制终端吗？如果脱离了，那为什么还要setsid呢？如果没有脱离，子进程已经不是session leader了，而只有session leader才能控制终端。\n2. 终端退出时，发生了什么，何时发送signup信号\n\n参考资料：\n*http://stackoverflow.com/questions/881388/what-is-the-reason-for-performing-a-double-fork-when-creating-a-daemon*\n*http://stackoverflow.com/questions/10932592/why-fork-twice/16655124#16655124*\n*http://www.win.tue.nl/~aeb/linux/lk/lk-10.html*\n*http://stackoverflow.com/questions/32780706/does-linux-kill-background-processes-if-we-close-the-terminal-from-which-it-has*\n*http://blog.csdn.net/ithomer/article/details/9288353*\n*《UNIX环境高级编程》*\n\n\n","slug":"daemon","published":1,"updated":"2017-09-18T11:36:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7q4uqzg000nkkjezmha5xyv","content":"<p>守护进程的一些原理和方法。<br><a id=\"more\"></a></p>\n<p><strong>首先来看几个概念：</strong></p>\n<ol>\n<li>守护进程：daemon，运行在后台的特殊进程，是生存期长的一种进程，它独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。</li>\n<li>前台进程：在多任务操作系统（诸如 UNIX/Linux）中，前台进程是用户当前与之交互的程序（例如，数据输入）。随着用户在程序之间切换，会导致这些程序在不同的时刻处于前台。在层叠的窗口环境中，前台进程是最前面的窗口。在命令行中，默认程序和命令都作为前台进程运行，要在后台运行，需要加&amp;符号。</li>\n<li>进程组：一个或者多个进程的集合。每个进程组有一个组长进程</li>\n<li>会话(session)：一个或多个进程组的集合。一个会话可以有一个控制终端，通常是终端设备。会话通常是一个登录进程创建的，创建会话的进程为会话首进程(session leader)，只有session leader才能控制终端。</li>\n</ol>\n<p><strong>那么，成为一个守护进程的关键是什么？</strong></p>\n<p>脱离终端，不继承标准输入。脱离终端的目的是避免进程在运行过程中的信息在任何终端中显示，并且进程也不会被任何终端所产生的终端信息打断。</p>\n<p><strong>如何命令行启动一个后台进程</strong></p>\n<p>可以参考这篇<a href=\"http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html\" target=\"_blank\" rel=\"external\">Linux 守护进程的启动方法</a>。<br>这里简单说下里面的nohup，比如：nohup php 1.php 2&gt;&amp;1 &amp;<br>nohup表示挂起，标准输入会重定向到/dev/null，并且忽略sigup信号，它并不会让进程变为后台任务，所以需要在命令行末尾加上&amp;符号。</p>\n<ul>\n<li>2表示标准错误(stderr)</li>\n<li>‘&gt;’表示重定向</li>\n<li>1表示标准输出(stdout)</li>\n<li>0表示标准输入(stdin)</li>\n</ul>\n<p>2&gt;&amp;1整个意思是：将标准错误重定向到标准输出，在大于号后面必须加上&amp;符号，否则，它只会重定向到一个名为1的文件。<br>如果没有2&gt;&amp;1，标准输出会以nohup.out文件输出。</p>\n<p><strong>程序如何实现守护进程呢</strong></p>\n<ol>\n<li>使用umask重设文件创建掩码，通常设为0。这是为了创建文件后，设置更多权限。</li>\n<li>调用fork创建子进程，然后父进程退出。fork得来的子进程复制了父进程的环境，最重要的是这样子进程不是session leader了，也不是进程组的组长进程。这是下面setsid的条件。</li>\n<li>setsid创建新会话。这样是为了摆脱控制终端。但是这样子进程就成为了新session的session leader，而只有session leader才能控制终端。假如它打开一个终端设备文件，比如/dev/console，就有可能控制终端。所以也有人会在此时再次fork来保证进程不是session leader，从而没有可能控制终端。还有一种避免取得控制终端的方式是：open后面加上O_NOCTTY参数，比如int fd = open(“/dev/console”,O_NOCTTY);</li>\n<li>更改当前工作目录到根目录。这个其实只要你的当前工作目录不会被卸载就行。</li>\n<li>关闭不再需要的文件描述符</li>\n<li>有些可能会将0，1，2重定向到/dev/null，使标准输入输出错误无效。</li>\n</ol>\n<p><strong>但是，还留下几个问题</strong></p>\n<ol>\n<li>fork之后，父进程退出，子进程脱离了控制终端吗？如果脱离了，那为什么还要setsid呢？如果没有脱离，子进程已经不是session leader了，而只有session leader才能控制终端。</li>\n<li>终端退出时，发生了什么，何时发送signup信号</li>\n</ol>\n<p>参考资料：<br><em><a href=\"http://stackoverflow.com/questions/881388/what-is-the-reason-for-performing-a-double-fork-when-creating-a-daemon\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/881388/what-is-the-reason-for-performing-a-double-fork-when-creating-a-daemon</a></em><br><em><a href=\"http://stackoverflow.com/questions/10932592/why-fork-twice/16655124#16655124\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/10932592/why-fork-twice/16655124#16655124</a></em><br><em><a href=\"http://www.win.tue.nl/~aeb/linux/lk/lk-10.html\" target=\"_blank\" rel=\"external\">http://www.win.tue.nl/~aeb/linux/lk/lk-10.html</a></em><br><em><a href=\"http://stackoverflow.com/questions/32780706/does-linux-kill-background-processes-if-we-close-the-terminal-from-which-it-has\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/32780706/does-linux-kill-background-processes-if-we-close-the-terminal-from-which-it-has</a></em><br><em><a href=\"http://blog.csdn.net/ithomer/article/details/9288353\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/ithomer/article/details/9288353</a></em><br><em>《UNIX环境高级编程》</em></p>\n","site":{"data":{}},"excerpt":"<p>守护进程的一些原理和方法。<br>","more":"</p>\n<p><strong>首先来看几个概念：</strong></p>\n<ol>\n<li>守护进程：daemon，运行在后台的特殊进程，是生存期长的一种进程，它独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。</li>\n<li>前台进程：在多任务操作系统（诸如 UNIX/Linux）中，前台进程是用户当前与之交互的程序（例如，数据输入）。随着用户在程序之间切换，会导致这些程序在不同的时刻处于前台。在层叠的窗口环境中，前台进程是最前面的窗口。在命令行中，默认程序和命令都作为前台进程运行，要在后台运行，需要加&amp;符号。</li>\n<li>进程组：一个或者多个进程的集合。每个进程组有一个组长进程</li>\n<li>会话(session)：一个或多个进程组的集合。一个会话可以有一个控制终端，通常是终端设备。会话通常是一个登录进程创建的，创建会话的进程为会话首进程(session leader)，只有session leader才能控制终端。</li>\n</ol>\n<p><strong>那么，成为一个守护进程的关键是什么？</strong></p>\n<p>脱离终端，不继承标准输入。脱离终端的目的是避免进程在运行过程中的信息在任何终端中显示，并且进程也不会被任何终端所产生的终端信息打断。</p>\n<p><strong>如何命令行启动一个后台进程</strong></p>\n<p>可以参考这篇<a href=\"http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html\" target=\"_blank\" rel=\"external\">Linux 守护进程的启动方法</a>。<br>这里简单说下里面的nohup，比如：nohup php 1.php 2&gt;&amp;1 &amp;<br>nohup表示挂起，标准输入会重定向到/dev/null，并且忽略sigup信号，它并不会让进程变为后台任务，所以需要在命令行末尾加上&amp;符号。</p>\n<ul>\n<li>2表示标准错误(stderr)</li>\n<li>‘&gt;’表示重定向</li>\n<li>1表示标准输出(stdout)</li>\n<li>0表示标准输入(stdin)</li>\n</ul>\n<p>2&gt;&amp;1整个意思是：将标准错误重定向到标准输出，在大于号后面必须加上&amp;符号，否则，它只会重定向到一个名为1的文件。<br>如果没有2&gt;&amp;1，标准输出会以nohup.out文件输出。</p>\n<p><strong>程序如何实现守护进程呢</strong></p>\n<ol>\n<li>使用umask重设文件创建掩码，通常设为0。这是为了创建文件后，设置更多权限。</li>\n<li>调用fork创建子进程，然后父进程退出。fork得来的子进程复制了父进程的环境，最重要的是这样子进程不是session leader了，也不是进程组的组长进程。这是下面setsid的条件。</li>\n<li>setsid创建新会话。这样是为了摆脱控制终端。但是这样子进程就成为了新session的session leader，而只有session leader才能控制终端。假如它打开一个终端设备文件，比如/dev/console，就有可能控制终端。所以也有人会在此时再次fork来保证进程不是session leader，从而没有可能控制终端。还有一种避免取得控制终端的方式是：open后面加上O_NOCTTY参数，比如int fd = open(“/dev/console”,O_NOCTTY);</li>\n<li>更改当前工作目录到根目录。这个其实只要你的当前工作目录不会被卸载就行。</li>\n<li>关闭不再需要的文件描述符</li>\n<li>有些可能会将0，1，2重定向到/dev/null，使标准输入输出错误无效。</li>\n</ol>\n<p><strong>但是，还留下几个问题</strong></p>\n<ol>\n<li>fork之后，父进程退出，子进程脱离了控制终端吗？如果脱离了，那为什么还要setsid呢？如果没有脱离，子进程已经不是session leader了，而只有session leader才能控制终端。</li>\n<li>终端退出时，发生了什么，何时发送signup信号</li>\n</ol>\n<p>参考资料：<br><em><a href=\"http://stackoverflow.com/questions/881388/what-is-the-reason-for-performing-a-double-fork-when-creating-a-daemon\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/881388/what-is-the-reason-for-performing-a-double-fork-when-creating-a-daemon</a></em><br><em><a href=\"http://stackoverflow.com/questions/10932592/why-fork-twice/16655124#16655124\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/10932592/why-fork-twice/16655124#16655124</a></em><br><em><a href=\"http://www.win.tue.nl/~aeb/linux/lk/lk-10.html\" target=\"_blank\" rel=\"external\">http://www.win.tue.nl/~aeb/linux/lk/lk-10.html</a></em><br><em><a href=\"http://stackoverflow.com/questions/32780706/does-linux-kill-background-processes-if-we-close-the-terminal-from-which-it-has\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/32780706/does-linux-kill-background-processes-if-we-close-the-terminal-from-which-it-has</a></em><br><em><a href=\"http://blog.csdn.net/ithomer/article/details/9288353\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/ithomer/article/details/9288353</a></em><br><em>《UNIX环境高级编程》</em></p>"},{"title":"一个简单的makefile编写教程","date":"2016-07-15T02:39:00.000Z","_content":"\n最近在学习编写一个简单的web server，用到了makefile。\n<!--more-->\n\n翻译资料：\n>http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/\n\n官方文档：\n>http://www.gnu.org/software/make/manual/make.html#Makefile-Contents\n\nMakefiles是一种简单的组织代码编写方式。这个教程不仅仅是对make用法的一个初浅的探讨，也可以作为初学者的指南，可以给小到中型项目创建自己的makefiles文件。\n\n比如有以下三个文件：\n\n#hellomake.c\n\n```c\n#include <hellomake.h>\n\nint main() {\n  // call a function in another file\n  myPrintHelloMake();\n\n  return(0);\n}\n```\n\n#hellofunc.c\n\n```c\n#include <stdio.h>\n#include <hellomake.h>\n\nvoid myPrintHelloMake(void) {\n\n  printf(\"Hello makefiles!\\n\");\n\n  return;\n}\n```\n\n#helomake.h\n\n```c\n/*\nexample include file\n*/\n\nvoid myPrintHelloMake(void);\n```\n\n通常，你将执行下面的命令来编译这些代码：\n\n    gcc -o hellomake hellomake.c hellofunc.c -I.\n    \n这里编译了两个c文件，命名了可执行文件hellomake。-I.的意思是包含在当前目录(.)下的hellomake.h文件。典型的测试／修改／debug的方法是在终端用向上箭头来回到你最近使用的编译命令，所以你不得不每次都这样用，特别是一旦你增加了一些c文件。\n\n不幸的事，这种编译方法有两个弊端。第一，如果你丢了编译命令或者换了电脑，你不得不从零输入，效率极低。第二，如果你只是修改了一个c文件，每次都要把它们重新编译也是耗时间和效率低的。所以，是时候看看我们用一个makefile来解决这些问题了。\n\n你可以创建一个最简单的makefile，如下：\n```c\nhellomake: hellomake.c hellofunc.c\n     gcc -o hellomake hellomake.c hellofunc.c -I.\n```\n如果你把上面命令输入到一个文件叫Makefile活着makefile，然后在命令行输入make，它将会执行你在makefile文件里写的编译命令。注意到make没有参数。而且，把文件列表放到：后面，make知道如果任何一个文件改变了，规则hellomake都需要被执行。此刻，你已经解决了问题一，避免重复用键盘上的向上箭头来寻找你最近使用的编译命令。但是，仅仅改变最近编译项，系统仍然效率不高。\n\n一个非常重要需要注意的是在gcc命令前面有一个tab，这是在任何命令开始前都是必需的，否则make会很不开心。\n\n为了效率更高一点，让我们试试下面的makefile：\n```c\nCC=gcc\nCFLAGS=-I.\n\nhellomake: hellomake.o hellofunc.o\n     $(CC) -o hellomake hellomake.o hellofunc.o -I.\n```\n所以现在我们已经定义了一些常量CC和CFLAGS。这些都是特殊的常量，告诉make我们想如何编译文件hellomake.c和hellofunc.c。尤其是，宏指令CC是是c编译程序，而CFLAGS是传给编译命令的标记列表。把目标文件－hellomake.o和hellofunc.o－放入依赖列表和规则中，make知道首先应该编译.c版本文件，然后建立可执行文件hellomake。\n\n对于大部分小型项目来说用这种makefile足够了。但是，还有一件事漏掉了：头文件的包含。如果你打算修改hellomake.h文件，例如，make将不会重新编译.c文件，虽然它们是必需的。为了解决这个，我们需要告诉make所有的.c文件都依赖某个.h文件。我们可以通过写一个简单的规则，加到makefile里面来实现它。\n\n```c\nCC=gcc\nCFLAGS=-I.\nDEPS = hellomake.h\n\n%.o: %.c $(DEPS)\n\t$(CC) -c -o $@ $< $(CFLAGS)\n\nhellomake: hellomake.o hellofunc.o \n\tgcc -o hellomake hellomake.o hellofunc.o -I.\n```\n第一个新添加的是宏命令DEPS，设置.c文件依赖的.h文件。然后我们定义了一个规则应用于所有以.o结尾的文件。规则是：.o文件依赖.c文件，.h文件包含在DEPS宏命令中；创建.o文件，make必须用CC宏命令定义的编译器编译.c文件。-c标记是建立目标文件，-o $@表示把编译的输出放到:左边名字的文件中，而$<是依赖列表中的第一项，而宏命令CFLAGS正如上面所说的。\n\n最终的简化，用特别宏命令$@和$^，分别表示:左边和右边，分别使以上编译规则更加通用。在下面的例子中，所有包含文件应当在DEPS列出，所有目标文件应当在OBJ中列出。\n```c\nCC=gcc\nCFLAGS=-I.\nDEPS = hellomake.h\nOBJ = hellomake.o hellofunc.o \n\n%.o: %.c $(DEPS)\n\t$(CC) -c -o $@ $< $(CFLAGS)\n\nhellomake: $(OBJ)\n\tgcc -o $@ $^ $(CFLAGS)\n```\n所以要是我们想把.h文件放入include目录，源代码放入src目录，一些本地库文件放入lib目录会怎么样呢？再者，有时候我们能隐藏那些烦人的到处都是的.o文件吗？答案是，当然可以！随后的makefile定义了include和lib目录的路径，并且把object文件放到src目录下的obj子目录。也有一个宏命令定义了任何你想要包含的库文件，比如math库文件-lm。这个makefile应该放在src目录本地。注意到，也包含了一个清理源代码和object目录的规则make clean。.PHONY规则使make命令不会生成一个名字叫clean的文件。\n```c\nIDIR =../include\nCC=gcc\nCFLAGS=-I$(IDIR)\n\nODIR=obj\nLDIR =../lib\n\nLIBS=-lm\n\n_DEPS = hellomake.h\nDEPS = $(patsubst %,$(IDIR)/%,$(_DEPS))\n\n_OBJ = hellomake.o hellofunc.o \nOBJ = $(patsubst %,$(ODIR)/%,$(_OBJ))\n\n\n$(ODIR)/%.o: %.c $(DEPS)\n\t$(CC) -c -o $@ $< $(CFLAGS)\n\nhellomake: $(OBJ)\n\tgcc -o $@ $^ $(CFLAGS) $(LIBS)\n\n.PHONY: clean\n\nclean:\n\trm -f $(ODIR)/*.o *~ core $(INCDIR)/*~ \n```\n现在你有了一个完美的makefile，可以修改管理小到中型软件工程。你可以增加多个规则到makefile；甚至创建规则调用规则。想获取更多关于makefiles和make方法的信息，可以到官网[GNU Make Manual](http://www.gnu.org/software/make/manual/make.html)查看。","source":"_posts/2016-07-15-make-tutorial.md","raw":"---\ntitle: 一个简单的makefile编写教程\ndate: 2016-07-15 10:39:00\ntags: 翻译\ncategories: c\n---\n\n最近在学习编写一个简单的web server，用到了makefile。\n<!--more-->\n\n翻译资料：\n>http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/\n\n官方文档：\n>http://www.gnu.org/software/make/manual/make.html#Makefile-Contents\n\nMakefiles是一种简单的组织代码编写方式。这个教程不仅仅是对make用法的一个初浅的探讨，也可以作为初学者的指南，可以给小到中型项目创建自己的makefiles文件。\n\n比如有以下三个文件：\n\n#hellomake.c\n\n```c\n#include <hellomake.h>\n\nint main() {\n  // call a function in another file\n  myPrintHelloMake();\n\n  return(0);\n}\n```\n\n#hellofunc.c\n\n```c\n#include <stdio.h>\n#include <hellomake.h>\n\nvoid myPrintHelloMake(void) {\n\n  printf(\"Hello makefiles!\\n\");\n\n  return;\n}\n```\n\n#helomake.h\n\n```c\n/*\nexample include file\n*/\n\nvoid myPrintHelloMake(void);\n```\n\n通常，你将执行下面的命令来编译这些代码：\n\n    gcc -o hellomake hellomake.c hellofunc.c -I.\n    \n这里编译了两个c文件，命名了可执行文件hellomake。-I.的意思是包含在当前目录(.)下的hellomake.h文件。典型的测试／修改／debug的方法是在终端用向上箭头来回到你最近使用的编译命令，所以你不得不每次都这样用，特别是一旦你增加了一些c文件。\n\n不幸的事，这种编译方法有两个弊端。第一，如果你丢了编译命令或者换了电脑，你不得不从零输入，效率极低。第二，如果你只是修改了一个c文件，每次都要把它们重新编译也是耗时间和效率低的。所以，是时候看看我们用一个makefile来解决这些问题了。\n\n你可以创建一个最简单的makefile，如下：\n```c\nhellomake: hellomake.c hellofunc.c\n     gcc -o hellomake hellomake.c hellofunc.c -I.\n```\n如果你把上面命令输入到一个文件叫Makefile活着makefile，然后在命令行输入make，它将会执行你在makefile文件里写的编译命令。注意到make没有参数。而且，把文件列表放到：后面，make知道如果任何一个文件改变了，规则hellomake都需要被执行。此刻，你已经解决了问题一，避免重复用键盘上的向上箭头来寻找你最近使用的编译命令。但是，仅仅改变最近编译项，系统仍然效率不高。\n\n一个非常重要需要注意的是在gcc命令前面有一个tab，这是在任何命令开始前都是必需的，否则make会很不开心。\n\n为了效率更高一点，让我们试试下面的makefile：\n```c\nCC=gcc\nCFLAGS=-I.\n\nhellomake: hellomake.o hellofunc.o\n     $(CC) -o hellomake hellomake.o hellofunc.o -I.\n```\n所以现在我们已经定义了一些常量CC和CFLAGS。这些都是特殊的常量，告诉make我们想如何编译文件hellomake.c和hellofunc.c。尤其是，宏指令CC是是c编译程序，而CFLAGS是传给编译命令的标记列表。把目标文件－hellomake.o和hellofunc.o－放入依赖列表和规则中，make知道首先应该编译.c版本文件，然后建立可执行文件hellomake。\n\n对于大部分小型项目来说用这种makefile足够了。但是，还有一件事漏掉了：头文件的包含。如果你打算修改hellomake.h文件，例如，make将不会重新编译.c文件，虽然它们是必需的。为了解决这个，我们需要告诉make所有的.c文件都依赖某个.h文件。我们可以通过写一个简单的规则，加到makefile里面来实现它。\n\n```c\nCC=gcc\nCFLAGS=-I.\nDEPS = hellomake.h\n\n%.o: %.c $(DEPS)\n\t$(CC) -c -o $@ $< $(CFLAGS)\n\nhellomake: hellomake.o hellofunc.o \n\tgcc -o hellomake hellomake.o hellofunc.o -I.\n```\n第一个新添加的是宏命令DEPS，设置.c文件依赖的.h文件。然后我们定义了一个规则应用于所有以.o结尾的文件。规则是：.o文件依赖.c文件，.h文件包含在DEPS宏命令中；创建.o文件，make必须用CC宏命令定义的编译器编译.c文件。-c标记是建立目标文件，-o $@表示把编译的输出放到:左边名字的文件中，而$<是依赖列表中的第一项，而宏命令CFLAGS正如上面所说的。\n\n最终的简化，用特别宏命令$@和$^，分别表示:左边和右边，分别使以上编译规则更加通用。在下面的例子中，所有包含文件应当在DEPS列出，所有目标文件应当在OBJ中列出。\n```c\nCC=gcc\nCFLAGS=-I.\nDEPS = hellomake.h\nOBJ = hellomake.o hellofunc.o \n\n%.o: %.c $(DEPS)\n\t$(CC) -c -o $@ $< $(CFLAGS)\n\nhellomake: $(OBJ)\n\tgcc -o $@ $^ $(CFLAGS)\n```\n所以要是我们想把.h文件放入include目录，源代码放入src目录，一些本地库文件放入lib目录会怎么样呢？再者，有时候我们能隐藏那些烦人的到处都是的.o文件吗？答案是，当然可以！随后的makefile定义了include和lib目录的路径，并且把object文件放到src目录下的obj子目录。也有一个宏命令定义了任何你想要包含的库文件，比如math库文件-lm。这个makefile应该放在src目录本地。注意到，也包含了一个清理源代码和object目录的规则make clean。.PHONY规则使make命令不会生成一个名字叫clean的文件。\n```c\nIDIR =../include\nCC=gcc\nCFLAGS=-I$(IDIR)\n\nODIR=obj\nLDIR =../lib\n\nLIBS=-lm\n\n_DEPS = hellomake.h\nDEPS = $(patsubst %,$(IDIR)/%,$(_DEPS))\n\n_OBJ = hellomake.o hellofunc.o \nOBJ = $(patsubst %,$(ODIR)/%,$(_OBJ))\n\n\n$(ODIR)/%.o: %.c $(DEPS)\n\t$(CC) -c -o $@ $< $(CFLAGS)\n\nhellomake: $(OBJ)\n\tgcc -o $@ $^ $(CFLAGS) $(LIBS)\n\n.PHONY: clean\n\nclean:\n\trm -f $(ODIR)/*.o *~ core $(INCDIR)/*~ \n```\n现在你有了一个完美的makefile，可以修改管理小到中型软件工程。你可以增加多个规则到makefile；甚至创建规则调用规则。想获取更多关于makefiles和make方法的信息，可以到官网[GNU Make Manual](http://www.gnu.org/software/make/manual/make.html)查看。","slug":"make-tutorial","published":1,"updated":"2017-09-18T11:36:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7q4uqzk000pkkje0g53sdl3","content":"<p>最近在学习编写一个简单的web server，用到了makefile。<br><a id=\"more\"></a></p>\n<p>翻译资料：</p>\n<blockquote>\n<p><a href=\"http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/\" target=\"_blank\" rel=\"external\">http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/</a></p>\n</blockquote>\n<p>官方文档：</p>\n<blockquote>\n<p><a href=\"http://www.gnu.org/software/make/manual/make.html#Makefile-Contents\" target=\"_blank\" rel=\"external\">http://www.gnu.org/software/make/manual/make.html#Makefile-Contents</a></p>\n</blockquote>\n<p>Makefiles是一种简单的组织代码编写方式。这个教程不仅仅是对make用法的一个初浅的探讨，也可以作为初学者的指南，可以给小到中型项目创建自己的makefiles文件。</p>\n<p>比如有以下三个文件：</p>\n<p>#hellomake.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;hellomake.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// call a function in another file</span></div><div class=\"line\">  myPrintHelloMake();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>#hellofunc.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;hellomake.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myPrintHelloMake</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello makefiles!\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>#helomake.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">example include file</span></div><div class=\"line\"><span class=\"comment\">*/</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myPrintHelloMake</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div></pre></td></tr></table></figure>\n<p>通常，你将执行下面的命令来编译这些代码：</p>\n<pre><code>gcc -o hellomake hellomake.c hellofunc.c -I.\n</code></pre><p>这里编译了两个c文件，命名了可执行文件hellomake。-I.的意思是包含在当前目录(.)下的hellomake.h文件。典型的测试／修改／debug的方法是在终端用向上箭头来回到你最近使用的编译命令，所以你不得不每次都这样用，特别是一旦你增加了一些c文件。</p>\n<p>不幸的事，这种编译方法有两个弊端。第一，如果你丢了编译命令或者换了电脑，你不得不从零输入，效率极低。第二，如果你只是修改了一个c文件，每次都要把它们重新编译也是耗时间和效率低的。所以，是时候看看我们用一个makefile来解决这些问题了。</p>\n<p>你可以创建一个最简单的makefile，如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hellomake: hellomake.c hellofunc.c</div><div class=\"line\">     gcc -o hellomake hellomake.c hellofunc.c -I.</div></pre></td></tr></table></figure></p>\n<p>如果你把上面命令输入到一个文件叫Makefile活着makefile，然后在命令行输入make，它将会执行你在makefile文件里写的编译命令。注意到make没有参数。而且，把文件列表放到：后面，make知道如果任何一个文件改变了，规则hellomake都需要被执行。此刻，你已经解决了问题一，避免重复用键盘上的向上箭头来寻找你最近使用的编译命令。但是，仅仅改变最近编译项，系统仍然效率不高。</p>\n<p>一个非常重要需要注意的是在gcc命令前面有一个tab，这是在任何命令开始前都是必需的，否则make会很不开心。</p>\n<p>为了效率更高一点，让我们试试下面的makefile：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">CC=gcc</div><div class=\"line\">CFLAGS=-I.</div><div class=\"line\"></div><div class=\"line\">hellomake: hellomake.o hellofunc.o</div><div class=\"line\">     $(CC) -o hellomake hellomake.o hellofunc.o -I.</div></pre></td></tr></table></figure></p>\n<p>所以现在我们已经定义了一些常量CC和CFLAGS。这些都是特殊的常量，告诉make我们想如何编译文件hellomake.c和hellofunc.c。尤其是，宏指令CC是是c编译程序，而CFLAGS是传给编译命令的标记列表。把目标文件－hellomake.o和hellofunc.o－放入依赖列表和规则中，make知道首先应该编译.c版本文件，然后建立可执行文件hellomake。</p>\n<p>对于大部分小型项目来说用这种makefile足够了。但是，还有一件事漏掉了：头文件的包含。如果你打算修改hellomake.h文件，例如，make将不会重新编译.c文件，虽然它们是必需的。为了解决这个，我们需要告诉make所有的.c文件都依赖某个.h文件。我们可以通过写一个简单的规则，加到makefile里面来实现它。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">CC=gcc</div><div class=\"line\">CFLAGS=-I.</div><div class=\"line\">DEPS = hellomake.h</div><div class=\"line\"></div><div class=\"line\">%.o: %.c $(DEPS)</div><div class=\"line\">\t$(CC) -c -o $@ $&lt; $(CFLAGS)</div><div class=\"line\"></div><div class=\"line\">hellomake: hellomake.o hellofunc.o </div><div class=\"line\">\tgcc -o hellomake hellomake.o hellofunc.o -I.</div></pre></td></tr></table></figure>\n<p>第一个新添加的是宏命令DEPS，设置.c文件依赖的.h文件。然后我们定义了一个规则应用于所有以.o结尾的文件。规则是：.o文件依赖.c文件，.h文件包含在DEPS宏命令中；创建.o文件，make必须用CC宏命令定义的编译器编译.c文件。-c标记是建立目标文件，-o $@表示把编译的输出放到:左边名字的文件中，而$&lt;是依赖列表中的第一项，而宏命令CFLAGS正如上面所说的。</p>\n<p>最终的简化，用特别宏命令$@和$^，分别表示:左边和右边，分别使以上编译规则更加通用。在下面的例子中，所有包含文件应当在DEPS列出，所有目标文件应当在OBJ中列出。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">CC=gcc</div><div class=\"line\">CFLAGS=-I.</div><div class=\"line\">DEPS = hellomake.h</div><div class=\"line\">OBJ = hellomake.o hellofunc.o </div><div class=\"line\"></div><div class=\"line\">%.o: %.c $(DEPS)</div><div class=\"line\">\t$(CC) -c -o $@ $&lt; $(CFLAGS)</div><div class=\"line\"></div><div class=\"line\">hellomake: $(OBJ)</div><div class=\"line\">\tgcc -o $@ $^ $(CFLAGS)</div></pre></td></tr></table></figure></p>\n<p>所以要是我们想把.h文件放入include目录，源代码放入src目录，一些本地库文件放入lib目录会怎么样呢？再者，有时候我们能隐藏那些烦人的到处都是的.o文件吗？答案是，当然可以！随后的makefile定义了include和lib目录的路径，并且把object文件放到src目录下的obj子目录。也有一个宏命令定义了任何你想要包含的库文件，比如math库文件-lm。这个makefile应该放在src目录本地。注意到，也包含了一个清理源代码和object目录的规则make clean。.PHONY规则使make命令不会生成一个名字叫clean的文件。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">IDIR =../include</div><div class=\"line\">CC=gcc</div><div class=\"line\">CFLAGS=-I$(IDIR)</div><div class=\"line\"></div><div class=\"line\">ODIR=obj</div><div class=\"line\">LDIR =../lib</div><div class=\"line\"></div><div class=\"line\">LIBS=-lm</div><div class=\"line\"></div><div class=\"line\">_DEPS = hellomake.h</div><div class=\"line\">DEPS = $(patsubst %,$(IDIR)/%,$(_DEPS))</div><div class=\"line\"></div><div class=\"line\">_OBJ = hellomake.o hellofunc.o </div><div class=\"line\">OBJ = $(patsubst %,$(ODIR)/%,$(_OBJ))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$(ODIR)/%.o: %.c $(DEPS)</div><div class=\"line\">\t$(CC) -c -o $@ $&lt; $(CFLAGS)</div><div class=\"line\"></div><div class=\"line\">hellomake: $(OBJ)</div><div class=\"line\">\tgcc -o $@ $^ $(CFLAGS) $(LIBS)</div><div class=\"line\"></div><div class=\"line\">.PHONY: clean</div><div class=\"line\"></div><div class=\"line\">clean:</div><div class=\"line\">\trm -f $(ODIR)<span class=\"comment\">/*.o *~ core $(INCDIR)/*~</span></div></pre></td></tr></table></figure></p>\n<p>现在你有了一个完美的makefile，可以修改管理小到中型软件工程。你可以增加多个规则到makefile；甚至创建规则调用规则。想获取更多关于makefiles和make方法的信息，可以到官网<a href=\"http://www.gnu.org/software/make/manual/make.html\" target=\"_blank\" rel=\"external\">GNU Make Manual</a>查看。</p>\n","site":{"data":{}},"excerpt":"<p>最近在学习编写一个简单的web server，用到了makefile。<br>","more":"</p>\n<p>翻译资料：</p>\n<blockquote>\n<p><a href=\"http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/\" target=\"_blank\" rel=\"external\">http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/</a></p>\n</blockquote>\n<p>官方文档：</p>\n<blockquote>\n<p><a href=\"http://www.gnu.org/software/make/manual/make.html#Makefile-Contents\" target=\"_blank\" rel=\"external\">http://www.gnu.org/software/make/manual/make.html#Makefile-Contents</a></p>\n</blockquote>\n<p>Makefiles是一种简单的组织代码编写方式。这个教程不仅仅是对make用法的一个初浅的探讨，也可以作为初学者的指南，可以给小到中型项目创建自己的makefiles文件。</p>\n<p>比如有以下三个文件：</p>\n<p>#hellomake.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;hellomake.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// call a function in another file</span></div><div class=\"line\">  myPrintHelloMake();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>#hellofunc.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;hellomake.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myPrintHelloMake</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello makefiles!\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>#helomake.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">example include file</span></div><div class=\"line\"><span class=\"comment\">*/</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myPrintHelloMake</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div></pre></td></tr></table></figure>\n<p>通常，你将执行下面的命令来编译这些代码：</p>\n<pre><code>gcc -o hellomake hellomake.c hellofunc.c -I.\n</code></pre><p>这里编译了两个c文件，命名了可执行文件hellomake。-I.的意思是包含在当前目录(.)下的hellomake.h文件。典型的测试／修改／debug的方法是在终端用向上箭头来回到你最近使用的编译命令，所以你不得不每次都这样用，特别是一旦你增加了一些c文件。</p>\n<p>不幸的事，这种编译方法有两个弊端。第一，如果你丢了编译命令或者换了电脑，你不得不从零输入，效率极低。第二，如果你只是修改了一个c文件，每次都要把它们重新编译也是耗时间和效率低的。所以，是时候看看我们用一个makefile来解决这些问题了。</p>\n<p>你可以创建一个最简单的makefile，如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hellomake: hellomake.c hellofunc.c</div><div class=\"line\">     gcc -o hellomake hellomake.c hellofunc.c -I.</div></pre></td></tr></table></figure></p>\n<p>如果你把上面命令输入到一个文件叫Makefile活着makefile，然后在命令行输入make，它将会执行你在makefile文件里写的编译命令。注意到make没有参数。而且，把文件列表放到：后面，make知道如果任何一个文件改变了，规则hellomake都需要被执行。此刻，你已经解决了问题一，避免重复用键盘上的向上箭头来寻找你最近使用的编译命令。但是，仅仅改变最近编译项，系统仍然效率不高。</p>\n<p>一个非常重要需要注意的是在gcc命令前面有一个tab，这是在任何命令开始前都是必需的，否则make会很不开心。</p>\n<p>为了效率更高一点，让我们试试下面的makefile：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">CC=gcc</div><div class=\"line\">CFLAGS=-I.</div><div class=\"line\"></div><div class=\"line\">hellomake: hellomake.o hellofunc.o</div><div class=\"line\">     $(CC) -o hellomake hellomake.o hellofunc.o -I.</div></pre></td></tr></table></figure></p>\n<p>所以现在我们已经定义了一些常量CC和CFLAGS。这些都是特殊的常量，告诉make我们想如何编译文件hellomake.c和hellofunc.c。尤其是，宏指令CC是是c编译程序，而CFLAGS是传给编译命令的标记列表。把目标文件－hellomake.o和hellofunc.o－放入依赖列表和规则中，make知道首先应该编译.c版本文件，然后建立可执行文件hellomake。</p>\n<p>对于大部分小型项目来说用这种makefile足够了。但是，还有一件事漏掉了：头文件的包含。如果你打算修改hellomake.h文件，例如，make将不会重新编译.c文件，虽然它们是必需的。为了解决这个，我们需要告诉make所有的.c文件都依赖某个.h文件。我们可以通过写一个简单的规则，加到makefile里面来实现它。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">CC=gcc</div><div class=\"line\">CFLAGS=-I.</div><div class=\"line\">DEPS = hellomake.h</div><div class=\"line\"></div><div class=\"line\">%.o: %.c $(DEPS)</div><div class=\"line\">\t$(CC) -c -o $@ $&lt; $(CFLAGS)</div><div class=\"line\"></div><div class=\"line\">hellomake: hellomake.o hellofunc.o </div><div class=\"line\">\tgcc -o hellomake hellomake.o hellofunc.o -I.</div></pre></td></tr></table></figure>\n<p>第一个新添加的是宏命令DEPS，设置.c文件依赖的.h文件。然后我们定义了一个规则应用于所有以.o结尾的文件。规则是：.o文件依赖.c文件，.h文件包含在DEPS宏命令中；创建.o文件，make必须用CC宏命令定义的编译器编译.c文件。-c标记是建立目标文件，-o $@表示把编译的输出放到:左边名字的文件中，而$&lt;是依赖列表中的第一项，而宏命令CFLAGS正如上面所说的。</p>\n<p>最终的简化，用特别宏命令$@和$^，分别表示:左边和右边，分别使以上编译规则更加通用。在下面的例子中，所有包含文件应当在DEPS列出，所有目标文件应当在OBJ中列出。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">CC=gcc</div><div class=\"line\">CFLAGS=-I.</div><div class=\"line\">DEPS = hellomake.h</div><div class=\"line\">OBJ = hellomake.o hellofunc.o </div><div class=\"line\"></div><div class=\"line\">%.o: %.c $(DEPS)</div><div class=\"line\">\t$(CC) -c -o $@ $&lt; $(CFLAGS)</div><div class=\"line\"></div><div class=\"line\">hellomake: $(OBJ)</div><div class=\"line\">\tgcc -o $@ $^ $(CFLAGS)</div></pre></td></tr></table></figure></p>\n<p>所以要是我们想把.h文件放入include目录，源代码放入src目录，一些本地库文件放入lib目录会怎么样呢？再者，有时候我们能隐藏那些烦人的到处都是的.o文件吗？答案是，当然可以！随后的makefile定义了include和lib目录的路径，并且把object文件放到src目录下的obj子目录。也有一个宏命令定义了任何你想要包含的库文件，比如math库文件-lm。这个makefile应该放在src目录本地。注意到，也包含了一个清理源代码和object目录的规则make clean。.PHONY规则使make命令不会生成一个名字叫clean的文件。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">IDIR =../include</div><div class=\"line\">CC=gcc</div><div class=\"line\">CFLAGS=-I$(IDIR)</div><div class=\"line\"></div><div class=\"line\">ODIR=obj</div><div class=\"line\">LDIR =../lib</div><div class=\"line\"></div><div class=\"line\">LIBS=-lm</div><div class=\"line\"></div><div class=\"line\">_DEPS = hellomake.h</div><div class=\"line\">DEPS = $(patsubst %,$(IDIR)/%,$(_DEPS))</div><div class=\"line\"></div><div class=\"line\">_OBJ = hellomake.o hellofunc.o </div><div class=\"line\">OBJ = $(patsubst %,$(ODIR)/%,$(_OBJ))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$(ODIR)/%.o: %.c $(DEPS)</div><div class=\"line\">\t$(CC) -c -o $@ $&lt; $(CFLAGS)</div><div class=\"line\"></div><div class=\"line\">hellomake: $(OBJ)</div><div class=\"line\">\tgcc -o $@ $^ $(CFLAGS) $(LIBS)</div><div class=\"line\"></div><div class=\"line\">.PHONY: clean</div><div class=\"line\"></div><div class=\"line\">clean:</div><div class=\"line\">\trm -f $(ODIR)<span class=\"comment\">/*.o *~ core $(INCDIR)/*~</span></div></pre></td></tr></table></figure></p>\n<p>现在你有了一个完美的makefile，可以修改管理小到中型软件工程。你可以增加多个规则到makefile；甚至创建规则调用规则。想获取更多关于makefiles和make方法的信息，可以到官网<a href=\"http://www.gnu.org/software/make/manual/make.html\" target=\"_blank\" rel=\"external\">GNU Make Manual</a>查看。</p>"},{"title":"varchar和char区别","date":"2016-10-27T02:19:03.000Z","_content":"\n翻译官方文档：\n* https://dev.mysql.com/doc/refman/5.7/en/char.html\n\n<!--more-->\n\nchar和varchar类型比较相似，但是在存储和取出有区别，在最大长度和是否在尾部保留空格也有区别。\n\nchar和varchar都有一个长度声明，定义了你想存储的最大字符数。比如，char(30)可以存储最多30个字符。\n\n当创建表时，char列的长度会一直补足到你所声明的长度。长度可以从0到255。当存储char类型值时，会在右边补足空格直到指定长度。当取出char类型值时，尾部空格将会被移除，除非[PAD_CHAR_TO_FULL_LENGTH](https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_pad_char_to_full_length)sql模式被启用。\n\nvarchar列中的值是可变长的字符串。长度可以指定从0到65535。一个varchar的有效最大长度取决于最大行大小(65535字节，在各个列之间取)和所设置的字符。可以查看[Section C.10.4, “Limits on Table Column Count and Row Size”](https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html)。\n\n相比于char，varchar会在数据值前缀增加1字节或者2字节长度。这个前缀的长度定义了值的字节数。如果值没有超过255字节，那么用1个字节存储长度；超过了则用2字节。\n\n如果没有启用严格SQL模式，而你赋值给一个char或者varchar列超过了列的最大长度，那么这个值会被截取，然后生成一个警告。启用严格SQL模式后，然后产生一个错误，并且值不会被插入。查看[Section 6.1.8, “Server SQL Modes”](https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html)。\n\n对于varchar类型列，超过列长的尾部空格会在插入前删除，然后产生一个警告，和当前所使用的SQL模式无关。对于char类型列，超过的空格会被默默的从插入的值中截取，也和当前所使用的SQL模式无关。\n\n当存储varchar时，值不会被补充。尾部空格会被保留当存储和取出时，这符合标准SQL。\n\n以下图表说明了char和varchar存储字符串的区别，char(4)和varchar(4)列（假设列用单字节字符串存储，比如latin1）。\n\nValue | CHAR(4) | Storage Required | VARCHAR(4) | Storage Required\n------------ | ------------- | ------------ | ------------ | ------------\n'' | '    ' | 4 bytes | '' | 1 byte\n'ab' | 'ab  ' | 4 bytes | 'ab' | 3 bytes\n'abcd' | 'abcd' | 4 bytes | 'abcd' | 5 bytes\n'abcdefgh' | 'abcd' | 4 bytes | 'abcd' | 5 bytes\n\n上面表中最后一行，只有在严格SQL模式下才会出现。如果是非严格SQL模式，超过长度的值不会被存储，并且报错。\n\n对于 InnoDB的 COMPACT, DYNAMIC 和COMPRESSED 行格式，如果列值长度大于等于768字节，char被当作可变长度对待，当是utf8mb4时，如果最大字节长度设置为超过3也会发生。例如，当被当作可变长度类型时，一个char列的值可能被选为off-page存储。查看更多信息，[Section 15.11, “InnoDB Row Storage and Row Formats”](https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html)。\n\n如果值存入char(4)和varchar(4)列，从列中取出不会总是一样的，因为尾部空格会从char列中移除，并且无法复原。以下例子说明了这个差异：\n\n    mysql> CREATE TABLE vc (v VARCHAR(4), c CHAR(4));\n    Query OK, 0 rows affected (0.01 sec)\n\n    mysql> INSERT INTO vc VALUES ('ab  ', 'ab  ');\n    Query OK, 1 row affected (0.00 sec)\n\n    mysql> SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;\n    +---------------------+---------------------+\n    | CONCAT('(', v, ')') | CONCAT('(', c, ')') |\n    +---------------------+---------------------+\n    | (ab  )              | (ab)                |\n    +---------------------+---------------------+\n    1 row in set (0.06 sec)\nchar和varchar列的值会被排序和比较根据赋值给这个值的字符校对。\n\n所有的mysql校对都是PADSPACE类型。这意味着所有的char,varchar和text值在被比较的时候，不会去考虑尾部空格。在这里说的比较不包含like模式匹配操作，like中尾部空格是很重要的。例如：\n\n    mysql> CREATE TABLE names (myname CHAR(10));\n    Query OK, 0 rows affected (0.03 sec)\n\n    mysql> INSERT INTO names VALUES ('Monty');\n    Query OK, 1 row affected (0.00 sec)\n\n    mysql> SELECT myname = 'Monty', myname = 'Monty  ' FROM names;\n    +------------------+--------------------+\n    | myname = 'Monty' | myname = 'Monty  ' |\n    +------------------+--------------------+\n    |                1 |                  1 |\n    +------------------+--------------------+\n    1 row in set (0.00 sec)\n\n    mysql> SELECT myname LIKE 'Monty', myname LIKE 'Monty  ' FROM names;\n    +---------------------+-----------------------+\n    | myname LIKE 'Monty' | myname LIKE 'Monty  ' |\n    +---------------------+-----------------------+\n    |                   1 |                     0 |\n    +---------------------+-----------------------+\n    1 row in set (0.00 sec)\n这对所有的mysql版本都一样，也不会对SQL模式所影响。\n\n#### Note\n更多MYSQL字符和校对的信息，查看[Section 11.1, “Character Set Support”](https://dev.mysql.com/doc/refman/5.7/en/charset.html)。关于存储需要的额外信息，查看[Section 12.8, “Data Type Storage Requirements”](https://dev.mysql.com/doc/refman/5.7/en/storage-requirements.html)。\n    \n那些尾部补足字符除去或者忽略比较的情况，如果一个列有一个唯一索引，只有在尾部有补足字符时不同，报重复键错误。比如，一个表包含'a'，当试图存储'a '会引起一个重复键错误。(**注释：唯一索引会忽略尾部空格**)\n\n","source":"_posts/2016-10-27-char-varchar.md","raw":"---\ntitle: varchar和char区别\ndate: 2016-10-27 10:19:03\ntags: mysql\ncategories: 数据库\n---\n\n翻译官方文档：\n* https://dev.mysql.com/doc/refman/5.7/en/char.html\n\n<!--more-->\n\nchar和varchar类型比较相似，但是在存储和取出有区别，在最大长度和是否在尾部保留空格也有区别。\n\nchar和varchar都有一个长度声明，定义了你想存储的最大字符数。比如，char(30)可以存储最多30个字符。\n\n当创建表时，char列的长度会一直补足到你所声明的长度。长度可以从0到255。当存储char类型值时，会在右边补足空格直到指定长度。当取出char类型值时，尾部空格将会被移除，除非[PAD_CHAR_TO_FULL_LENGTH](https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_pad_char_to_full_length)sql模式被启用。\n\nvarchar列中的值是可变长的字符串。长度可以指定从0到65535。一个varchar的有效最大长度取决于最大行大小(65535字节，在各个列之间取)和所设置的字符。可以查看[Section C.10.4, “Limits on Table Column Count and Row Size”](https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html)。\n\n相比于char，varchar会在数据值前缀增加1字节或者2字节长度。这个前缀的长度定义了值的字节数。如果值没有超过255字节，那么用1个字节存储长度；超过了则用2字节。\n\n如果没有启用严格SQL模式，而你赋值给一个char或者varchar列超过了列的最大长度，那么这个值会被截取，然后生成一个警告。启用严格SQL模式后，然后产生一个错误，并且值不会被插入。查看[Section 6.1.8, “Server SQL Modes”](https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html)。\n\n对于varchar类型列，超过列长的尾部空格会在插入前删除，然后产生一个警告，和当前所使用的SQL模式无关。对于char类型列，超过的空格会被默默的从插入的值中截取，也和当前所使用的SQL模式无关。\n\n当存储varchar时，值不会被补充。尾部空格会被保留当存储和取出时，这符合标准SQL。\n\n以下图表说明了char和varchar存储字符串的区别，char(4)和varchar(4)列（假设列用单字节字符串存储，比如latin1）。\n\nValue | CHAR(4) | Storage Required | VARCHAR(4) | Storage Required\n------------ | ------------- | ------------ | ------------ | ------------\n'' | '    ' | 4 bytes | '' | 1 byte\n'ab' | 'ab  ' | 4 bytes | 'ab' | 3 bytes\n'abcd' | 'abcd' | 4 bytes | 'abcd' | 5 bytes\n'abcdefgh' | 'abcd' | 4 bytes | 'abcd' | 5 bytes\n\n上面表中最后一行，只有在严格SQL模式下才会出现。如果是非严格SQL模式，超过长度的值不会被存储，并且报错。\n\n对于 InnoDB的 COMPACT, DYNAMIC 和COMPRESSED 行格式，如果列值长度大于等于768字节，char被当作可变长度对待，当是utf8mb4时，如果最大字节长度设置为超过3也会发生。例如，当被当作可变长度类型时，一个char列的值可能被选为off-page存储。查看更多信息，[Section 15.11, “InnoDB Row Storage and Row Formats”](https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html)。\n\n如果值存入char(4)和varchar(4)列，从列中取出不会总是一样的，因为尾部空格会从char列中移除，并且无法复原。以下例子说明了这个差异：\n\n    mysql> CREATE TABLE vc (v VARCHAR(4), c CHAR(4));\n    Query OK, 0 rows affected (0.01 sec)\n\n    mysql> INSERT INTO vc VALUES ('ab  ', 'ab  ');\n    Query OK, 1 row affected (0.00 sec)\n\n    mysql> SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;\n    +---------------------+---------------------+\n    | CONCAT('(', v, ')') | CONCAT('(', c, ')') |\n    +---------------------+---------------------+\n    | (ab  )              | (ab)                |\n    +---------------------+---------------------+\n    1 row in set (0.06 sec)\nchar和varchar列的值会被排序和比较根据赋值给这个值的字符校对。\n\n所有的mysql校对都是PADSPACE类型。这意味着所有的char,varchar和text值在被比较的时候，不会去考虑尾部空格。在这里说的比较不包含like模式匹配操作，like中尾部空格是很重要的。例如：\n\n    mysql> CREATE TABLE names (myname CHAR(10));\n    Query OK, 0 rows affected (0.03 sec)\n\n    mysql> INSERT INTO names VALUES ('Monty');\n    Query OK, 1 row affected (0.00 sec)\n\n    mysql> SELECT myname = 'Monty', myname = 'Monty  ' FROM names;\n    +------------------+--------------------+\n    | myname = 'Monty' | myname = 'Monty  ' |\n    +------------------+--------------------+\n    |                1 |                  1 |\n    +------------------+--------------------+\n    1 row in set (0.00 sec)\n\n    mysql> SELECT myname LIKE 'Monty', myname LIKE 'Monty  ' FROM names;\n    +---------------------+-----------------------+\n    | myname LIKE 'Monty' | myname LIKE 'Monty  ' |\n    +---------------------+-----------------------+\n    |                   1 |                     0 |\n    +---------------------+-----------------------+\n    1 row in set (0.00 sec)\n这对所有的mysql版本都一样，也不会对SQL模式所影响。\n\n#### Note\n更多MYSQL字符和校对的信息，查看[Section 11.1, “Character Set Support”](https://dev.mysql.com/doc/refman/5.7/en/charset.html)。关于存储需要的额外信息，查看[Section 12.8, “Data Type Storage Requirements”](https://dev.mysql.com/doc/refman/5.7/en/storage-requirements.html)。\n    \n那些尾部补足字符除去或者忽略比较的情况，如果一个列有一个唯一索引，只有在尾部有补足字符时不同，报重复键错误。比如，一个表包含'a'，当试图存储'a '会引起一个重复键错误。(**注释：唯一索引会忽略尾部空格**)\n\n","slug":"char-varchar","published":1,"updated":"2017-09-18T11:36:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7q4uqzr000ukkje8fya8stg","content":"<p>翻译官方文档：</p>\n<ul>\n<li><a href=\"https://dev.mysql.com/doc/refman/5.7/en/char.html\" target=\"_blank\" rel=\"external\">https://dev.mysql.com/doc/refman/5.7/en/char.html</a></li>\n</ul>\n<a id=\"more\"></a>\n<p>char和varchar类型比较相似，但是在存储和取出有区别，在最大长度和是否在尾部保留空格也有区别。</p>\n<p>char和varchar都有一个长度声明，定义了你想存储的最大字符数。比如，char(30)可以存储最多30个字符。</p>\n<p>当创建表时，char列的长度会一直补足到你所声明的长度。长度可以从0到255。当存储char类型值时，会在右边补足空格直到指定长度。当取出char类型值时，尾部空格将会被移除，除非<a href=\"https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_pad_char_to_full_length\" target=\"_blank\" rel=\"external\">PAD_CHAR_TO_FULL_LENGTH</a>sql模式被启用。</p>\n<p>varchar列中的值是可变长的字符串。长度可以指定从0到65535。一个varchar的有效最大长度取决于最大行大小(65535字节，在各个列之间取)和所设置的字符。可以查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html\" target=\"_blank\" rel=\"external\">Section C.10.4, “Limits on Table Column Count and Row Size”</a>。</p>\n<p>相比于char，varchar会在数据值前缀增加1字节或者2字节长度。这个前缀的长度定义了值的字节数。如果值没有超过255字节，那么用1个字节存储长度；超过了则用2字节。</p>\n<p>如果没有启用严格SQL模式，而你赋值给一个char或者varchar列超过了列的最大长度，那么这个值会被截取，然后生成一个警告。启用严格SQL模式后，然后产生一个错误，并且值不会被插入。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html\" target=\"_blank\" rel=\"external\">Section 6.1.8, “Server SQL Modes”</a>。</p>\n<p>对于varchar类型列，超过列长的尾部空格会在插入前删除，然后产生一个警告，和当前所使用的SQL模式无关。对于char类型列，超过的空格会被默默的从插入的值中截取，也和当前所使用的SQL模式无关。</p>\n<p>当存储varchar时，值不会被补充。尾部空格会被保留当存储和取出时，这符合标准SQL。</p>\n<p>以下图表说明了char和varchar存储字符串的区别，char(4)和varchar(4)列（假设列用单字节字符串存储，比如latin1）。</p>\n<table>\n<thead>\n<tr>\n<th>Value</th>\n<th>CHAR(4)</th>\n<th>Storage Required</th>\n<th>VARCHAR(4)</th>\n<th>Storage Required</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>‘’</td>\n<td>‘    ‘</td>\n<td>4 bytes</td>\n<td>‘’</td>\n<td>1 byte</td>\n</tr>\n<tr>\n<td>‘ab’</td>\n<td>‘ab  ‘</td>\n<td>4 bytes</td>\n<td>‘ab’</td>\n<td>3 bytes</td>\n</tr>\n<tr>\n<td>‘abcd’</td>\n<td>‘abcd’</td>\n<td>4 bytes</td>\n<td>‘abcd’</td>\n<td>5 bytes</td>\n</tr>\n<tr>\n<td>‘abcdefgh’</td>\n<td>‘abcd’</td>\n<td>4 bytes</td>\n<td>‘abcd’</td>\n<td>5 bytes</td>\n</tr>\n</tbody>\n</table>\n<p>上面表中最后一行，只有在严格SQL模式下才会出现。如果是非严格SQL模式，超过长度的值不会被存储，并且报错。</p>\n<p>对于 InnoDB的 COMPACT, DYNAMIC 和COMPRESSED 行格式，如果列值长度大于等于768字节，char被当作可变长度对待，当是utf8mb4时，如果最大字节长度设置为超过3也会发生。例如，当被当作可变长度类型时，一个char列的值可能被选为off-page存储。查看更多信息，<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html\" target=\"_blank\" rel=\"external\">Section 15.11, “InnoDB Row Storage and Row Formats”</a>。</p>\n<p>如果值存入char(4)和varchar(4)列，从列中取出不会总是一样的，因为尾部空格会从char列中移除，并且无法复原。以下例子说明了这个差异：</p>\n<pre><code>mysql&gt; CREATE TABLE vc (v VARCHAR(4), c CHAR(4));\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; INSERT INTO vc VALUES (&apos;ab  &apos;, &apos;ab  &apos;);\nQuery OK, 1 row affected (0.00 sec)\n\nmysql&gt; SELECT CONCAT(&apos;(&apos;, v, &apos;)&apos;), CONCAT(&apos;(&apos;, c, &apos;)&apos;) FROM vc;\n+---------------------+---------------------+\n| CONCAT(&apos;(&apos;, v, &apos;)&apos;) | CONCAT(&apos;(&apos;, c, &apos;)&apos;) |\n+---------------------+---------------------+\n| (ab  )              | (ab)                |\n+---------------------+---------------------+\n1 row in set (0.06 sec)\n</code></pre><p>char和varchar列的值会被排序和比较根据赋值给这个值的字符校对。</p>\n<p>所有的mysql校对都是PADSPACE类型。这意味着所有的char,varchar和text值在被比较的时候，不会去考虑尾部空格。在这里说的比较不包含like模式匹配操作，like中尾部空格是很重要的。例如：</p>\n<pre><code>mysql&gt; CREATE TABLE names (myname CHAR(10));\nQuery OK, 0 rows affected (0.03 sec)\n\nmysql&gt; INSERT INTO names VALUES (&apos;Monty&apos;);\nQuery OK, 1 row affected (0.00 sec)\n\nmysql&gt; SELECT myname = &apos;Monty&apos;, myname = &apos;Monty  &apos; FROM names;\n+------------------+--------------------+\n| myname = &apos;Monty&apos; | myname = &apos;Monty  &apos; |\n+------------------+--------------------+\n|                1 |                  1 |\n+------------------+--------------------+\n1 row in set (0.00 sec)\n\nmysql&gt; SELECT myname LIKE &apos;Monty&apos;, myname LIKE &apos;Monty  &apos; FROM names;\n+---------------------+-----------------------+\n| myname LIKE &apos;Monty&apos; | myname LIKE &apos;Monty  &apos; |\n+---------------------+-----------------------+\n|                   1 |                     0 |\n+---------------------+-----------------------+\n1 row in set (0.00 sec)\n</code></pre><p>这对所有的mysql版本都一样，也不会对SQL模式所影响。</p>\n<h4 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h4><p>更多MYSQL字符和校对的信息，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/charset.html\" target=\"_blank\" rel=\"external\">Section 11.1, “Character Set Support”</a>。关于存储需要的额外信息，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/storage-requirements.html\" target=\"_blank\" rel=\"external\">Section 12.8, “Data Type Storage Requirements”</a>。</p>\n<p>那些尾部补足字符除去或者忽略比较的情况，如果一个列有一个唯一索引，只有在尾部有补足字符时不同，报重复键错误。比如，一个表包含’a’，当试图存储’a ‘会引起一个重复键错误。(<strong>注释：唯一索引会忽略尾部空格</strong>)</p>\n","site":{"data":{}},"excerpt":"<p>翻译官方文档：</p>\n<ul>\n<li><a href=\"https://dev.mysql.com/doc/refman/5.7/en/char.html\" target=\"_blank\" rel=\"external\">https://dev.mysql.com/doc/refman/5.7/en/char.html</a></li>\n</ul>","more":"<p>char和varchar类型比较相似，但是在存储和取出有区别，在最大长度和是否在尾部保留空格也有区别。</p>\n<p>char和varchar都有一个长度声明，定义了你想存储的最大字符数。比如，char(30)可以存储最多30个字符。</p>\n<p>当创建表时，char列的长度会一直补足到你所声明的长度。长度可以从0到255。当存储char类型值时，会在右边补足空格直到指定长度。当取出char类型值时，尾部空格将会被移除，除非<a href=\"https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_pad_char_to_full_length\" target=\"_blank\" rel=\"external\">PAD_CHAR_TO_FULL_LENGTH</a>sql模式被启用。</p>\n<p>varchar列中的值是可变长的字符串。长度可以指定从0到65535。一个varchar的有效最大长度取决于最大行大小(65535字节，在各个列之间取)和所设置的字符。可以查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html\" target=\"_blank\" rel=\"external\">Section C.10.4, “Limits on Table Column Count and Row Size”</a>。</p>\n<p>相比于char，varchar会在数据值前缀增加1字节或者2字节长度。这个前缀的长度定义了值的字节数。如果值没有超过255字节，那么用1个字节存储长度；超过了则用2字节。</p>\n<p>如果没有启用严格SQL模式，而你赋值给一个char或者varchar列超过了列的最大长度，那么这个值会被截取，然后生成一个警告。启用严格SQL模式后，然后产生一个错误，并且值不会被插入。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html\" target=\"_blank\" rel=\"external\">Section 6.1.8, “Server SQL Modes”</a>。</p>\n<p>对于varchar类型列，超过列长的尾部空格会在插入前删除，然后产生一个警告，和当前所使用的SQL模式无关。对于char类型列，超过的空格会被默默的从插入的值中截取，也和当前所使用的SQL模式无关。</p>\n<p>当存储varchar时，值不会被补充。尾部空格会被保留当存储和取出时，这符合标准SQL。</p>\n<p>以下图表说明了char和varchar存储字符串的区别，char(4)和varchar(4)列（假设列用单字节字符串存储，比如latin1）。</p>\n<table>\n<thead>\n<tr>\n<th>Value</th>\n<th>CHAR(4)</th>\n<th>Storage Required</th>\n<th>VARCHAR(4)</th>\n<th>Storage Required</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>‘’</td>\n<td>‘    ‘</td>\n<td>4 bytes</td>\n<td>‘’</td>\n<td>1 byte</td>\n</tr>\n<tr>\n<td>‘ab’</td>\n<td>‘ab  ‘</td>\n<td>4 bytes</td>\n<td>‘ab’</td>\n<td>3 bytes</td>\n</tr>\n<tr>\n<td>‘abcd’</td>\n<td>‘abcd’</td>\n<td>4 bytes</td>\n<td>‘abcd’</td>\n<td>5 bytes</td>\n</tr>\n<tr>\n<td>‘abcdefgh’</td>\n<td>‘abcd’</td>\n<td>4 bytes</td>\n<td>‘abcd’</td>\n<td>5 bytes</td>\n</tr>\n</tbody>\n</table>\n<p>上面表中最后一行，只有在严格SQL模式下才会出现。如果是非严格SQL模式，超过长度的值不会被存储，并且报错。</p>\n<p>对于 InnoDB的 COMPACT, DYNAMIC 和COMPRESSED 行格式，如果列值长度大于等于768字节，char被当作可变长度对待，当是utf8mb4时，如果最大字节长度设置为超过3也会发生。例如，当被当作可变长度类型时，一个char列的值可能被选为off-page存储。查看更多信息，<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html\" target=\"_blank\" rel=\"external\">Section 15.11, “InnoDB Row Storage and Row Formats”</a>。</p>\n<p>如果值存入char(4)和varchar(4)列，从列中取出不会总是一样的，因为尾部空格会从char列中移除，并且无法复原。以下例子说明了这个差异：</p>\n<pre><code>mysql&gt; CREATE TABLE vc (v VARCHAR(4), c CHAR(4));\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; INSERT INTO vc VALUES (&apos;ab  &apos;, &apos;ab  &apos;);\nQuery OK, 1 row affected (0.00 sec)\n\nmysql&gt; SELECT CONCAT(&apos;(&apos;, v, &apos;)&apos;), CONCAT(&apos;(&apos;, c, &apos;)&apos;) FROM vc;\n+---------------------+---------------------+\n| CONCAT(&apos;(&apos;, v, &apos;)&apos;) | CONCAT(&apos;(&apos;, c, &apos;)&apos;) |\n+---------------------+---------------------+\n| (ab  )              | (ab)                |\n+---------------------+---------------------+\n1 row in set (0.06 sec)\n</code></pre><p>char和varchar列的值会被排序和比较根据赋值给这个值的字符校对。</p>\n<p>所有的mysql校对都是PADSPACE类型。这意味着所有的char,varchar和text值在被比较的时候，不会去考虑尾部空格。在这里说的比较不包含like模式匹配操作，like中尾部空格是很重要的。例如：</p>\n<pre><code>mysql&gt; CREATE TABLE names (myname CHAR(10));\nQuery OK, 0 rows affected (0.03 sec)\n\nmysql&gt; INSERT INTO names VALUES (&apos;Monty&apos;);\nQuery OK, 1 row affected (0.00 sec)\n\nmysql&gt; SELECT myname = &apos;Monty&apos;, myname = &apos;Monty  &apos; FROM names;\n+------------------+--------------------+\n| myname = &apos;Monty&apos; | myname = &apos;Monty  &apos; |\n+------------------+--------------------+\n|                1 |                  1 |\n+------------------+--------------------+\n1 row in set (0.00 sec)\n\nmysql&gt; SELECT myname LIKE &apos;Monty&apos;, myname LIKE &apos;Monty  &apos; FROM names;\n+---------------------+-----------------------+\n| myname LIKE &apos;Monty&apos; | myname LIKE &apos;Monty  &apos; |\n+---------------------+-----------------------+\n|                   1 |                     0 |\n+---------------------+-----------------------+\n1 row in set (0.00 sec)\n</code></pre><p>这对所有的mysql版本都一样，也不会对SQL模式所影响。</p>\n<h4 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h4><p>更多MYSQL字符和校对的信息，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/charset.html\" target=\"_blank\" rel=\"external\">Section 11.1, “Character Set Support”</a>。关于存储需要的额外信息，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/storage-requirements.html\" target=\"_blank\" rel=\"external\">Section 12.8, “Data Type Storage Requirements”</a>。</p>\n<p>那些尾部补足字符除去或者忽略比较的情况，如果一个列有一个唯一索引，只有在尾部有补足字符时不同，报重复键错误。比如，一个表包含’a’，当试图存储’a ‘会引起一个重复键错误。(<strong>注释：唯一索引会忽略尾部空格</strong>)</p>"},{"title":"mysqlnd驱动","date":"2017-02-15T09:08:54.000Z","_content":"* 了解下mysqlnd驱动\n* 翻译的是官方文档http://php.net/manual/zh/mysqlnd.overview.php\n\n<!--more-->\n\nphp5.3以前，默认使用的都是libmysqlclient(MySQL client server library)，5.3之后，mysqlnd(mysql native driver)已经内置于php源代码中，并且官方强烈建议使用这个驱动。虽然它是作为php扩展被编写，但是需要注意的是，它不提供新API给php程序员。连接mysql的API是由mysql扩展，由mysqli和PDO MYSQL提供。这些扩展现在可以用mysqlnd与mysql server通信。因此，你不应该认为mysqlnd是一个API。\n\nmysqlnd比MySQL Client Library多几个优点\n\n旧的MySQL Client Library是由MySQL AB（现在是oracle组织）写的，所以是在mysql许可证下发行的。这最终导致mysql支持在php中默认被禁用。但是，mysqlnd已经作为php项目的一部分被开发，是在php许可证下发行，这消除了过去存在的许可问题。\n\n同时，在过去，你需要根据libmysqlclient的副本构建mysql数据库扩展。意味着，你在安装php的机器上需要安装mysql。并且，PHP应用运行时，mysql的扩展会调用libmysqlclient文件，所以该文件需要在你的系统上被安装。而用mysqlnd将不会有这种情况，因为它是作为标准分发的一部分了。所以你不需要安装一个mysql来构建php或者运行php数据库应用。\n\n因为mysqlnd作为php扩展被编写，所以它能够和php工作紧密结合。这在效率上会有收益，特别是来自内存的使用，作为驱动在php内存管理系统中使用。它同样支持php内存限制。使用mysqlnd比libmysqlclient有更好的性能，它总是保证最有效的使用内存。一个例子是，当用MySQL Client Library，每一行都会在内存中存储两次，而用mysqlnd只存储一次。\n\n\t注意：内存使用\n\t因为mysqlnd用的是php的内存管理系统，它的内存使用会被 memory_get_usage()函数追踪到。而这对libmysqlclient来说是不可能的，因为它用的是c函数malloc().\n\n## 特殊功能\nmysqlnd提供一些MySQL Client Library没有的特殊功能：\n\n* 改进了持久连接\n* 特殊方法mysqli_fetch_all()\n* 性能统计调用： mysqli_get_cache_stats(), mysqli_get_client_stats(), mysqli_get_connection_stats()\n\n性能统计工具在识别性能瓶颈上被证明非常有用。\n当用mysqli扩展时，mysqlnd同样提供持久连接。\n\n## ssl支持\n从php5.3.3开始，mysqlnd意境支持ssl\n\n## 压缩协议支持\nphp5.3.2 mysqlnd支持压缩的客户端服务协议。在5.3.0和5.3.1中还不支持。扩展比如ext/mysql,ext/mysqli用mysqlnd，同样可以利用此功能。注意pdo_mysql不支持压缩当和mysqlnd一起用时。\n\n## 命名管道支持\nwindows的命名管道支持在php5.4.0被增加","source":"_posts/2017-02-15-mysqlnd.md","raw":"---\ntitle: mysqlnd驱动\ndate: 2017-02-15 17:08:54\ntags: mysql php\ncategories: php\n---\n* 了解下mysqlnd驱动\n* 翻译的是官方文档http://php.net/manual/zh/mysqlnd.overview.php\n\n<!--more-->\n\nphp5.3以前，默认使用的都是libmysqlclient(MySQL client server library)，5.3之后，mysqlnd(mysql native driver)已经内置于php源代码中，并且官方强烈建议使用这个驱动。虽然它是作为php扩展被编写，但是需要注意的是，它不提供新API给php程序员。连接mysql的API是由mysql扩展，由mysqli和PDO MYSQL提供。这些扩展现在可以用mysqlnd与mysql server通信。因此，你不应该认为mysqlnd是一个API。\n\nmysqlnd比MySQL Client Library多几个优点\n\n旧的MySQL Client Library是由MySQL AB（现在是oracle组织）写的，所以是在mysql许可证下发行的。这最终导致mysql支持在php中默认被禁用。但是，mysqlnd已经作为php项目的一部分被开发，是在php许可证下发行，这消除了过去存在的许可问题。\n\n同时，在过去，你需要根据libmysqlclient的副本构建mysql数据库扩展。意味着，你在安装php的机器上需要安装mysql。并且，PHP应用运行时，mysql的扩展会调用libmysqlclient文件，所以该文件需要在你的系统上被安装。而用mysqlnd将不会有这种情况，因为它是作为标准分发的一部分了。所以你不需要安装一个mysql来构建php或者运行php数据库应用。\n\n因为mysqlnd作为php扩展被编写，所以它能够和php工作紧密结合。这在效率上会有收益，特别是来自内存的使用，作为驱动在php内存管理系统中使用。它同样支持php内存限制。使用mysqlnd比libmysqlclient有更好的性能，它总是保证最有效的使用内存。一个例子是，当用MySQL Client Library，每一行都会在内存中存储两次，而用mysqlnd只存储一次。\n\n\t注意：内存使用\n\t因为mysqlnd用的是php的内存管理系统，它的内存使用会被 memory_get_usage()函数追踪到。而这对libmysqlclient来说是不可能的，因为它用的是c函数malloc().\n\n## 特殊功能\nmysqlnd提供一些MySQL Client Library没有的特殊功能：\n\n* 改进了持久连接\n* 特殊方法mysqli_fetch_all()\n* 性能统计调用： mysqli_get_cache_stats(), mysqli_get_client_stats(), mysqli_get_connection_stats()\n\n性能统计工具在识别性能瓶颈上被证明非常有用。\n当用mysqli扩展时，mysqlnd同样提供持久连接。\n\n## ssl支持\n从php5.3.3开始，mysqlnd意境支持ssl\n\n## 压缩协议支持\nphp5.3.2 mysqlnd支持压缩的客户端服务协议。在5.3.0和5.3.1中还不支持。扩展比如ext/mysql,ext/mysqli用mysqlnd，同样可以利用此功能。注意pdo_mysql不支持压缩当和mysqlnd一起用时。\n\n## 命名管道支持\nwindows的命名管道支持在php5.4.0被增加","slug":"mysqlnd","published":1,"updated":"2017-09-18T11:36:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7q4uqzt000xkkje9maij0oq","content":"<ul>\n<li>了解下mysqlnd驱动</li>\n<li>翻译的是官方文档<a href=\"http://php.net/manual/zh/mysqlnd.overview.php\" target=\"_blank\" rel=\"external\">http://php.net/manual/zh/mysqlnd.overview.php</a></li>\n</ul>\n<a id=\"more\"></a>\n<p>php5.3以前，默认使用的都是libmysqlclient(MySQL client server library)，5.3之后，mysqlnd(mysql native driver)已经内置于php源代码中，并且官方强烈建议使用这个驱动。虽然它是作为php扩展被编写，但是需要注意的是，它不提供新API给php程序员。连接mysql的API是由mysql扩展，由mysqli和PDO MYSQL提供。这些扩展现在可以用mysqlnd与mysql server通信。因此，你不应该认为mysqlnd是一个API。</p>\n<p>mysqlnd比MySQL Client Library多几个优点</p>\n<p>旧的MySQL Client Library是由MySQL AB（现在是oracle组织）写的，所以是在mysql许可证下发行的。这最终导致mysql支持在php中默认被禁用。但是，mysqlnd已经作为php项目的一部分被开发，是在php许可证下发行，这消除了过去存在的许可问题。</p>\n<p>同时，在过去，你需要根据libmysqlclient的副本构建mysql数据库扩展。意味着，你在安装php的机器上需要安装mysql。并且，PHP应用运行时，mysql的扩展会调用libmysqlclient文件，所以该文件需要在你的系统上被安装。而用mysqlnd将不会有这种情况，因为它是作为标准分发的一部分了。所以你不需要安装一个mysql来构建php或者运行php数据库应用。</p>\n<p>因为mysqlnd作为php扩展被编写，所以它能够和php工作紧密结合。这在效率上会有收益，特别是来自内存的使用，作为驱动在php内存管理系统中使用。它同样支持php内存限制。使用mysqlnd比libmysqlclient有更好的性能，它总是保证最有效的使用内存。一个例子是，当用MySQL Client Library，每一行都会在内存中存储两次，而用mysqlnd只存储一次。</p>\n<pre><code>注意：内存使用\n因为mysqlnd用的是php的内存管理系统，它的内存使用会被 memory_get_usage()函数追踪到。而这对libmysqlclient来说是不可能的，因为它用的是c函数malloc().\n</code></pre><h2 id=\"特殊功能\"><a href=\"#特殊功能\" class=\"headerlink\" title=\"特殊功能\"></a>特殊功能</h2><p>mysqlnd提供一些MySQL Client Library没有的特殊功能：</p>\n<ul>\n<li>改进了持久连接</li>\n<li>特殊方法mysqli_fetch_all()</li>\n<li>性能统计调用： mysqli_get_cache_stats(), mysqli_get_client_stats(), mysqli_get_connection_stats()</li>\n</ul>\n<p>性能统计工具在识别性能瓶颈上被证明非常有用。<br>当用mysqli扩展时，mysqlnd同样提供持久连接。</p>\n<h2 id=\"ssl支持\"><a href=\"#ssl支持\" class=\"headerlink\" title=\"ssl支持\"></a>ssl支持</h2><p>从php5.3.3开始，mysqlnd意境支持ssl</p>\n<h2 id=\"压缩协议支持\"><a href=\"#压缩协议支持\" class=\"headerlink\" title=\"压缩协议支持\"></a>压缩协议支持</h2><p>php5.3.2 mysqlnd支持压缩的客户端服务协议。在5.3.0和5.3.1中还不支持。扩展比如ext/mysql,ext/mysqli用mysqlnd，同样可以利用此功能。注意pdo_mysql不支持压缩当和mysqlnd一起用时。</p>\n<h2 id=\"命名管道支持\"><a href=\"#命名管道支持\" class=\"headerlink\" title=\"命名管道支持\"></a>命名管道支持</h2><p>windows的命名管道支持在php5.4.0被增加</p>\n","site":{"data":{}},"excerpt":"<ul>\n<li>了解下mysqlnd驱动</li>\n<li>翻译的是官方文档<a href=\"http://php.net/manual/zh/mysqlnd.overview.php\" target=\"_blank\" rel=\"external\">http://php.net/manual/zh/mysqlnd.overview.php</a></li>\n</ul>","more":"<p>php5.3以前，默认使用的都是libmysqlclient(MySQL client server library)，5.3之后，mysqlnd(mysql native driver)已经内置于php源代码中，并且官方强烈建议使用这个驱动。虽然它是作为php扩展被编写，但是需要注意的是，它不提供新API给php程序员。连接mysql的API是由mysql扩展，由mysqli和PDO MYSQL提供。这些扩展现在可以用mysqlnd与mysql server通信。因此，你不应该认为mysqlnd是一个API。</p>\n<p>mysqlnd比MySQL Client Library多几个优点</p>\n<p>旧的MySQL Client Library是由MySQL AB（现在是oracle组织）写的，所以是在mysql许可证下发行的。这最终导致mysql支持在php中默认被禁用。但是，mysqlnd已经作为php项目的一部分被开发，是在php许可证下发行，这消除了过去存在的许可问题。</p>\n<p>同时，在过去，你需要根据libmysqlclient的副本构建mysql数据库扩展。意味着，你在安装php的机器上需要安装mysql。并且，PHP应用运行时，mysql的扩展会调用libmysqlclient文件，所以该文件需要在你的系统上被安装。而用mysqlnd将不会有这种情况，因为它是作为标准分发的一部分了。所以你不需要安装一个mysql来构建php或者运行php数据库应用。</p>\n<p>因为mysqlnd作为php扩展被编写，所以它能够和php工作紧密结合。这在效率上会有收益，特别是来自内存的使用，作为驱动在php内存管理系统中使用。它同样支持php内存限制。使用mysqlnd比libmysqlclient有更好的性能，它总是保证最有效的使用内存。一个例子是，当用MySQL Client Library，每一行都会在内存中存储两次，而用mysqlnd只存储一次。</p>\n<pre><code>注意：内存使用\n因为mysqlnd用的是php的内存管理系统，它的内存使用会被 memory_get_usage()函数追踪到。而这对libmysqlclient来说是不可能的，因为它用的是c函数malloc().\n</code></pre><h2 id=\"特殊功能\"><a href=\"#特殊功能\" class=\"headerlink\" title=\"特殊功能\"></a>特殊功能</h2><p>mysqlnd提供一些MySQL Client Library没有的特殊功能：</p>\n<ul>\n<li>改进了持久连接</li>\n<li>特殊方法mysqli_fetch_all()</li>\n<li>性能统计调用： mysqli_get_cache_stats(), mysqli_get_client_stats(), mysqli_get_connection_stats()</li>\n</ul>\n<p>性能统计工具在识别性能瓶颈上被证明非常有用。<br>当用mysqli扩展时，mysqlnd同样提供持久连接。</p>\n<h2 id=\"ssl支持\"><a href=\"#ssl支持\" class=\"headerlink\" title=\"ssl支持\"></a>ssl支持</h2><p>从php5.3.3开始，mysqlnd意境支持ssl</p>\n<h2 id=\"压缩协议支持\"><a href=\"#压缩协议支持\" class=\"headerlink\" title=\"压缩协议支持\"></a>压缩协议支持</h2><p>php5.3.2 mysqlnd支持压缩的客户端服务协议。在5.3.0和5.3.1中还不支持。扩展比如ext/mysql,ext/mysqli用mysqlnd，同样可以利用此功能。注意pdo_mysql不支持压缩当和mysqlnd一起用时。</p>\n<h2 id=\"命名管道支持\"><a href=\"#命名管道支持\" class=\"headerlink\" title=\"命名管道支持\"></a>命名管道支持</h2><p>windows的命名管道支持在php5.4.0被增加</p>"},{"title":"curl超时导致进程假死","date":"2017-05-27T07:32:26.000Z","_content":"\n其实主要是如何去查看进程相关的东西\n\n<!-- more -->\n\n很多时候的进程假死都是网络超时导致的，比如curl。\ncurl的底层库是libcurl，它有以下几个对时间控制的设置：\n\n```\n\tCURLOPT_FTP_RESPONSE_TIMEOUT: No default (indefinite)\n\tCURLOPT_TIMEOUT: No default (indefinite)\n\tCURLOPT_TIMEOUT_MS: No default (indefinite)\n\tCURLOPT_CONNECTTIMEOUT: Defaults to 300 seconds\n\tCURLOPT_CONNECTTIMEOUT_MS: No default\n\tCURLOPT_ACCEPTTIMEOUT_MS: Defaults to 60000 ms\n```\n其中 CURLOPT_ACCEPTTIMEOUT_MS是和ftp相关的，CURLOPT_CONNECTTIMEOUT是连接的超时设置。可以从https://curl.haxx.se/libcurl/c/curl_easy_setopt.html去查看相关参数。\n可以看出，默认情况下，curl是不会超时的，假如连上服务，curl会一直保持连接。\n对于php，可以从http://cn2.php.net/manual/zh/function.curl-setopt.php 查看。\n我们来模拟一下场景：\n在一台机器a上用nc开一个123的端口去等待连接\n{% asset_img 1.png %}\n然后在另一台机器b上用curl命令连接\n{% asset_img 2.png %}\n可以看到它会阻塞在那，此时用strace命令查看curl进程，看该进程到底在干啥\n{% asset_img 3.png %}\n发现curl一直在用poll并且超时。\n通常来说，我们查问题是从strace开始看的，所以找到该处，看到是poll，并且超时，而它打开的文件描述符fd是3，那么接下来用lsof查看该进程打开的所有fd\n{% asset_img 4.png %}\n找到fd是3的一行，图中是3u，看到是一个tcp连接，连接的对方ip正是机器a的ip。\n\ncurl能设置毫秒级别的超时吗？虽然curl提供了相关ms参数设置，但实际上却是还有问题，具体参考鸟哥的这篇文章http://www.laruence.com/2014/01/21/2939.html\nphp官方文档也对CURLOPT_TIMEOUT_MS给出了说明：\n>设置cURL允许执行的最长毫秒数。 如果 libcurl 编译时使用系统标准的名称解析器（ standard system name resolver），那部分的连接仍旧使用以秒计的超时解决方案，最小超时时间还是一秒钟。\n\n还是在机器a上起123端口，然后机器b上用php去测试\n\n```php\n<?php\n\nfunction test($url)\n{        \n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_USERAGENT, \"Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0)\");\n        curl_setopt($ch, CURLOPT_TIMEOUT_MS, 10);\n        $result = curl_exec($ch);\n        var_dump(curl_error($ch));\n        curl_close($ch);\n        return $result;\n}        \n\n$url = 'http://x.x.x.x:123';\n$start = gettimeofday(true);\n$l = test($url);\nvar_dump($l);\n$time = gettimeofday(true) - $start;\nvar_dump($time);\n```\n\n执行返回：Timeout was reached，并且在a上没接收到任何请求\n一种是设置CURLOPT_NOSIGNAL\n\n```\ncurl_setopt($ch, CURLOPT_NOSIGNAL, 1);\n```\n\n此时再执行，会发现a上确实接收到请求了，但是curl超时最小1秒，这和官网上说的一致，也就是设置毫秒无效。\n\n另外一种是启动libcurl的c-ares，这是异步dns解析，一般linux机器上安装curl都不会启动该功能，可以在自己机器上用curl --version查看下是否有c-ares标志，如需启用需要下载相关安装包，并且重新编译libcurl，可以参考https://www.haiyun.me/archives/1068.html\n\n参考资料：\n>https://stackoverflow.com/questions/10308915/php-default-curl-timeout-value","source":"_posts/2017-05-27-curl.md","raw":"---\ntitle: curl超时导致进程假死\ndate: 2017-05-27 15:32:26\ntags:\n- linux\n- php\ncategories: linux\n---\n\n其实主要是如何去查看进程相关的东西\n\n<!-- more -->\n\n很多时候的进程假死都是网络超时导致的，比如curl。\ncurl的底层库是libcurl，它有以下几个对时间控制的设置：\n\n```\n\tCURLOPT_FTP_RESPONSE_TIMEOUT: No default (indefinite)\n\tCURLOPT_TIMEOUT: No default (indefinite)\n\tCURLOPT_TIMEOUT_MS: No default (indefinite)\n\tCURLOPT_CONNECTTIMEOUT: Defaults to 300 seconds\n\tCURLOPT_CONNECTTIMEOUT_MS: No default\n\tCURLOPT_ACCEPTTIMEOUT_MS: Defaults to 60000 ms\n```\n其中 CURLOPT_ACCEPTTIMEOUT_MS是和ftp相关的，CURLOPT_CONNECTTIMEOUT是连接的超时设置。可以从https://curl.haxx.se/libcurl/c/curl_easy_setopt.html去查看相关参数。\n可以看出，默认情况下，curl是不会超时的，假如连上服务，curl会一直保持连接。\n对于php，可以从http://cn2.php.net/manual/zh/function.curl-setopt.php 查看。\n我们来模拟一下场景：\n在一台机器a上用nc开一个123的端口去等待连接\n{% asset_img 1.png %}\n然后在另一台机器b上用curl命令连接\n{% asset_img 2.png %}\n可以看到它会阻塞在那，此时用strace命令查看curl进程，看该进程到底在干啥\n{% asset_img 3.png %}\n发现curl一直在用poll并且超时。\n通常来说，我们查问题是从strace开始看的，所以找到该处，看到是poll，并且超时，而它打开的文件描述符fd是3，那么接下来用lsof查看该进程打开的所有fd\n{% asset_img 4.png %}\n找到fd是3的一行，图中是3u，看到是一个tcp连接，连接的对方ip正是机器a的ip。\n\ncurl能设置毫秒级别的超时吗？虽然curl提供了相关ms参数设置，但实际上却是还有问题，具体参考鸟哥的这篇文章http://www.laruence.com/2014/01/21/2939.html\nphp官方文档也对CURLOPT_TIMEOUT_MS给出了说明：\n>设置cURL允许执行的最长毫秒数。 如果 libcurl 编译时使用系统标准的名称解析器（ standard system name resolver），那部分的连接仍旧使用以秒计的超时解决方案，最小超时时间还是一秒钟。\n\n还是在机器a上起123端口，然后机器b上用php去测试\n\n```php\n<?php\n\nfunction test($url)\n{        \n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, true);\n        curl_setopt($ch, CURLOPT_USERAGENT, \"Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0)\");\n        curl_setopt($ch, CURLOPT_TIMEOUT_MS, 10);\n        $result = curl_exec($ch);\n        var_dump(curl_error($ch));\n        curl_close($ch);\n        return $result;\n}        \n\n$url = 'http://x.x.x.x:123';\n$start = gettimeofday(true);\n$l = test($url);\nvar_dump($l);\n$time = gettimeofday(true) - $start;\nvar_dump($time);\n```\n\n执行返回：Timeout was reached，并且在a上没接收到任何请求\n一种是设置CURLOPT_NOSIGNAL\n\n```\ncurl_setopt($ch, CURLOPT_NOSIGNAL, 1);\n```\n\n此时再执行，会发现a上确实接收到请求了，但是curl超时最小1秒，这和官网上说的一致，也就是设置毫秒无效。\n\n另外一种是启动libcurl的c-ares，这是异步dns解析，一般linux机器上安装curl都不会启动该功能，可以在自己机器上用curl --version查看下是否有c-ares标志，如需启用需要下载相关安装包，并且重新编译libcurl，可以参考https://www.haiyun.me/archives/1068.html\n\n参考资料：\n>https://stackoverflow.com/questions/10308915/php-default-curl-timeout-value","slug":"curl","published":1,"updated":"2017-09-18T11:36:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7q4uqzu0010kkjedxxmo3mk","content":"<p>其实主要是如何去查看进程相关的东西</p>\n<a id=\"more\"></a>\n<p>很多时候的进程假死都是网络超时导致的，比如curl。<br>curl的底层库是libcurl，它有以下几个对时间控制的设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">CURLOPT_FTP_RESPONSE_TIMEOUT: No default (indefinite)</div><div class=\"line\">CURLOPT_TIMEOUT: No default (indefinite)</div><div class=\"line\">CURLOPT_TIMEOUT_MS: No default (indefinite)</div><div class=\"line\">CURLOPT_CONNECTTIMEOUT: Defaults to 300 seconds</div><div class=\"line\">CURLOPT_CONNECTTIMEOUT_MS: No default</div><div class=\"line\">CURLOPT_ACCEPTTIMEOUT_MS: Defaults to 60000 ms</div></pre></td></tr></table></figure>\n<p>其中 CURLOPT_ACCEPTTIMEOUT_MS是和ftp相关的，CURLOPT_CONNECTTIMEOUT是连接的超时设置。可以从<a href=\"https://curl.haxx.se/libcurl/c/curl_easy_setopt.html去查看相关参数。\" target=\"_blank\" rel=\"external\">https://curl.haxx.se/libcurl/c/curl_easy_setopt.html去查看相关参数。</a><br>可以看出，默认情况下，curl是不会超时的，假如连上服务，curl会一直保持连接。<br>对于php，可以从<a href=\"http://cn2.php.net/manual/zh/function.curl-setopt.php\" target=\"_blank\" rel=\"external\">http://cn2.php.net/manual/zh/function.curl-setopt.php</a> 查看。<br>我们来模拟一下场景：<br>在一台机器a上用nc开一个123的端口去等待连接<br><img src=\"/2017/05/27/curl/1.png\" alt=\"1.png\" title=\"\"><br>然后在另一台机器b上用curl命令连接<br><img src=\"/2017/05/27/curl/2.png\" alt=\"2.png\" title=\"\"><br>可以看到它会阻塞在那，此时用strace命令查看curl进程，看该进程到底在干啥<br><img src=\"/2017/05/27/curl/3.png\" alt=\"3.png\" title=\"\"><br>发现curl一直在用poll并且超时。<br>通常来说，我们查问题是从strace开始看的，所以找到该处，看到是poll，并且超时，而它打开的文件描述符fd是3，那么接下来用lsof查看该进程打开的所有fd<br><img src=\"/2017/05/27/curl/4.png\" alt=\"4.png\" title=\"\"><br>找到fd是3的一行，图中是3u，看到是一个tcp连接，连接的对方ip正是机器a的ip。</p>\n<p>curl能设置毫秒级别的超时吗？虽然curl提供了相关ms参数设置，但实际上却是还有问题，具体参考鸟哥的这篇文章<a href=\"http://www.laruence.com/2014/01/21/2939.html\" target=\"_blank\" rel=\"external\">http://www.laruence.com/2014/01/21/2939.html</a><br>php官方文档也对CURLOPT_TIMEOUT_MS给出了说明：</p>\n<blockquote>\n<p>设置cURL允许执行的最长毫秒数。 如果 libcurl 编译时使用系统标准的名称解析器（ standard system name resolver），那部分的连接仍旧使用以秒计的超时解决方案，最小超时时间还是一秒钟。</p>\n</blockquote>\n<p>还是在机器a上起123端口，然后机器b上用php去测试</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span><span class=\"params\">($url)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;        </div><div class=\"line\">        $ch = curl_init();</div><div class=\"line\">        curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class=\"number\">1</span>);</div><div class=\"line\">        curl_setopt($ch, CURLOPT_URL, $url);</div><div class=\"line\">        curl_setopt($ch, CURLOPT_HEADER, <span class=\"keyword\">true</span>);</div><div class=\"line\">        curl_setopt($ch, CURLOPT_USERAGENT, <span class=\"string\">\"Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0)\"</span>);</div><div class=\"line\">        curl_setopt($ch, CURLOPT_TIMEOUT_MS, <span class=\"number\">10</span>);</div><div class=\"line\">        $result = curl_exec($ch);</div><div class=\"line\">        var_dump(curl_error($ch));</div><div class=\"line\">        curl_close($ch);</div><div class=\"line\">        <span class=\"keyword\">return</span> $result;</div><div class=\"line\">&#125;        </div><div class=\"line\"></div><div class=\"line\">$url = <span class=\"string\">'http://x.x.x.x:123'</span>;</div><div class=\"line\">$start = gettimeofday(<span class=\"keyword\">true</span>);</div><div class=\"line\">$l = test($url);</div><div class=\"line\">var_dump($l);</div><div class=\"line\">$time = gettimeofday(<span class=\"keyword\">true</span>) - $start;</div><div class=\"line\">var_dump($time);</div></pre></td></tr></table></figure>\n<p>执行返回：Timeout was reached，并且在a上没接收到任何请求<br>一种是设置CURLOPT_NOSIGNAL</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl_setopt($ch, CURLOPT_NOSIGNAL, 1);</div></pre></td></tr></table></figure>\n<p>此时再执行，会发现a上确实接收到请求了，但是curl超时最小1秒，这和官网上说的一致，也就是设置毫秒无效。</p>\n<p>另外一种是启动libcurl的c-ares，这是异步dns解析，一般linux机器上安装curl都不会启动该功能，可以在自己机器上用curl –version查看下是否有c-ares标志，如需启用需要下载相关安装包，并且重新编译libcurl，可以参考<a href=\"https://www.haiyun.me/archives/1068.html\" target=\"_blank\" rel=\"external\">https://www.haiyun.me/archives/1068.html</a></p>\n<p>参考资料：</p>\n<blockquote>\n<p><a href=\"https://stackoverflow.com/questions/10308915/php-default-curl-timeout-value\" target=\"_blank\" rel=\"external\">https://stackoverflow.com/questions/10308915/php-default-curl-timeout-value</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>其实主要是如何去查看进程相关的东西</p>","more":"<p>很多时候的进程假死都是网络超时导致的，比如curl。<br>curl的底层库是libcurl，它有以下几个对时间控制的设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">CURLOPT_FTP_RESPONSE_TIMEOUT: No default (indefinite)</div><div class=\"line\">CURLOPT_TIMEOUT: No default (indefinite)</div><div class=\"line\">CURLOPT_TIMEOUT_MS: No default (indefinite)</div><div class=\"line\">CURLOPT_CONNECTTIMEOUT: Defaults to 300 seconds</div><div class=\"line\">CURLOPT_CONNECTTIMEOUT_MS: No default</div><div class=\"line\">CURLOPT_ACCEPTTIMEOUT_MS: Defaults to 60000 ms</div></pre></td></tr></table></figure>\n<p>其中 CURLOPT_ACCEPTTIMEOUT_MS是和ftp相关的，CURLOPT_CONNECTTIMEOUT是连接的超时设置。可以从<a href=\"https://curl.haxx.se/libcurl/c/curl_easy_setopt.html去查看相关参数。\" target=\"_blank\" rel=\"external\">https://curl.haxx.se/libcurl/c/curl_easy_setopt.html去查看相关参数。</a><br>可以看出，默认情况下，curl是不会超时的，假如连上服务，curl会一直保持连接。<br>对于php，可以从<a href=\"http://cn2.php.net/manual/zh/function.curl-setopt.php\" target=\"_blank\" rel=\"external\">http://cn2.php.net/manual/zh/function.curl-setopt.php</a> 查看。<br>我们来模拟一下场景：<br>在一台机器a上用nc开一个123的端口去等待连接<br><img src=\"/2017/05/27/curl/1.png\" alt=\"1.png\" title=\"\"><br>然后在另一台机器b上用curl命令连接<br><img src=\"/2017/05/27/curl/2.png\" alt=\"2.png\" title=\"\"><br>可以看到它会阻塞在那，此时用strace命令查看curl进程，看该进程到底在干啥<br><img src=\"/2017/05/27/curl/3.png\" alt=\"3.png\" title=\"\"><br>发现curl一直在用poll并且超时。<br>通常来说，我们查问题是从strace开始看的，所以找到该处，看到是poll，并且超时，而它打开的文件描述符fd是3，那么接下来用lsof查看该进程打开的所有fd<br><img src=\"/2017/05/27/curl/4.png\" alt=\"4.png\" title=\"\"><br>找到fd是3的一行，图中是3u，看到是一个tcp连接，连接的对方ip正是机器a的ip。</p>\n<p>curl能设置毫秒级别的超时吗？虽然curl提供了相关ms参数设置，但实际上却是还有问题，具体参考鸟哥的这篇文章<a href=\"http://www.laruence.com/2014/01/21/2939.html\" target=\"_blank\" rel=\"external\">http://www.laruence.com/2014/01/21/2939.html</a><br>php官方文档也对CURLOPT_TIMEOUT_MS给出了说明：</p>\n<blockquote>\n<p>设置cURL允许执行的最长毫秒数。 如果 libcurl 编译时使用系统标准的名称解析器（ standard system name resolver），那部分的连接仍旧使用以秒计的超时解决方案，最小超时时间还是一秒钟。</p>\n</blockquote>\n<p>还是在机器a上起123端口，然后机器b上用php去测试</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span><span class=\"params\">($url)</span></span></div><div class=\"line\"><span class=\"function\"></span>&#123;        </div><div class=\"line\">        $ch = curl_init();</div><div class=\"line\">        curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class=\"number\">1</span>);</div><div class=\"line\">        curl_setopt($ch, CURLOPT_URL, $url);</div><div class=\"line\">        curl_setopt($ch, CURLOPT_HEADER, <span class=\"keyword\">true</span>);</div><div class=\"line\">        curl_setopt($ch, CURLOPT_USERAGENT, <span class=\"string\">\"Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0)\"</span>);</div><div class=\"line\">        curl_setopt($ch, CURLOPT_TIMEOUT_MS, <span class=\"number\">10</span>);</div><div class=\"line\">        $result = curl_exec($ch);</div><div class=\"line\">        var_dump(curl_error($ch));</div><div class=\"line\">        curl_close($ch);</div><div class=\"line\">        <span class=\"keyword\">return</span> $result;</div><div class=\"line\">&#125;        </div><div class=\"line\"></div><div class=\"line\">$url = <span class=\"string\">'http://x.x.x.x:123'</span>;</div><div class=\"line\">$start = gettimeofday(<span class=\"keyword\">true</span>);</div><div class=\"line\">$l = test($url);</div><div class=\"line\">var_dump($l);</div><div class=\"line\">$time = gettimeofday(<span class=\"keyword\">true</span>) - $start;</div><div class=\"line\">var_dump($time);</div></pre></td></tr></table></figure>\n<p>执行返回：Timeout was reached，并且在a上没接收到任何请求<br>一种是设置CURLOPT_NOSIGNAL</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl_setopt($ch, CURLOPT_NOSIGNAL, 1);</div></pre></td></tr></table></figure>\n<p>此时再执行，会发现a上确实接收到请求了，但是curl超时最小1秒，这和官网上说的一致，也就是设置毫秒无效。</p>\n<p>另外一种是启动libcurl的c-ares，这是异步dns解析，一般linux机器上安装curl都不会启动该功能，可以在自己机器上用curl –version查看下是否有c-ares标志，如需启用需要下载相关安装包，并且重新编译libcurl，可以参考<a href=\"https://www.haiyun.me/archives/1068.html\" target=\"_blank\" rel=\"external\">https://www.haiyun.me/archives/1068.html</a></p>\n<p>参考资料：</p>\n<blockquote>\n<p><a href=\"https://stackoverflow.com/questions/10308915/php-default-curl-timeout-value\" target=\"_blank\" rel=\"external\">https://stackoverflow.com/questions/10308915/php-default-curl-timeout-value</a></p>\n</blockquote>"},{"title":"php的文件锁flock总结","date":"2017-05-03T07:31:13.000Z","_content":"\n* 先从应用方面，之后会从操作系统方面深入理解\n\n<!-- more -->\n\n如果两个进程同时写一个文件，那么两个进程写的内容势必会乱掉，那么如何保证内容不乱呢，加锁。\nPHP加锁的函数为[flock](http://cn2.php.net/manual/zh/function.flock.php)，该函数有3个参数：\n  1. 文件指针；\n  2. 锁类型，LOCK_SH共享锁，LOCK_EX独占锁，LOCK_UN释放锁。加上LOCK_NB将不会阻塞，而是立即返回。比如LOCK_SH|LOCK_NB；\n  3. wouldblock，是个引用变量，一般不会用到，可以传入一个变量，然后打印该变量看函数赋的是什么值；\n\nLOCK_SH共享锁，用在读取程序上；\nLOCK_EX独占锁，用在写入程序上；\n\n### 读取文件\n1. 如果在lock1.php读取一个文件时（未加锁），lock2.php往里面写（没有加锁），那么lock1.php有可能读取脏数据，即读到lock2.php写入的数据；\n2. 在lock1.php读取一个文件时（加了LOCK_SH锁），lock2.php往里面写（没有加锁），那么lock1.php还是会读取脏数据，即读到lock2.php写入的数据；\n* lock1.php:\n```php\n<?php\n\n$f = fopen('test.txt', 'r');\n\nif ( flock($f, LOCK_SH) ) { \n    while (!feof($f)) {\n        $contents = fread($f, 1); \n        echo $contents.chr(10);\n        usleep(100000);\n    }   \n    flock($f, LOCK_UN);\n} else {\n    echo 'no';\n}\nfclose($f);\n```\n* lock2.php:\n```php\n<?php\n\n$f = fopen('test.txt', 'a+');\n$re = fwrite($f, 'ok');\nvar_dump($re);\nfclose($f);\n```\n 3.如果在lock1.php读取一个文件时（加了LOCK_SH锁），lock2.php往里面写（加上LOCK_EX锁），那么lock2.php会阻塞直到lock1.php读取完毕后再写入\n* lock1.php\n```php\n<?php\n\n$f = fopen('test.txt', 'r');\n\nif (flock($f, LOCK_SH)) {\n    while (!feof($f)) {\n        $contents = fread($f, 2);\n        echo $contents.chr(10);\n        usleep(10000);\n    }\n} else {\n    echo 'no lock'.chr(10);\n}\nfclose($f);\n```\n* lock2.php\n```php\n<?php\n\n$f = fopen('test.txt', 'a+');\n\nif ( flock($f, LOCK_EX) ) { \n//if ( flock($f, LOCK_EX|LOCK_NB) ) { 不会阻塞，立即返回\n    fwrite($f, 'ok');\n    flock($f, LOCK_UN);\n} else {\n    echo 'no';\n}\nfclose($f);\n```\n\n### 写入文件\n1. 如果lock1.php写一个文件时（未加锁），lock2.php读取该文件（未加锁），那么lock2.php会读到脏数据\n2. 如果lock1.php写一个文件时（加上LOCK_EX锁），lock2.php读取该文件（未加锁），那么lock2.php还是会读到脏数据\n3. 如果lock1.php写一个文件时（加上LOCK_EX锁）, lock2.php读取该文件（加了LOCK_SH锁），那么lock2.php会等待lock1.php写完并且释放锁后读取。\n* lock1.php\n```php\n<?php\n\n$f = fopen('test.txt', 'a+');\n\nif (flock($f, LOCK_EX)) {\nfor ($i = 0; $i<1000; $i++) {\n    fwrite($f, $i.chr(10));\n    sleep(1);\n}\n}\nfclose($f);\n```\n* lock2.php\n```php\n<?php\n\n$f = fopen('test.txt', 'r');\n\nif (flock($f, LOCK_SH|LOCK_NB)) {\nwhile (!feof($f)) {\n    $re = fread($f, 2);\n    echo $re.chr(10);\n    usleep(1000);\n}\n} else {\n    echo 'file locked'.chr(10);\n}\n```\n\n如果多个进程同时写文件，为了避免错乱，那么每个进程都需要用flock来尝试获取锁，用LOCK_EX排它锁。\n\n\n\n\n","source":"_posts/2017-05-03-flock.md","raw":"---\ntitle: php的文件锁flock总结\ndate: 2017-05-03 15:31:13\ntags: php\ncategories: php\n---\n\n* 先从应用方面，之后会从操作系统方面深入理解\n\n<!-- more -->\n\n如果两个进程同时写一个文件，那么两个进程写的内容势必会乱掉，那么如何保证内容不乱呢，加锁。\nPHP加锁的函数为[flock](http://cn2.php.net/manual/zh/function.flock.php)，该函数有3个参数：\n  1. 文件指针；\n  2. 锁类型，LOCK_SH共享锁，LOCK_EX独占锁，LOCK_UN释放锁。加上LOCK_NB将不会阻塞，而是立即返回。比如LOCK_SH|LOCK_NB；\n  3. wouldblock，是个引用变量，一般不会用到，可以传入一个变量，然后打印该变量看函数赋的是什么值；\n\nLOCK_SH共享锁，用在读取程序上；\nLOCK_EX独占锁，用在写入程序上；\n\n### 读取文件\n1. 如果在lock1.php读取一个文件时（未加锁），lock2.php往里面写（没有加锁），那么lock1.php有可能读取脏数据，即读到lock2.php写入的数据；\n2. 在lock1.php读取一个文件时（加了LOCK_SH锁），lock2.php往里面写（没有加锁），那么lock1.php还是会读取脏数据，即读到lock2.php写入的数据；\n* lock1.php:\n```php\n<?php\n\n$f = fopen('test.txt', 'r');\n\nif ( flock($f, LOCK_SH) ) { \n    while (!feof($f)) {\n        $contents = fread($f, 1); \n        echo $contents.chr(10);\n        usleep(100000);\n    }   \n    flock($f, LOCK_UN);\n} else {\n    echo 'no';\n}\nfclose($f);\n```\n* lock2.php:\n```php\n<?php\n\n$f = fopen('test.txt', 'a+');\n$re = fwrite($f, 'ok');\nvar_dump($re);\nfclose($f);\n```\n 3.如果在lock1.php读取一个文件时（加了LOCK_SH锁），lock2.php往里面写（加上LOCK_EX锁），那么lock2.php会阻塞直到lock1.php读取完毕后再写入\n* lock1.php\n```php\n<?php\n\n$f = fopen('test.txt', 'r');\n\nif (flock($f, LOCK_SH)) {\n    while (!feof($f)) {\n        $contents = fread($f, 2);\n        echo $contents.chr(10);\n        usleep(10000);\n    }\n} else {\n    echo 'no lock'.chr(10);\n}\nfclose($f);\n```\n* lock2.php\n```php\n<?php\n\n$f = fopen('test.txt', 'a+');\n\nif ( flock($f, LOCK_EX) ) { \n//if ( flock($f, LOCK_EX|LOCK_NB) ) { 不会阻塞，立即返回\n    fwrite($f, 'ok');\n    flock($f, LOCK_UN);\n} else {\n    echo 'no';\n}\nfclose($f);\n```\n\n### 写入文件\n1. 如果lock1.php写一个文件时（未加锁），lock2.php读取该文件（未加锁），那么lock2.php会读到脏数据\n2. 如果lock1.php写一个文件时（加上LOCK_EX锁），lock2.php读取该文件（未加锁），那么lock2.php还是会读到脏数据\n3. 如果lock1.php写一个文件时（加上LOCK_EX锁）, lock2.php读取该文件（加了LOCK_SH锁），那么lock2.php会等待lock1.php写完并且释放锁后读取。\n* lock1.php\n```php\n<?php\n\n$f = fopen('test.txt', 'a+');\n\nif (flock($f, LOCK_EX)) {\nfor ($i = 0; $i<1000; $i++) {\n    fwrite($f, $i.chr(10));\n    sleep(1);\n}\n}\nfclose($f);\n```\n* lock2.php\n```php\n<?php\n\n$f = fopen('test.txt', 'r');\n\nif (flock($f, LOCK_SH|LOCK_NB)) {\nwhile (!feof($f)) {\n    $re = fread($f, 2);\n    echo $re.chr(10);\n    usleep(1000);\n}\n} else {\n    echo 'file locked'.chr(10);\n}\n```\n\n如果多个进程同时写文件，为了避免错乱，那么每个进程都需要用flock来尝试获取锁，用LOCK_EX排它锁。\n\n\n\n\n","slug":"flock","published":1,"updated":"2017-09-18T11:36:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7q4uqzw0014kkjen3p7qamu","content":"<ul>\n<li>先从应用方面，之后会从操作系统方面深入理解</li>\n</ul>\n<a id=\"more\"></a>\n<p>如果两个进程同时写一个文件，那么两个进程写的内容势必会乱掉，那么如何保证内容不乱呢，加锁。<br>PHP加锁的函数为<a href=\"http://cn2.php.net/manual/zh/function.flock.php\" target=\"_blank\" rel=\"external\">flock</a>，该函数有3个参数：</p>\n<ol>\n<li>文件指针；</li>\n<li>锁类型，LOCK_SH共享锁，LOCK_EX独占锁，LOCK_UN释放锁。加上LOCK_NB将不会阻塞，而是立即返回。比如LOCK_SH|LOCK_NB；</li>\n<li>wouldblock，是个引用变量，一般不会用到，可以传入一个变量，然后打印该变量看函数赋的是什么值；</li>\n</ol>\n<p>LOCK_SH共享锁，用在读取程序上；<br>LOCK_EX独占锁，用在写入程序上；</p>\n<h3 id=\"读取文件\"><a href=\"#读取文件\" class=\"headerlink\" title=\"读取文件\"></a>读取文件</h3><ol>\n<li>如果在lock1.php读取一个文件时（未加锁），lock2.php往里面写（没有加锁），那么lock1.php有可能读取脏数据，即读到lock2.php写入的数据；</li>\n<li>在lock1.php读取一个文件时（加了LOCK_SH锁），lock2.php往里面写（没有加锁），那么lock1.php还是会读取脏数据，即读到lock2.php写入的数据；</li>\n</ol>\n<ul>\n<li><p>lock1.php:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\">$f = fopen(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'r'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> ( flock($f, LOCK_SH) ) &#123; </div><div class=\"line\">    <span class=\"keyword\">while</span> (!feof($f)) &#123;</div><div class=\"line\">        $contents = fread($f, <span class=\"number\">1</span>); </div><div class=\"line\">        <span class=\"keyword\">echo</span> $contents.chr(<span class=\"number\">10</span>);</div><div class=\"line\">        usleep(<span class=\"number\">100000</span>);</div><div class=\"line\">    &#125;   </div><div class=\"line\">    flock($f, LOCK_UN);</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">'no'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">fclose($f);</div></pre></td></tr></table></figure>\n</li>\n<li><p>lock2.php:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\">$f = fopen(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'a+'</span>);</div><div class=\"line\">$re = fwrite($f, <span class=\"string\">'ok'</span>);</div><div class=\"line\">var_dump($re);</div><div class=\"line\">fclose($f);</div></pre></td></tr></table></figure>\n<p>3.如果在lock1.php读取一个文件时（加了LOCK_SH锁），lock2.php往里面写（加上LOCK_EX锁），那么lock2.php会阻塞直到lock1.php读取完毕后再写入</p>\n</li>\n<li><p>lock1.php</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\">$f = fopen(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'r'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (flock($f, LOCK_SH)) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!feof($f)) &#123;</div><div class=\"line\">        $contents = fread($f, <span class=\"number\">2</span>);</div><div class=\"line\">        <span class=\"keyword\">echo</span> $contents.chr(<span class=\"number\">10</span>);</div><div class=\"line\">        usleep(<span class=\"number\">10000</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">'no lock'</span>.chr(<span class=\"number\">10</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">fclose($f);</div></pre></td></tr></table></figure>\n</li>\n<li><p>lock2.php</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\">$f = fopen(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'a+'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> ( flock($f, LOCK_EX) ) &#123; </div><div class=\"line\"><span class=\"comment\">//if ( flock($f, LOCK_EX|LOCK_NB) ) &#123; 不会阻塞，立即返回</span></div><div class=\"line\">    fwrite($f, <span class=\"string\">'ok'</span>);</div><div class=\"line\">    flock($f, LOCK_UN);</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">'no'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">fclose($f);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"写入文件\"><a href=\"#写入文件\" class=\"headerlink\" title=\"写入文件\"></a>写入文件</h3><ol>\n<li>如果lock1.php写一个文件时（未加锁），lock2.php读取该文件（未加锁），那么lock2.php会读到脏数据</li>\n<li>如果lock1.php写一个文件时（加上LOCK_EX锁），lock2.php读取该文件（未加锁），那么lock2.php还是会读到脏数据</li>\n<li>如果lock1.php写一个文件时（加上LOCK_EX锁）, lock2.php读取该文件（加了LOCK_SH锁），那么lock2.php会等待lock1.php写完并且释放锁后读取。</li>\n</ol>\n<ul>\n<li><p>lock1.php</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\">$f = fopen(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'a+'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (flock($f, LOCK_EX)) &#123;</div><div class=\"line\"><span class=\"keyword\">for</span> ($i = <span class=\"number\">0</span>; $i&lt;<span class=\"number\">1000</span>; $i++) &#123;</div><div class=\"line\">    fwrite($f, $i.chr(<span class=\"number\">10</span>));</div><div class=\"line\">    sleep(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">fclose($f);</div></pre></td></tr></table></figure>\n</li>\n<li><p>lock2.php</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\">$f = fopen(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'r'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (flock($f, LOCK_SH|LOCK_NB)) &#123;</div><div class=\"line\"><span class=\"keyword\">while</span> (!feof($f)) &#123;</div><div class=\"line\">    $re = fread($f, <span class=\"number\">2</span>);</div><div class=\"line\">    <span class=\"keyword\">echo</span> $re.chr(<span class=\"number\">10</span>);</div><div class=\"line\">    usleep(<span class=\"number\">1000</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">'file locked'</span>.chr(<span class=\"number\">10</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果多个进程同时写文件，为了避免错乱，那么每个进程都需要用flock来尝试获取锁，用LOCK_EX排它锁。</p>\n","site":{"data":{}},"excerpt":"<ul>\n<li>先从应用方面，之后会从操作系统方面深入理解</li>\n</ul>","more":"<p>如果两个进程同时写一个文件，那么两个进程写的内容势必会乱掉，那么如何保证内容不乱呢，加锁。<br>PHP加锁的函数为<a href=\"http://cn2.php.net/manual/zh/function.flock.php\" target=\"_blank\" rel=\"external\">flock</a>，该函数有3个参数：</p>\n<ol>\n<li>文件指针；</li>\n<li>锁类型，LOCK_SH共享锁，LOCK_EX独占锁，LOCK_UN释放锁。加上LOCK_NB将不会阻塞，而是立即返回。比如LOCK_SH|LOCK_NB；</li>\n<li>wouldblock，是个引用变量，一般不会用到，可以传入一个变量，然后打印该变量看函数赋的是什么值；</li>\n</ol>\n<p>LOCK_SH共享锁，用在读取程序上；<br>LOCK_EX独占锁，用在写入程序上；</p>\n<h3 id=\"读取文件\"><a href=\"#读取文件\" class=\"headerlink\" title=\"读取文件\"></a>读取文件</h3><ol>\n<li>如果在lock1.php读取一个文件时（未加锁），lock2.php往里面写（没有加锁），那么lock1.php有可能读取脏数据，即读到lock2.php写入的数据；</li>\n<li>在lock1.php读取一个文件时（加了LOCK_SH锁），lock2.php往里面写（没有加锁），那么lock1.php还是会读取脏数据，即读到lock2.php写入的数据；</li>\n</ol>\n<ul>\n<li><p>lock1.php:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\">$f = fopen(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'r'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> ( flock($f, LOCK_SH) ) &#123; </div><div class=\"line\">    <span class=\"keyword\">while</span> (!feof($f)) &#123;</div><div class=\"line\">        $contents = fread($f, <span class=\"number\">1</span>); </div><div class=\"line\">        <span class=\"keyword\">echo</span> $contents.chr(<span class=\"number\">10</span>);</div><div class=\"line\">        usleep(<span class=\"number\">100000</span>);</div><div class=\"line\">    &#125;   </div><div class=\"line\">    flock($f, LOCK_UN);</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">'no'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">fclose($f);</div></pre></td></tr></table></figure>\n</li>\n<li><p>lock2.php:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\">$f = fopen(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'a+'</span>);</div><div class=\"line\">$re = fwrite($f, <span class=\"string\">'ok'</span>);</div><div class=\"line\">var_dump($re);</div><div class=\"line\">fclose($f);</div></pre></td></tr></table></figure>\n<p>3.如果在lock1.php读取一个文件时（加了LOCK_SH锁），lock2.php往里面写（加上LOCK_EX锁），那么lock2.php会阻塞直到lock1.php读取完毕后再写入</p>\n</li>\n<li><p>lock1.php</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\">$f = fopen(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'r'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (flock($f, LOCK_SH)) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (!feof($f)) &#123;</div><div class=\"line\">        $contents = fread($f, <span class=\"number\">2</span>);</div><div class=\"line\">        <span class=\"keyword\">echo</span> $contents.chr(<span class=\"number\">10</span>);</div><div class=\"line\">        usleep(<span class=\"number\">10000</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">'no lock'</span>.chr(<span class=\"number\">10</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">fclose($f);</div></pre></td></tr></table></figure>\n</li>\n<li><p>lock2.php</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\">$f = fopen(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'a+'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> ( flock($f, LOCK_EX) ) &#123; </div><div class=\"line\"><span class=\"comment\">//if ( flock($f, LOCK_EX|LOCK_NB) ) &#123; 不会阻塞，立即返回</span></div><div class=\"line\">    fwrite($f, <span class=\"string\">'ok'</span>);</div><div class=\"line\">    flock($f, LOCK_UN);</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">'no'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">fclose($f);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"写入文件\"><a href=\"#写入文件\" class=\"headerlink\" title=\"写入文件\"></a>写入文件</h3><ol>\n<li>如果lock1.php写一个文件时（未加锁），lock2.php读取该文件（未加锁），那么lock2.php会读到脏数据</li>\n<li>如果lock1.php写一个文件时（加上LOCK_EX锁），lock2.php读取该文件（未加锁），那么lock2.php还是会读到脏数据</li>\n<li>如果lock1.php写一个文件时（加上LOCK_EX锁）, lock2.php读取该文件（加了LOCK_SH锁），那么lock2.php会等待lock1.php写完并且释放锁后读取。</li>\n</ol>\n<ul>\n<li><p>lock1.php</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\">$f = fopen(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'a+'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (flock($f, LOCK_EX)) &#123;</div><div class=\"line\"><span class=\"keyword\">for</span> ($i = <span class=\"number\">0</span>; $i&lt;<span class=\"number\">1000</span>; $i++) &#123;</div><div class=\"line\">    fwrite($f, $i.chr(<span class=\"number\">10</span>));</div><div class=\"line\">    sleep(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">fclose($f);</div></pre></td></tr></table></figure>\n</li>\n<li><p>lock2.php</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\">$f = fopen(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'r'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (flock($f, LOCK_SH|LOCK_NB)) &#123;</div><div class=\"line\"><span class=\"keyword\">while</span> (!feof($f)) &#123;</div><div class=\"line\">    $re = fread($f, <span class=\"number\">2</span>);</div><div class=\"line\">    <span class=\"keyword\">echo</span> $re.chr(<span class=\"number\">10</span>);</div><div class=\"line\">    usleep(<span class=\"number\">1000</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">'file locked'</span>.chr(<span class=\"number\">10</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果多个进程同时写文件，为了避免错乱，那么每个进程都需要用flock来尝试获取锁，用LOCK_EX排它锁。</p>"},{"title":"The innoDB buffer pool","date":"2017-01-04T12:00:06.000Z","_content":"\n* 最近和DBA打交道，提到了InnoDB的buffer pool，所以想了解下这个概念，最好的方式当然是翻译官方文档。\n* 文档版本是5.7.\n* 官网地址：https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool.html\n\n<!--more-->\n\n#### The InnoDB Buffer Pool\n\nInnoDB维持了一个存储空间叫buffer pool，在内存里缓存数据和索引。知道InnoDB的buffer pool如何工作，并且经常利用它访问内存中的数据是一个很重要的mysql访问调优方式。\n\n你可以配置各种各样的InnoDB buffer pool方式来提升性能。\n\n* 最理想的，你设置的buffer pool大小和实际的值一样，留下足够的内存给服务器上的其他程序运行，从而没有超出页。buffer pool越大，InnoDB变的越像内存数据库，只从磁盘读取一次数据，然后在之后的读取中从内存中访问数据。查看[Section 15.6.3.2, “Configuring InnoDB Buffer Pool Size”](https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-resize.html)\n\n* 在64位系统大内存中，你可以切分buffer pool为多个部分，在并发操作中降低对内存结构的竞争。更多细节，查看[Section 15.6.3.3, “Configuring Multiple Buffer Pool Instances”](https://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-buffer-pools.html).\n\n* 你可以经常访问内存中数据，尽管有突然的操作高峰比如备份或者报告。更多细节，查看[Section 15.6.3.4, “Making the Buffer Pool Scan Resistant”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html).\n\n* 你可以控制InnoDB何时和如何提供预读请求，异步预取很快会被用到的页面进buffer pool。更多细节，查看[Section 15.6.3.5, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html).\n\n* 你可以控制当后台刷新脏页面时，InnoDB是否动态调整基于工作量的刷新比率。更多细节，查看[Section 15.6.3.6, “Configuring InnoDB Buffer Pool Flushing\"](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-adaptive_flushing.html).\n\n* 你可以微调InnoDB buffer pool刷新行为部分来提高性能。更多细节，查看[Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing\"](https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html).\n\n* 你可以配置InnoDB在服务重启后，如何保护当前buffer pool状态，避免冗长的预热期。你也可以保存当前的buffer pool状态，在服务运行的同时。更多细节，查看[Section 15.6.3.8, “Saving and Restoring the Buffer Pool State\"](https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html).\n\n#### InnoDB Buffer Pool LRU 算法\n\nInnoDB管理一个buffer pool列表，用一个最少最近使用(LRU)算法的变体。当房间需要增加一个新页面进pool时，InnoDB会清除最少最近用的页面，增加新页面到列表中间。这个“中点插入策略”按照以下两个子列表对待列表：\n\n* 在头部，一个新或者young页面子列表是最近访问的\n* 在尾部，一个旧页面子列表是最少最近访问的\n\n这个算法使得在新子列表中页面能被大量查询到。旧的子列表包含最少使用页面；这些页面是清除的候选。\n\nLRU算法默认按照以下几点操作：\n\n* 3/8的buffer pool专门给旧的子列表用\n* 列表中点是新子列表尾部遇到旧子列表头部的边界\n* 当InnoDB读取一个页面进buffer pool时，起初会被插入到中点（旧子列表的头部）。这个页面能被读取是因为它包含在用户的特殊操作中，比如一个SQL查询，或者是在InnoDB的自动预读取操作部分。\n* 随着数据库的操作，在buffer pool中未被访问的页面通过向列表尾部移动而“老化”。新旧子列表中的页面随着其他页面变新而变旧。旧子列表中页面也随着页面被插入到中点而变旧。最终，很长时间没被使用的页面到达旧列表尾部而被清除。\n\n默认，被查询的页面会立即移动到新子列表，意味着它们将会在很长一段时间内留在buffer pool。一个表扫描（例如一个mysqldump操作，或者没有where的select语句）会带很大的数据进入buffer poll，然后清除大量的旧数据，即使这个新数据从来不会被用。类似的，后台进程预读加载的页面，只有被移到新列表的头部才会被访问到。这些情况会经常推送有用的页面到旧子列表，然后它们成为清除的对象。关于这些行为的更多信息，查看[Section 15.6.3.4, “Making the Buffer Pool Scan Resistant”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html)和[Section 15.6.3.5, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html).\n\nInnoDB标准监控输出包含buffer pool和内存部分的几个领域，这些从属于buffer pool LRU算法。更多细节查看[Section 15.6.3.9, “Monitoring the Buffer Pool Using the InnoDB Standard Monitor”](https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-monitoring.html).\n\n#### InnoDB Buffer Pool 配置选项\n\n几个影响InnoDB buffer pool不同部分的配置选项。\n\n* [innodb_buffer_pool_size](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size)\n指定buffer pool的大小。如果buffer pool比较小，而你有充足的内存，那么把buffer pool增大点可以减少查询访问InnoDB表的磁盘I/O操作，从而提升性能。在mysql的5.7.5，innodb_buffer_pool_size设置是动态的，不用重启服务你就可以配置它。查看[Section 15.6.3.2, “Configuring InnoDB Buffer Pool Size”](https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-resize.html).\n\n* innodb_buffer_pool_chunk_size\n定义了Innodb buffer pool 改变操作的块大小。查看[Section 15.6.3.2, “Configuring InnoDB Buffer Pool Size”](https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-resize.html)\n\n* [innodb_buffer_pool_instances](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_instances)\n划分buffer pool为用户指定的几个单独部分，每一个都有自己的LRU列表和相近的数据结构，这样在并发的内存读写操作中减少竞争。这个选项只有在你设置[innodb_buffer_pool_size](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size)大于1GB时才生效。你指定的总大小会被划分给所有的buffer polls。为了最高的效率，可以指定一个[innodb_buffer_pool_instances](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_instances)和[innodb_buffer_pool_size](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size)的组合，这样每一个buffer pool实例都至少有1g。查看[Section 14.9.2.2, “Configuring Multiple Buffer Pool Instances”](https://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-buffer-pools.html).\n\n* [innodb_old_blocks_pct](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_pct)\n指定InnoDB给旧子列表块用的buffer pool近似百分比。值范围为5到95。默认值为37（也就是3/8的pool）。查看[Section 15.6.3.4, “Making the Buffer Pool Scan Resistant”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html).\n\n* [innodb_old_blocks_time](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time)\n指定一个页面插入到旧子列表后必须停留多少ms，当它第一次被访问移到新子列表前。如果值是0，那么被移到旧子列表的页面将会立即移动到新子列表，当它第一次被访问的时候，无论插入后访问发生了多久。如果值大于0，页面会停留在旧子列表知道一个访问发生，至少第一次访问后许多ms。比如，值是1000会使页面停留在旧子列表1秒在第一次访问之后，移动到新子列表之前。\n\n设置[innodb_old_blocks_time](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time)值超过0可以防止一次表扫描扫大量的新子列表，只为了这次扫描。一次页面扫描读取行被快速连续访问多次，但是之后这个页面却是没用的。如果[innodb_old_blocks_time](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time)设置的值比处理页面的时间大，那么在旧子列表的和该到列表尾部的页面将被很快的清除。这样，只被一次表扫描用的页面不会对新子列表中的大量使用的页面造成损害。\n\n[innodb_old_blocks_time](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time)可以在运行时设置，所以你可以在执行诸如表扫描和下载操作的时候暂时改变它：\n\n    SET GLOBAL innodb_old_blocks_time = 1000;\n    ... perform queries that scan tables ...\n    SET GLOBAL innodb_old_blocks_time = 0;\n这个策略并不会执行，如果你的意图是想通过充满一个表的内容来热启动buffer pool。比如，基准测试经常在服务启动时做一个表或者索引扫描，因为当用了一段时间之后，数据通常都在buffer pool里面。在这种情况，把[innodb_old_blocks_time](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time)设为0，至少等到热启动完成。查看[Section 15.6.3.4, “Making the Buffer Pool Scan Resistant”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html).\n\n* [innodb_read_ahead_threshold](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_read_ahead_threshold)\n控制线性预读的灵敏度，InnoDB经常用来预读取页面进buffer pool。查看[Section 15.6.3.5, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html).\n\n* [innodb_random_read_ahead](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_random_read_ahead)\n为预读取页面进buffer pool启动随机预读技术。随机预读技术是基于已经存在buffer pool的也看来预言将会被用到的页面，不理会那些页面被读取的顺序。[innodb_random_read_ahead](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_random_read_ahead)默认是关闭的。查看[Section 15.6.3.5, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html)。\n\n* [innodb_adaptive_flushing](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_adaptive_flushing)\n指定是否自动调整刷新[脏页面](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page)的比率，基于在工作中的buffer pool。自动调整刷新比率是想要防止I/O操作的爆发。这个设定是默认开启的。查看[Section 15.6.3.6, “Configuring InnoDB Buffer Pool Flushing”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-adaptive_flushing.html).\n\n* [innodb_adaptive_flushing_lwm](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_adaptive_flushing_lwm)\n当[adaptive flushing](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_adaptive_flushing)启用时，低水位线，相当于[redo log](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_redo_log)所能容纳的百分比。查看[Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”](https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html)\n\n* [innodb_flush_neighbors](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_neighbors)\n规定从buffer pool刷新页面是否也刷新其他[dirty pages](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page)，在同样[extent](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_extent)范围里。查看[Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-adaptive_flushing.html).\n\n* [innodb_flushing_avg_loops](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flushing_avg_loops)\ninnoDB保留之前计算的刷新状态快照的迭代次数，控制[adaptive flushing](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_adaptive_flushing)回应改变[工作量](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_workload)的速度。查看[Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”](https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html)\n\n* [innodb_lru_scan_depth](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_lru_scan_depth)\n一个影响[flush](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_flush)操作buffer pool的算法和启发式。主要关注i/o密集型工作量性能。具体来说，每一个buffer pool实例，page_cleaner线程扫描寻找[脏页面](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page)刷新有多深入buffer pool LRU的列表。查看[Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”](https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html).\n\n* [innodb_max_dirty_pages_pct](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_max_dirty_pages_pct)\nInnoDB会尝试从buffer pool中[刷新](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_flush)数据，使得[脏页面](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page)的占比不回超过这个值。指定一个从0到99的整数。默认值为75.查看[Section 15.6.3.6, “Configuring InnoDB Buffer Pool Flushing”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-adaptive_flushing.html).\n\n* [innodb_max_dirty_pages_pct_lwm](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_max_dirty_pages_pct_lwm)\n预刷新的[脏页面](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page)低水位控制脏页面比例。默认值0来使预刷新行为完全无效。查看[Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”](https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html).\n\n* [innodb_buffer_pool_filename](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_filename)\n指定文件名字，该文件保存[innodb_buffer_pool_dump_at_shutdown](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_at_shutdown)和[innodb_buffer_pool_dump_now](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_now)产生的表空间ID和页面ID。查看[Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”](https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html)\n\n* [innodb_buffer_pool_dump_at_shutdown](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_at_shutdown)\n指明当mysql宕机的时候是否记录缓存在buffer pool的页面，以在下次重启时缩短[预热](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_warm_up)过程。查看[Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”](https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html)\n\n* [innodb_buffer_pool_load_at_startup](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_at_startup)\n指定在mysql启动时，buffer pool[预热](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_warm_up)自动加载早些时候加载的页面.通常和[innodb_buffer_pool_dump_at_shutdown](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_at_shutdown)一起用。查看[Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”](https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html)\n\n* [innodb_buffer_pool_dump_now](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_now)\n立即记录缓存在buffer pool的页面。查看[Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”](https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html)\n\n* [innodb_buffer_pool_load_now](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_now)\n立即[预热](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_warm_up)buffer pool加载一些数据页面，不等mysql重启。在基准测试中将缓存恢复到已知状态很有用，或者是使mysql运行报表或维护查询后恢复正常工作负载。通常和[innodb_buffer_pool_dump_now](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_now)一起用。查看[Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”](https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html)\n\n* [innodb_buffer_pool_dump_pct](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_pct)\n指定每一个buffer pool读出下载最近用到的页面百分比。范围从1到100. 查看[Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”](https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html)\n\n* [innodb_buffer_pool_load_abort](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_abort)\n中断由[innodb_buffer_pool_load_at_startup](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_at_startup)或者[innodb_buffer_pool_load_now](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_now)触发的修复buffer pool内容的进程。查看[Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”](https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html)\n","source":"_posts/2017-01-04-bufferPool.md","raw":"---\ntitle: The innoDB buffer pool\ndate: 2017-01-04 20:00:06\ntags: mysql\ncategories: 数据库\n---\n\n* 最近和DBA打交道，提到了InnoDB的buffer pool，所以想了解下这个概念，最好的方式当然是翻译官方文档。\n* 文档版本是5.7.\n* 官网地址：https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool.html\n\n<!--more-->\n\n#### The InnoDB Buffer Pool\n\nInnoDB维持了一个存储空间叫buffer pool，在内存里缓存数据和索引。知道InnoDB的buffer pool如何工作，并且经常利用它访问内存中的数据是一个很重要的mysql访问调优方式。\n\n你可以配置各种各样的InnoDB buffer pool方式来提升性能。\n\n* 最理想的，你设置的buffer pool大小和实际的值一样，留下足够的内存给服务器上的其他程序运行，从而没有超出页。buffer pool越大，InnoDB变的越像内存数据库，只从磁盘读取一次数据，然后在之后的读取中从内存中访问数据。查看[Section 15.6.3.2, “Configuring InnoDB Buffer Pool Size”](https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-resize.html)\n\n* 在64位系统大内存中，你可以切分buffer pool为多个部分，在并发操作中降低对内存结构的竞争。更多细节，查看[Section 15.6.3.3, “Configuring Multiple Buffer Pool Instances”](https://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-buffer-pools.html).\n\n* 你可以经常访问内存中数据，尽管有突然的操作高峰比如备份或者报告。更多细节，查看[Section 15.6.3.4, “Making the Buffer Pool Scan Resistant”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html).\n\n* 你可以控制InnoDB何时和如何提供预读请求，异步预取很快会被用到的页面进buffer pool。更多细节，查看[Section 15.6.3.5, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html).\n\n* 你可以控制当后台刷新脏页面时，InnoDB是否动态调整基于工作量的刷新比率。更多细节，查看[Section 15.6.3.6, “Configuring InnoDB Buffer Pool Flushing\"](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-adaptive_flushing.html).\n\n* 你可以微调InnoDB buffer pool刷新行为部分来提高性能。更多细节，查看[Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing\"](https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html).\n\n* 你可以配置InnoDB在服务重启后，如何保护当前buffer pool状态，避免冗长的预热期。你也可以保存当前的buffer pool状态，在服务运行的同时。更多细节，查看[Section 15.6.3.8, “Saving and Restoring the Buffer Pool State\"](https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html).\n\n#### InnoDB Buffer Pool LRU 算法\n\nInnoDB管理一个buffer pool列表，用一个最少最近使用(LRU)算法的变体。当房间需要增加一个新页面进pool时，InnoDB会清除最少最近用的页面，增加新页面到列表中间。这个“中点插入策略”按照以下两个子列表对待列表：\n\n* 在头部，一个新或者young页面子列表是最近访问的\n* 在尾部，一个旧页面子列表是最少最近访问的\n\n这个算法使得在新子列表中页面能被大量查询到。旧的子列表包含最少使用页面；这些页面是清除的候选。\n\nLRU算法默认按照以下几点操作：\n\n* 3/8的buffer pool专门给旧的子列表用\n* 列表中点是新子列表尾部遇到旧子列表头部的边界\n* 当InnoDB读取一个页面进buffer pool时，起初会被插入到中点（旧子列表的头部）。这个页面能被读取是因为它包含在用户的特殊操作中，比如一个SQL查询，或者是在InnoDB的自动预读取操作部分。\n* 随着数据库的操作，在buffer pool中未被访问的页面通过向列表尾部移动而“老化”。新旧子列表中的页面随着其他页面变新而变旧。旧子列表中页面也随着页面被插入到中点而变旧。最终，很长时间没被使用的页面到达旧列表尾部而被清除。\n\n默认，被查询的页面会立即移动到新子列表，意味着它们将会在很长一段时间内留在buffer pool。一个表扫描（例如一个mysqldump操作，或者没有where的select语句）会带很大的数据进入buffer poll，然后清除大量的旧数据，即使这个新数据从来不会被用。类似的，后台进程预读加载的页面，只有被移到新列表的头部才会被访问到。这些情况会经常推送有用的页面到旧子列表，然后它们成为清除的对象。关于这些行为的更多信息，查看[Section 15.6.3.4, “Making the Buffer Pool Scan Resistant”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html)和[Section 15.6.3.5, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html).\n\nInnoDB标准监控输出包含buffer pool和内存部分的几个领域，这些从属于buffer pool LRU算法。更多细节查看[Section 15.6.3.9, “Monitoring the Buffer Pool Using the InnoDB Standard Monitor”](https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-monitoring.html).\n\n#### InnoDB Buffer Pool 配置选项\n\n几个影响InnoDB buffer pool不同部分的配置选项。\n\n* [innodb_buffer_pool_size](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size)\n指定buffer pool的大小。如果buffer pool比较小，而你有充足的内存，那么把buffer pool增大点可以减少查询访问InnoDB表的磁盘I/O操作，从而提升性能。在mysql的5.7.5，innodb_buffer_pool_size设置是动态的，不用重启服务你就可以配置它。查看[Section 15.6.3.2, “Configuring InnoDB Buffer Pool Size”](https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-resize.html).\n\n* innodb_buffer_pool_chunk_size\n定义了Innodb buffer pool 改变操作的块大小。查看[Section 15.6.3.2, “Configuring InnoDB Buffer Pool Size”](https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-resize.html)\n\n* [innodb_buffer_pool_instances](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_instances)\n划分buffer pool为用户指定的几个单独部分，每一个都有自己的LRU列表和相近的数据结构，这样在并发的内存读写操作中减少竞争。这个选项只有在你设置[innodb_buffer_pool_size](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size)大于1GB时才生效。你指定的总大小会被划分给所有的buffer polls。为了最高的效率，可以指定一个[innodb_buffer_pool_instances](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_instances)和[innodb_buffer_pool_size](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size)的组合，这样每一个buffer pool实例都至少有1g。查看[Section 14.9.2.2, “Configuring Multiple Buffer Pool Instances”](https://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-buffer-pools.html).\n\n* [innodb_old_blocks_pct](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_pct)\n指定InnoDB给旧子列表块用的buffer pool近似百分比。值范围为5到95。默认值为37（也就是3/8的pool）。查看[Section 15.6.3.4, “Making the Buffer Pool Scan Resistant”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html).\n\n* [innodb_old_blocks_time](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time)\n指定一个页面插入到旧子列表后必须停留多少ms，当它第一次被访问移到新子列表前。如果值是0，那么被移到旧子列表的页面将会立即移动到新子列表，当它第一次被访问的时候，无论插入后访问发生了多久。如果值大于0，页面会停留在旧子列表知道一个访问发生，至少第一次访问后许多ms。比如，值是1000会使页面停留在旧子列表1秒在第一次访问之后，移动到新子列表之前。\n\n设置[innodb_old_blocks_time](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time)值超过0可以防止一次表扫描扫大量的新子列表，只为了这次扫描。一次页面扫描读取行被快速连续访问多次，但是之后这个页面却是没用的。如果[innodb_old_blocks_time](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time)设置的值比处理页面的时间大，那么在旧子列表的和该到列表尾部的页面将被很快的清除。这样，只被一次表扫描用的页面不会对新子列表中的大量使用的页面造成损害。\n\n[innodb_old_blocks_time](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time)可以在运行时设置，所以你可以在执行诸如表扫描和下载操作的时候暂时改变它：\n\n    SET GLOBAL innodb_old_blocks_time = 1000;\n    ... perform queries that scan tables ...\n    SET GLOBAL innodb_old_blocks_time = 0;\n这个策略并不会执行，如果你的意图是想通过充满一个表的内容来热启动buffer pool。比如，基准测试经常在服务启动时做一个表或者索引扫描，因为当用了一段时间之后，数据通常都在buffer pool里面。在这种情况，把[innodb_old_blocks_time](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time)设为0，至少等到热启动完成。查看[Section 15.6.3.4, “Making the Buffer Pool Scan Resistant”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html).\n\n* [innodb_read_ahead_threshold](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_read_ahead_threshold)\n控制线性预读的灵敏度，InnoDB经常用来预读取页面进buffer pool。查看[Section 15.6.3.5, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html).\n\n* [innodb_random_read_ahead](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_random_read_ahead)\n为预读取页面进buffer pool启动随机预读技术。随机预读技术是基于已经存在buffer pool的也看来预言将会被用到的页面，不理会那些页面被读取的顺序。[innodb_random_read_ahead](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_random_read_ahead)默认是关闭的。查看[Section 15.6.3.5, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html)。\n\n* [innodb_adaptive_flushing](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_adaptive_flushing)\n指定是否自动调整刷新[脏页面](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page)的比率，基于在工作中的buffer pool。自动调整刷新比率是想要防止I/O操作的爆发。这个设定是默认开启的。查看[Section 15.6.3.6, “Configuring InnoDB Buffer Pool Flushing”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-adaptive_flushing.html).\n\n* [innodb_adaptive_flushing_lwm](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_adaptive_flushing_lwm)\n当[adaptive flushing](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_adaptive_flushing)启用时，低水位线，相当于[redo log](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_redo_log)所能容纳的百分比。查看[Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”](https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html)\n\n* [innodb_flush_neighbors](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_neighbors)\n规定从buffer pool刷新页面是否也刷新其他[dirty pages](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page)，在同样[extent](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_extent)范围里。查看[Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-adaptive_flushing.html).\n\n* [innodb_flushing_avg_loops](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flushing_avg_loops)\ninnoDB保留之前计算的刷新状态快照的迭代次数，控制[adaptive flushing](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_adaptive_flushing)回应改变[工作量](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_workload)的速度。查看[Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”](https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html)\n\n* [innodb_lru_scan_depth](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_lru_scan_depth)\n一个影响[flush](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_flush)操作buffer pool的算法和启发式。主要关注i/o密集型工作量性能。具体来说，每一个buffer pool实例，page_cleaner线程扫描寻找[脏页面](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page)刷新有多深入buffer pool LRU的列表。查看[Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”](https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html).\n\n* [innodb_max_dirty_pages_pct](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_max_dirty_pages_pct)\nInnoDB会尝试从buffer pool中[刷新](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_flush)数据，使得[脏页面](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page)的占比不回超过这个值。指定一个从0到99的整数。默认值为75.查看[Section 15.6.3.6, “Configuring InnoDB Buffer Pool Flushing”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-adaptive_flushing.html).\n\n* [innodb_max_dirty_pages_pct_lwm](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_max_dirty_pages_pct_lwm)\n预刷新的[脏页面](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page)低水位控制脏页面比例。默认值0来使预刷新行为完全无效。查看[Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”](https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html).\n\n* [innodb_buffer_pool_filename](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_filename)\n指定文件名字，该文件保存[innodb_buffer_pool_dump_at_shutdown](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_at_shutdown)和[innodb_buffer_pool_dump_now](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_now)产生的表空间ID和页面ID。查看[Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”](https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html)\n\n* [innodb_buffer_pool_dump_at_shutdown](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_at_shutdown)\n指明当mysql宕机的时候是否记录缓存在buffer pool的页面，以在下次重启时缩短[预热](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_warm_up)过程。查看[Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”](https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html)\n\n* [innodb_buffer_pool_load_at_startup](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_at_startup)\n指定在mysql启动时，buffer pool[预热](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_warm_up)自动加载早些时候加载的页面.通常和[innodb_buffer_pool_dump_at_shutdown](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_at_shutdown)一起用。查看[Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”](https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html)\n\n* [innodb_buffer_pool_dump_now](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_now)\n立即记录缓存在buffer pool的页面。查看[Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”](https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html)\n\n* [innodb_buffer_pool_load_now](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_now)\n立即[预热](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_warm_up)buffer pool加载一些数据页面，不等mysql重启。在基准测试中将缓存恢复到已知状态很有用，或者是使mysql运行报表或维护查询后恢复正常工作负载。通常和[innodb_buffer_pool_dump_now](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_now)一起用。查看[Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”](https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html)\n\n* [innodb_buffer_pool_dump_pct](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_pct)\n指定每一个buffer pool读出下载最近用到的页面百分比。范围从1到100. 查看[Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”](https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html)\n\n* [innodb_buffer_pool_load_abort](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_abort)\n中断由[innodb_buffer_pool_load_at_startup](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_at_startup)或者[innodb_buffer_pool_load_now](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_now)触发的修复buffer pool内容的进程。查看[Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”](https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html)\n","slug":"bufferPool","published":1,"updated":"2017-09-18T11:36:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7q4uqzy0017kkjee8xcq8ce","content":"<ul>\n<li>最近和DBA打交道，提到了InnoDB的buffer pool，所以想了解下这个概念，最好的方式当然是翻译官方文档。</li>\n<li>文档版本是5.7.</li>\n<li>官网地址：<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool.html\" target=\"_blank\" rel=\"external\">https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool.html</a></li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"The-InnoDB-Buffer-Pool\"><a href=\"#The-InnoDB-Buffer-Pool\" class=\"headerlink\" title=\"The InnoDB Buffer Pool\"></a>The InnoDB Buffer Pool</h4><p>InnoDB维持了一个存储空间叫buffer pool，在内存里缓存数据和索引。知道InnoDB的buffer pool如何工作，并且经常利用它访问内存中的数据是一个很重要的mysql访问调优方式。</p>\n<p>你可以配置各种各样的InnoDB buffer pool方式来提升性能。</p>\n<ul>\n<li><p>最理想的，你设置的buffer pool大小和实际的值一样，留下足够的内存给服务器上的其他程序运行，从而没有超出页。buffer pool越大，InnoDB变的越像内存数据库，只从磁盘读取一次数据，然后在之后的读取中从内存中访问数据。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-resize.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.2, “Configuring InnoDB Buffer Pool Size”</a></p>\n</li>\n<li><p>在64位系统大内存中，你可以切分buffer pool为多个部分，在并发操作中降低对内存结构的竞争。更多细节，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-buffer-pools.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.3, “Configuring Multiple Buffer Pool Instances”</a>.</p>\n</li>\n<li><p>你可以经常访问内存中数据，尽管有突然的操作高峰比如备份或者报告。更多细节，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.4, “Making the Buffer Pool Scan Resistant”</a>.</p>\n</li>\n<li><p>你可以控制InnoDB何时和如何提供预读请求，异步预取很快会被用到的页面进buffer pool。更多细节，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.5, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”</a>.</p>\n</li>\n<li><p>你可以控制当后台刷新脏页面时，InnoDB是否动态调整基于工作量的刷新比率。更多细节，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-adaptive_flushing.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.6, “Configuring InnoDB Buffer Pool Flushing”</a>.</p>\n</li>\n<li><p>你可以微调InnoDB buffer pool刷新行为部分来提高性能。更多细节，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”</a>.</p>\n</li>\n<li><p>你可以配置InnoDB在服务重启后，如何保护当前buffer pool状态，避免冗长的预热期。你也可以保存当前的buffer pool状态，在服务运行的同时。更多细节，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”</a>.</p>\n</li>\n</ul>\n<h4 id=\"InnoDB-Buffer-Pool-LRU-算法\"><a href=\"#InnoDB-Buffer-Pool-LRU-算法\" class=\"headerlink\" title=\"InnoDB Buffer Pool LRU 算法\"></a>InnoDB Buffer Pool LRU 算法</h4><p>InnoDB管理一个buffer pool列表，用一个最少最近使用(LRU)算法的变体。当房间需要增加一个新页面进pool时，InnoDB会清除最少最近用的页面，增加新页面到列表中间。这个“中点插入策略”按照以下两个子列表对待列表：</p>\n<ul>\n<li>在头部，一个新或者young页面子列表是最近访问的</li>\n<li>在尾部，一个旧页面子列表是最少最近访问的</li>\n</ul>\n<p>这个算法使得在新子列表中页面能被大量查询到。旧的子列表包含最少使用页面；这些页面是清除的候选。</p>\n<p>LRU算法默认按照以下几点操作：</p>\n<ul>\n<li>3/8的buffer pool专门给旧的子列表用</li>\n<li>列表中点是新子列表尾部遇到旧子列表头部的边界</li>\n<li>当InnoDB读取一个页面进buffer pool时，起初会被插入到中点（旧子列表的头部）。这个页面能被读取是因为它包含在用户的特殊操作中，比如一个SQL查询，或者是在InnoDB的自动预读取操作部分。</li>\n<li>随着数据库的操作，在buffer pool中未被访问的页面通过向列表尾部移动而“老化”。新旧子列表中的页面随着其他页面变新而变旧。旧子列表中页面也随着页面被插入到中点而变旧。最终，很长时间没被使用的页面到达旧列表尾部而被清除。</li>\n</ul>\n<p>默认，被查询的页面会立即移动到新子列表，意味着它们将会在很长一段时间内留在buffer pool。一个表扫描（例如一个mysqldump操作，或者没有where的select语句）会带很大的数据进入buffer poll，然后清除大量的旧数据，即使这个新数据从来不会被用。类似的，后台进程预读加载的页面，只有被移到新列表的头部才会被访问到。这些情况会经常推送有用的页面到旧子列表，然后它们成为清除的对象。关于这些行为的更多信息，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.4, “Making the Buffer Pool Scan Resistant”</a>和<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.5, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”</a>.</p>\n<p>InnoDB标准监控输出包含buffer pool和内存部分的几个领域，这些从属于buffer pool LRU算法。更多细节查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-monitoring.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.9, “Monitoring the Buffer Pool Using the InnoDB Standard Monitor”</a>.</p>\n<h4 id=\"InnoDB-Buffer-Pool-配置选项\"><a href=\"#InnoDB-Buffer-Pool-配置选项\" class=\"headerlink\" title=\"InnoDB Buffer Pool 配置选项\"></a>InnoDB Buffer Pool 配置选项</h4><p>几个影响InnoDB buffer pool不同部分的配置选项。</p>\n<ul>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_size</a><br>指定buffer pool的大小。如果buffer pool比较小，而你有充足的内存，那么把buffer pool增大点可以减少查询访问InnoDB表的磁盘I/O操作，从而提升性能。在mysql的5.7.5，innodb_buffer_pool_size设置是动态的，不用重启服务你就可以配置它。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-resize.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.2, “Configuring InnoDB Buffer Pool Size”</a>.</p>\n</li>\n<li><p>innodb_buffer_pool_chunk_size<br>定义了Innodb buffer pool 改变操作的块大小。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-resize.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.2, “Configuring InnoDB Buffer Pool Size”</a></p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_instances\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_instances</a><br>划分buffer pool为用户指定的几个单独部分，每一个都有自己的LRU列表和相近的数据结构，这样在并发的内存读写操作中减少竞争。这个选项只有在你设置<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_size</a>大于1GB时才生效。你指定的总大小会被划分给所有的buffer polls。为了最高的效率，可以指定一个<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_instances\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_instances</a>和<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_size</a>的组合，这样每一个buffer pool实例都至少有1g。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-buffer-pools.html\" target=\"_blank\" rel=\"external\">Section 14.9.2.2, “Configuring Multiple Buffer Pool Instances”</a>.</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_pct\" target=\"_blank\" rel=\"external\">innodb_old_blocks_pct</a><br>指定InnoDB给旧子列表块用的buffer pool近似百分比。值范围为5到95。默认值为37（也就是3/8的pool）。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.4, “Making the Buffer Pool Scan Resistant”</a>.</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time\" target=\"_blank\" rel=\"external\">innodb_old_blocks_time</a><br>指定一个页面插入到旧子列表后必须停留多少ms，当它第一次被访问移到新子列表前。如果值是0，那么被移到旧子列表的页面将会立即移动到新子列表，当它第一次被访问的时候，无论插入后访问发生了多久。如果值大于0，页面会停留在旧子列表知道一个访问发生，至少第一次访问后许多ms。比如，值是1000会使页面停留在旧子列表1秒在第一次访问之后，移动到新子列表之前。</p>\n</li>\n</ul>\n<p>设置<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time\" target=\"_blank\" rel=\"external\">innodb_old_blocks_time</a>值超过0可以防止一次表扫描扫大量的新子列表，只为了这次扫描。一次页面扫描读取行被快速连续访问多次，但是之后这个页面却是没用的。如果<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time\" target=\"_blank\" rel=\"external\">innodb_old_blocks_time</a>设置的值比处理页面的时间大，那么在旧子列表的和该到列表尾部的页面将被很快的清除。这样，只被一次表扫描用的页面不会对新子列表中的大量使用的页面造成损害。</p>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time\" target=\"_blank\" rel=\"external\">innodb_old_blocks_time</a>可以在运行时设置，所以你可以在执行诸如表扫描和下载操作的时候暂时改变它：</p>\n<pre><code>SET GLOBAL innodb_old_blocks_time = 1000;\n... perform queries that scan tables ...\nSET GLOBAL innodb_old_blocks_time = 0;\n</code></pre><p>这个策略并不会执行，如果你的意图是想通过充满一个表的内容来热启动buffer pool。比如，基准测试经常在服务启动时做一个表或者索引扫描，因为当用了一段时间之后，数据通常都在buffer pool里面。在这种情况，把<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time\" target=\"_blank\" rel=\"external\">innodb_old_blocks_time</a>设为0，至少等到热启动完成。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.4, “Making the Buffer Pool Scan Resistant”</a>.</p>\n<ul>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_read_ahead_threshold\" target=\"_blank\" rel=\"external\">innodb_read_ahead_threshold</a><br>控制线性预读的灵敏度，InnoDB经常用来预读取页面进buffer pool。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.5, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”</a>.</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_random_read_ahead\" target=\"_blank\" rel=\"external\">innodb_random_read_ahead</a><br>为预读取页面进buffer pool启动随机预读技术。随机预读技术是基于已经存在buffer pool的也看来预言将会被用到的页面，不理会那些页面被读取的顺序。<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_random_read_ahead\" target=\"_blank\" rel=\"external\">innodb_random_read_ahead</a>默认是关闭的。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.5, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”</a>。</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_adaptive_flushing\" target=\"_blank\" rel=\"external\">innodb_adaptive_flushing</a><br>指定是否自动调整刷新<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page\" target=\"_blank\" rel=\"external\">脏页面</a>的比率，基于在工作中的buffer pool。自动调整刷新比率是想要防止I/O操作的爆发。这个设定是默认开启的。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-adaptive_flushing.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.6, “Configuring InnoDB Buffer Pool Flushing”</a>.</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_adaptive_flushing_lwm\" target=\"_blank\" rel=\"external\">innodb_adaptive_flushing_lwm</a><br>当<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_adaptive_flushing\" target=\"_blank\" rel=\"external\">adaptive flushing</a>启用时，低水位线，相当于<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_redo_log\" target=\"_blank\" rel=\"external\">redo log</a>所能容纳的百分比。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”</a></p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_neighbors\" target=\"_blank\" rel=\"external\">innodb_flush_neighbors</a><br>规定从buffer pool刷新页面是否也刷新其他<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page\" target=\"_blank\" rel=\"external\">dirty pages</a>，在同样<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_extent\" target=\"_blank\" rel=\"external\">extent</a>范围里。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-adaptive_flushing.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”</a>.</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flushing_avg_loops\" target=\"_blank\" rel=\"external\">innodb_flushing_avg_loops</a><br>innoDB保留之前计算的刷新状态快照的迭代次数，控制<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_adaptive_flushing\" target=\"_blank\" rel=\"external\">adaptive flushing</a>回应改变<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_workload\" target=\"_blank\" rel=\"external\">工作量</a>的速度。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”</a></p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_lru_scan_depth\" target=\"_blank\" rel=\"external\">innodb_lru_scan_depth</a><br>一个影响<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_flush\" target=\"_blank\" rel=\"external\">flush</a>操作buffer pool的算法和启发式。主要关注i/o密集型工作量性能。具体来说，每一个buffer pool实例，page_cleaner线程扫描寻找<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page\" target=\"_blank\" rel=\"external\">脏页面</a>刷新有多深入buffer pool LRU的列表。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”</a>.</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_max_dirty_pages_pct\" target=\"_blank\" rel=\"external\">innodb_max_dirty_pages_pct</a><br>InnoDB会尝试从buffer pool中<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_flush\" target=\"_blank\" rel=\"external\">刷新</a>数据，使得<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page\" target=\"_blank\" rel=\"external\">脏页面</a>的占比不回超过这个值。指定一个从0到99的整数。默认值为75.查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-adaptive_flushing.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.6, “Configuring InnoDB Buffer Pool Flushing”</a>.</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_max_dirty_pages_pct_lwm\" target=\"_blank\" rel=\"external\">innodb_max_dirty_pages_pct_lwm</a><br>预刷新的<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page\" target=\"_blank\" rel=\"external\">脏页面</a>低水位控制脏页面比例。默认值0来使预刷新行为完全无效。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”</a>.</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_filename\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_filename</a><br>指定文件名字，该文件保存<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_at_shutdown\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_dump_at_shutdown</a>和<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_now\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_dump_now</a>产生的表空间ID和页面ID。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”</a></p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_at_shutdown\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_dump_at_shutdown</a><br>指明当mysql宕机的时候是否记录缓存在buffer pool的页面，以在下次重启时缩短<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_warm_up\" target=\"_blank\" rel=\"external\">预热</a>过程。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”</a></p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_at_startup\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_load_at_startup</a><br>指定在mysql启动时，buffer pool<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_warm_up\" target=\"_blank\" rel=\"external\">预热</a>自动加载早些时候加载的页面.通常和<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_at_shutdown\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_dump_at_shutdown</a>一起用。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”</a></p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_now\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_dump_now</a><br>立即记录缓存在buffer pool的页面。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”</a></p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_now\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_load_now</a><br>立即<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_warm_up\" target=\"_blank\" rel=\"external\">预热</a>buffer pool加载一些数据页面，不等mysql重启。在基准测试中将缓存恢复到已知状态很有用，或者是使mysql运行报表或维护查询后恢复正常工作负载。通常和<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_now\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_dump_now</a>一起用。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”</a></p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_pct\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_dump_pct</a><br>指定每一个buffer pool读出下载最近用到的页面百分比。范围从1到100. 查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”</a></p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_abort\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_load_abort</a><br>中断由<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_at_startup\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_load_at_startup</a>或者<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_now\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_load_now</a>触发的修复buffer pool内容的进程。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li>最近和DBA打交道，提到了InnoDB的buffer pool，所以想了解下这个概念，最好的方式当然是翻译官方文档。</li>\n<li>文档版本是5.7.</li>\n<li>官网地址：<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool.html\" target=\"_blank\" rel=\"external\">https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool.html</a></li>\n</ul>","more":"<h4 id=\"The-InnoDB-Buffer-Pool\"><a href=\"#The-InnoDB-Buffer-Pool\" class=\"headerlink\" title=\"The InnoDB Buffer Pool\"></a>The InnoDB Buffer Pool</h4><p>InnoDB维持了一个存储空间叫buffer pool，在内存里缓存数据和索引。知道InnoDB的buffer pool如何工作，并且经常利用它访问内存中的数据是一个很重要的mysql访问调优方式。</p>\n<p>你可以配置各种各样的InnoDB buffer pool方式来提升性能。</p>\n<ul>\n<li><p>最理想的，你设置的buffer pool大小和实际的值一样，留下足够的内存给服务器上的其他程序运行，从而没有超出页。buffer pool越大，InnoDB变的越像内存数据库，只从磁盘读取一次数据，然后在之后的读取中从内存中访问数据。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-resize.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.2, “Configuring InnoDB Buffer Pool Size”</a></p>\n</li>\n<li><p>在64位系统大内存中，你可以切分buffer pool为多个部分，在并发操作中降低对内存结构的竞争。更多细节，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-buffer-pools.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.3, “Configuring Multiple Buffer Pool Instances”</a>.</p>\n</li>\n<li><p>你可以经常访问内存中数据，尽管有突然的操作高峰比如备份或者报告。更多细节，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.4, “Making the Buffer Pool Scan Resistant”</a>.</p>\n</li>\n<li><p>你可以控制InnoDB何时和如何提供预读请求，异步预取很快会被用到的页面进buffer pool。更多细节，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.5, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”</a>.</p>\n</li>\n<li><p>你可以控制当后台刷新脏页面时，InnoDB是否动态调整基于工作量的刷新比率。更多细节，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-adaptive_flushing.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.6, “Configuring InnoDB Buffer Pool Flushing”</a>.</p>\n</li>\n<li><p>你可以微调InnoDB buffer pool刷新行为部分来提高性能。更多细节，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”</a>.</p>\n</li>\n<li><p>你可以配置InnoDB在服务重启后，如何保护当前buffer pool状态，避免冗长的预热期。你也可以保存当前的buffer pool状态，在服务运行的同时。更多细节，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”</a>.</p>\n</li>\n</ul>\n<h4 id=\"InnoDB-Buffer-Pool-LRU-算法\"><a href=\"#InnoDB-Buffer-Pool-LRU-算法\" class=\"headerlink\" title=\"InnoDB Buffer Pool LRU 算法\"></a>InnoDB Buffer Pool LRU 算法</h4><p>InnoDB管理一个buffer pool列表，用一个最少最近使用(LRU)算法的变体。当房间需要增加一个新页面进pool时，InnoDB会清除最少最近用的页面，增加新页面到列表中间。这个“中点插入策略”按照以下两个子列表对待列表：</p>\n<ul>\n<li>在头部，一个新或者young页面子列表是最近访问的</li>\n<li>在尾部，一个旧页面子列表是最少最近访问的</li>\n</ul>\n<p>这个算法使得在新子列表中页面能被大量查询到。旧的子列表包含最少使用页面；这些页面是清除的候选。</p>\n<p>LRU算法默认按照以下几点操作：</p>\n<ul>\n<li>3/8的buffer pool专门给旧的子列表用</li>\n<li>列表中点是新子列表尾部遇到旧子列表头部的边界</li>\n<li>当InnoDB读取一个页面进buffer pool时，起初会被插入到中点（旧子列表的头部）。这个页面能被读取是因为它包含在用户的特殊操作中，比如一个SQL查询，或者是在InnoDB的自动预读取操作部分。</li>\n<li>随着数据库的操作，在buffer pool中未被访问的页面通过向列表尾部移动而“老化”。新旧子列表中的页面随着其他页面变新而变旧。旧子列表中页面也随着页面被插入到中点而变旧。最终，很长时间没被使用的页面到达旧列表尾部而被清除。</li>\n</ul>\n<p>默认，被查询的页面会立即移动到新子列表，意味着它们将会在很长一段时间内留在buffer pool。一个表扫描（例如一个mysqldump操作，或者没有where的select语句）会带很大的数据进入buffer poll，然后清除大量的旧数据，即使这个新数据从来不会被用。类似的，后台进程预读加载的页面，只有被移到新列表的头部才会被访问到。这些情况会经常推送有用的页面到旧子列表，然后它们成为清除的对象。关于这些行为的更多信息，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.4, “Making the Buffer Pool Scan Resistant”</a>和<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.5, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”</a>.</p>\n<p>InnoDB标准监控输出包含buffer pool和内存部分的几个领域，这些从属于buffer pool LRU算法。更多细节查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-monitoring.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.9, “Monitoring the Buffer Pool Using the InnoDB Standard Monitor”</a>.</p>\n<h4 id=\"InnoDB-Buffer-Pool-配置选项\"><a href=\"#InnoDB-Buffer-Pool-配置选项\" class=\"headerlink\" title=\"InnoDB Buffer Pool 配置选项\"></a>InnoDB Buffer Pool 配置选项</h4><p>几个影响InnoDB buffer pool不同部分的配置选项。</p>\n<ul>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_size</a><br>指定buffer pool的大小。如果buffer pool比较小，而你有充足的内存，那么把buffer pool增大点可以减少查询访问InnoDB表的磁盘I/O操作，从而提升性能。在mysql的5.7.5，innodb_buffer_pool_size设置是动态的，不用重启服务你就可以配置它。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-resize.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.2, “Configuring InnoDB Buffer Pool Size”</a>.</p>\n</li>\n<li><p>innodb_buffer_pool_chunk_size<br>定义了Innodb buffer pool 改变操作的块大小。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-resize.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.2, “Configuring InnoDB Buffer Pool Size”</a></p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_instances\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_instances</a><br>划分buffer pool为用户指定的几个单独部分，每一个都有自己的LRU列表和相近的数据结构，这样在并发的内存读写操作中减少竞争。这个选项只有在你设置<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_size</a>大于1GB时才生效。你指定的总大小会被划分给所有的buffer polls。为了最高的效率，可以指定一个<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_instances\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_instances</a>和<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_size</a>的组合，这样每一个buffer pool实例都至少有1g。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-buffer-pools.html\" target=\"_blank\" rel=\"external\">Section 14.9.2.2, “Configuring Multiple Buffer Pool Instances”</a>.</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_pct\" target=\"_blank\" rel=\"external\">innodb_old_blocks_pct</a><br>指定InnoDB给旧子列表块用的buffer pool近似百分比。值范围为5到95。默认值为37（也就是3/8的pool）。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.4, “Making the Buffer Pool Scan Resistant”</a>.</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time\" target=\"_blank\" rel=\"external\">innodb_old_blocks_time</a><br>指定一个页面插入到旧子列表后必须停留多少ms，当它第一次被访问移到新子列表前。如果值是0，那么被移到旧子列表的页面将会立即移动到新子列表，当它第一次被访问的时候，无论插入后访问发生了多久。如果值大于0，页面会停留在旧子列表知道一个访问发生，至少第一次访问后许多ms。比如，值是1000会使页面停留在旧子列表1秒在第一次访问之后，移动到新子列表之前。</p>\n</li>\n</ul>\n<p>设置<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time\" target=\"_blank\" rel=\"external\">innodb_old_blocks_time</a>值超过0可以防止一次表扫描扫大量的新子列表，只为了这次扫描。一次页面扫描读取行被快速连续访问多次，但是之后这个页面却是没用的。如果<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time\" target=\"_blank\" rel=\"external\">innodb_old_blocks_time</a>设置的值比处理页面的时间大，那么在旧子列表的和该到列表尾部的页面将被很快的清除。这样，只被一次表扫描用的页面不会对新子列表中的大量使用的页面造成损害。</p>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time\" target=\"_blank\" rel=\"external\">innodb_old_blocks_time</a>可以在运行时设置，所以你可以在执行诸如表扫描和下载操作的时候暂时改变它：</p>\n<pre><code>SET GLOBAL innodb_old_blocks_time = 1000;\n... perform queries that scan tables ...\nSET GLOBAL innodb_old_blocks_time = 0;\n</code></pre><p>这个策略并不会执行，如果你的意图是想通过充满一个表的内容来热启动buffer pool。比如，基准测试经常在服务启动时做一个表或者索引扫描，因为当用了一段时间之后，数据通常都在buffer pool里面。在这种情况，把<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time\" target=\"_blank\" rel=\"external\">innodb_old_blocks_time</a>设为0，至少等到热启动完成。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.4, “Making the Buffer Pool Scan Resistant”</a>.</p>\n<ul>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_read_ahead_threshold\" target=\"_blank\" rel=\"external\">innodb_read_ahead_threshold</a><br>控制线性预读的灵敏度，InnoDB经常用来预读取页面进buffer pool。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.5, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”</a>.</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_random_read_ahead\" target=\"_blank\" rel=\"external\">innodb_random_read_ahead</a><br>为预读取页面进buffer pool启动随机预读技术。随机预读技术是基于已经存在buffer pool的也看来预言将会被用到的页面，不理会那些页面被读取的顺序。<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_random_read_ahead\" target=\"_blank\" rel=\"external\">innodb_random_read_ahead</a>默认是关闭的。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.5, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”</a>。</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_adaptive_flushing\" target=\"_blank\" rel=\"external\">innodb_adaptive_flushing</a><br>指定是否自动调整刷新<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page\" target=\"_blank\" rel=\"external\">脏页面</a>的比率，基于在工作中的buffer pool。自动调整刷新比率是想要防止I/O操作的爆发。这个设定是默认开启的。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-adaptive_flushing.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.6, “Configuring InnoDB Buffer Pool Flushing”</a>.</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_adaptive_flushing_lwm\" target=\"_blank\" rel=\"external\">innodb_adaptive_flushing_lwm</a><br>当<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_adaptive_flushing\" target=\"_blank\" rel=\"external\">adaptive flushing</a>启用时，低水位线，相当于<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_redo_log\" target=\"_blank\" rel=\"external\">redo log</a>所能容纳的百分比。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”</a></p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_neighbors\" target=\"_blank\" rel=\"external\">innodb_flush_neighbors</a><br>规定从buffer pool刷新页面是否也刷新其他<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page\" target=\"_blank\" rel=\"external\">dirty pages</a>，在同样<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_extent\" target=\"_blank\" rel=\"external\">extent</a>范围里。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-adaptive_flushing.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”</a>.</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flushing_avg_loops\" target=\"_blank\" rel=\"external\">innodb_flushing_avg_loops</a><br>innoDB保留之前计算的刷新状态快照的迭代次数，控制<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_adaptive_flushing\" target=\"_blank\" rel=\"external\">adaptive flushing</a>回应改变<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_workload\" target=\"_blank\" rel=\"external\">工作量</a>的速度。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”</a></p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_lru_scan_depth\" target=\"_blank\" rel=\"external\">innodb_lru_scan_depth</a><br>一个影响<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_flush\" target=\"_blank\" rel=\"external\">flush</a>操作buffer pool的算法和启发式。主要关注i/o密集型工作量性能。具体来说，每一个buffer pool实例，page_cleaner线程扫描寻找<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page\" target=\"_blank\" rel=\"external\">脏页面</a>刷新有多深入buffer pool LRU的列表。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”</a>.</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_max_dirty_pages_pct\" target=\"_blank\" rel=\"external\">innodb_max_dirty_pages_pct</a><br>InnoDB会尝试从buffer pool中<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_flush\" target=\"_blank\" rel=\"external\">刷新</a>数据，使得<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page\" target=\"_blank\" rel=\"external\">脏页面</a>的占比不回超过这个值。指定一个从0到99的整数。默认值为75.查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-adaptive_flushing.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.6, “Configuring InnoDB Buffer Pool Flushing”</a>.</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_max_dirty_pages_pct_lwm\" target=\"_blank\" rel=\"external\">innodb_max_dirty_pages_pct_lwm</a><br>预刷新的<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_page\" target=\"_blank\" rel=\"external\">脏页面</a>低水位控制脏页面比例。默认值0来使预刷新行为完全无效。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-lru-background-flushing.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.7, “Fine-tuning InnoDB Buffer Pool Flushing”</a>.</p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_filename\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_filename</a><br>指定文件名字，该文件保存<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_at_shutdown\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_dump_at_shutdown</a>和<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_now\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_dump_now</a>产生的表空间ID和页面ID。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”</a></p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_at_shutdown\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_dump_at_shutdown</a><br>指明当mysql宕机的时候是否记录缓存在buffer pool的页面，以在下次重启时缩短<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_warm_up\" target=\"_blank\" rel=\"external\">预热</a>过程。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”</a></p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_at_startup\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_load_at_startup</a><br>指定在mysql启动时，buffer pool<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_warm_up\" target=\"_blank\" rel=\"external\">预热</a>自动加载早些时候加载的页面.通常和<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_at_shutdown\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_dump_at_shutdown</a>一起用。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”</a></p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_now\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_dump_now</a><br>立即记录缓存在buffer pool的页面。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”</a></p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_now\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_load_now</a><br>立即<a href=\"https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_warm_up\" target=\"_blank\" rel=\"external\">预热</a>buffer pool加载一些数据页面，不等mysql重启。在基准测试中将缓存恢复到已知状态很有用，或者是使mysql运行报表或维护查询后恢复正常工作负载。通常和<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_now\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_dump_now</a>一起用。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”</a></p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_dump_pct\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_dump_pct</a><br>指定每一个buffer pool读出下载最近用到的页面百分比。范围从1到100. 查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”</a></p>\n</li>\n<li><p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_abort\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_load_abort</a><br>中断由<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_at_startup\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_load_at_startup</a>或者<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_load_now\" target=\"_blank\" rel=\"external\">innodb_buffer_pool_load_now</a>触发的修复buffer pool内容的进程。查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html\" target=\"_blank\" rel=\"external\">Section 15.6.3.8, “Saving and Restoring the Buffer Pool State”</a></p>\n</li>\n</ul>"},{"title":"memcached的内存管理总结","date":"2017-06-19T02:14:26.000Z","_content":"\n>为什么memcached（文中简写mc）的内存还有空余，而我设置的key还是会被挤掉呢？（文中memcached都指1.4.37版本）\n<!-- more -->\n\n### 安装\n首先是安装，网上一大堆，需要注意的是依赖libevent\n\n### 启动\nmemcached -h可以查看对应的启动参数，这里介绍几个常用的：\n\n```\n-p <num>\tTCP port number to listen on (default: 11211)\n\t\t指定端口号，默认是11211\n-l <addr>\tinterface to listen on (default: INADDR_ANY, all addresses)\n         \t<addr> may be specified as host:port. If you don't specify\n         \ta port number, the value you specified with -p or -U is\n         \tused. You may specify multiple addresses separated by comma\n         \tor by using -l multiple times\n         \t绑定地址，比如只允许本地访问 -l 127.0.0.1\n-d\t\trun as a daemon  守护进程运行\n-u <username>\tassume identity of <username> (only when run as root) 指定用户运行\n-m <num>\tmax memory to use for items in megabytes (default: 64 MB)\n\t\t分配的内存，默认64m\n-M\t\treturn error on memory exhausted (rather than removing items)\n\t\t内存满后是否返回错误或者移除item\n-vv\t\tvery verbose (also print client commands/responses)\n\t\t可以看到slab分配种类\n-I\t\tOverride the size of each slab page. Adjusts max item size\n  \t\t(default: 1mb, min: 1k, max: 128m) 指定slab的大小，默认1m\n-n <bytes>\tminimum space allocated for key+value+flags (default: 48)\n\t\t默认的key+value+flags大小\n-f <factor>\tchunk size growth factor (default: 1.25) chunk增长的倍率\n```\n\n所以启动可以这样\n> memcached -l 127.0.0.1 -P /tmp/memcached.pid -u www -m 100 -d\n\n### 几个名词\nmc内存的几个名词：\nslab：内存块，mc一次申请内存的最小单位，默认1m，可以用-I参数修改\npage: 分配给Slab的内存空间\nchunk: 一个slab会被划分成几个相同大小的chunk\nitem：我们需要保存的数据，一个chunk保存一个item，item主要存储缓存的key、value、key的长度、value的长度、缓存的时间等信息\nslabclass：slab的种类，mc会根据slab划分chunk的大小不一样来分成不同种类的slab\nSlab是一个内存块，它是memcached一次申请内存的最小单位。在启动memcached的时候一般会使用参数-m指定其可用内存，但是并不是在启动的那一刻所有的内存就全部分配出去了，只有在需要的时候才会去申请，而且每次申请一定是一个slab。\n如图：\n{% asset_img mem1.png %}\n图中几个错误的地方：\n在我的机器上chunk size：96*f^(n-1)\nclasses分了42种，item不仅仅存储了key和value\n\n### slab分配的策略\n启动时可以用-vv查看slab的分配策略，例如：\n```\nslab class   1: chunk size        96 perslab   10922\nslab class   2: chunk size       120 perslab    8738\nslab class   3: chunk size       152 perslab    6898\nslab class   4: chunk size       192 perslab    5461\nslab class   5: chunk size       240 perslab    4369\nslab class   6: chunk size       304 perslab    3449\nslab class   7: chunk size       384 perslab    2730\nslab class   8: chunk size       480 perslab    2184\nslab class   9: chunk size       600 perslab    1747\nslab class  10: chunk size       752 perslab    1394\nslab class  11: chunk size       944 perslab    1110\nslab class  12: chunk size      1184 perslab     885\nslab class  13: chunk size      1480 perslab     708\nslab class  14: chunk size      1856 perslab     564\nslab class  15: chunk size      2320 perslab     451\nslab class  16: chunk size      2904 perslab     361\nslab class  17: chunk size      3632 perslab     288\nslab class  18: chunk size      4544 perslab     230\nslab class  19: chunk size      5680 perslab     184\nslab class  20: chunk size      7104 perslab     147\nslab class  21: chunk size      8880 perslab     118\nslab class  22: chunk size     11104 perslab      94\nslab class  23: chunk size     13880 perslab      75\nslab class  24: chunk size     17352 perslab      60\nslab class  25: chunk size     21696 perslab      48\nslab class  26: chunk size     27120 perslab      38\nslab class  27: chunk size     33904 perslab      30\nslab class  28: chunk size     42384 perslab      24\nslab class  29: chunk size     52984 perslab      19\nslab class  30: chunk size     66232 perslab      15\nslab class  31: chunk size     82792 perslab      12\nslab class  32: chunk size    103496 perslab      10\nslab class  33: chunk size    129376 perslab       8\nslab class  34: chunk size    161720 perslab       6\nslab class  35: chunk size    202152 perslab       5\nslab class  36: chunk size    252696 perslab       4\nslab class  37: chunk size    315872 perslab       3\nslab class  38: chunk size    394840 perslab       2\nslab class  39: chunk size    493552 perslab       2\nslab class  40: chunk size    616944 perslab       1\nslab class  41: chunk size    771184 perslab       1\nslab class  42: chunk size   1048576 perslab       1\n```\n这是启动时mc会分配的slab种类，实际上，这只是个分配策略，预定义好可能使用的slab大小，并没有真正去申请内存空间，只有当实际数据添加时，才会有slab的内存申请。当数据进来时Memcached会选择一个大于等于最接近的slab来进行存储。\n比如第一次往mc添加一个10字节item时，mc会根据item大小，选择合适的slab大小如class 1，然后申请内存空间，用去一个chunk，从这可以看出，剩余的86字节确实浪费了。剩下的10921个chunk供下次有适合大小item时使用，当我们用完10922个chunk后，如果再有类似item进来，mc会再申请空间生成一个class 1的slab。\n默认一个slab的大小是1m，也就是1024x1024= 1048576字节，class 1的chunk数是1048576/96= 10922，取整。\n\nchunk的大小计算公式：\n\n\t(default_size+item_size)*f^(i-1) + CHUNK_ALIGN_BYTES\n\ni是分类，比如slab class 1\ndefault_size 是启动时-n参数的值，默认48字节\nitem_type：item结构体的长度，这个版本的是48字节\nf为factor，是增长倍率，默认为1.25 -f参数指定\nCHUNK_ALIGN_BYTES是修正值，为了保证chunk的大小是某个值的整数倍，在64位系统里，该值为8\nslabs.c中slabs_init函数（确定chunk大小，初始化slab class的描述符）的代码：\n\n```\n/* Make sure items are always n-byte aligned */\n        if (size % CHUNK_ALIGN_BYTES)\n            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);\n```\n            \n所以，slab class 1的chunk size = 48 + 48 = 96（8的倍数）\nslab class 2的chunk size = 96 x 1.25 = 120（8的倍数）\nslab class 3的chunk size = 120 x 1.25 = 150（不是8的倍数）则按照上面的公式\nsize += 8 - （150 % 8） 得出size=152\n以此类推\n\n回到开头，为什么mc的内存还有空余，而我设置的key还是会被挤掉呢？因为大量长度不规则的key，导致新申请了很多slab，占满了内存（这里占满，并不是说实实在在的内存使用，而是有点像上自习占座一样，虽然座位上没人，但是座位已经被定了），此时，新来一个item，如果适合的slab已经满了，mc并不会将这个item塞到大一点的slab，而是另外申请一个相同大小的slab，但是分配给mc的内存已经不够了，这时候就会挤掉原来slab中的数据，如果不想挤掉原来的，可以加-M参数。\n[timyang](https://timyang.net/data/memcached-lru-evictions/) 总结了几点：\n> 尽量不用随机字符串作为key，使用定值，这样占用空间大小相对固定。\n> 估算空间大小时候请用slab size计算，不要按value长度去计算。\n> 过期的不要和不过期的数据存在一起，否则不过期的可能被踢。\n\n### mc过期策略\n\nmc的缓存过期机制，并不会将内存释放给系统，而是将该内存标注为可用状态。并且有以下几种策略：\n1. 查询时检查过期\n2. 创建item的时候检查过期\n3. 执行flush命令，将所有item设置为失效\n4. lru爬虫，mc默认时关闭的。一个单独的线程，清理失效的item。（redis也有这种机制）\n5. LRU淘汰。先从LRU链表找有没有恰好过期的空间，有就用这个。如果没有过期空间，则分配新的空间。如果分配失败，那么往往是内存用光，则从LRU链表中把最旧的即使没过期的item淘汰掉，空间分给新的item。LRU链表插入缓存item的时候有先后顺序，所以淘汰一个item也是从尾部进行，也就是淘汰最早的item。\n\n需要注意的一点：如果设置过期时间超过30天，实际效果为1s后过期。\n\n参考资料：\n*https://www.zybuluo.com/phper/note/443547*\n*http://chenzhenianqing.cn/articles/1329.html*\n*http://calixwu.com/2014/11/memcached-yuanmafenxi-neicunguanli.html*\n*http://blog.csdn.net/initphp/article/details/44680115*\n*https://www.dexcoder.com/selfly/article/2248*\n*http://weibo.com/p/230418c019b4be0102w0tj?from=page_100505_profile&wvr=6&mod=wenzhangmod*\n*https://timyang.net/data/memcached-lru-evictions/*","source":"_posts/2017-06-07-memcached.md","raw":"---\ntitle: memcached的内存管理总结\ndate: 2017-06-19 10:14:26\ntags: memcached\ncategories: 缓存\n---\n\n>为什么memcached（文中简写mc）的内存还有空余，而我设置的key还是会被挤掉呢？（文中memcached都指1.4.37版本）\n<!-- more -->\n\n### 安装\n首先是安装，网上一大堆，需要注意的是依赖libevent\n\n### 启动\nmemcached -h可以查看对应的启动参数，这里介绍几个常用的：\n\n```\n-p <num>\tTCP port number to listen on (default: 11211)\n\t\t指定端口号，默认是11211\n-l <addr>\tinterface to listen on (default: INADDR_ANY, all addresses)\n         \t<addr> may be specified as host:port. If you don't specify\n         \ta port number, the value you specified with -p or -U is\n         \tused. You may specify multiple addresses separated by comma\n         \tor by using -l multiple times\n         \t绑定地址，比如只允许本地访问 -l 127.0.0.1\n-d\t\trun as a daemon  守护进程运行\n-u <username>\tassume identity of <username> (only when run as root) 指定用户运行\n-m <num>\tmax memory to use for items in megabytes (default: 64 MB)\n\t\t分配的内存，默认64m\n-M\t\treturn error on memory exhausted (rather than removing items)\n\t\t内存满后是否返回错误或者移除item\n-vv\t\tvery verbose (also print client commands/responses)\n\t\t可以看到slab分配种类\n-I\t\tOverride the size of each slab page. Adjusts max item size\n  \t\t(default: 1mb, min: 1k, max: 128m) 指定slab的大小，默认1m\n-n <bytes>\tminimum space allocated for key+value+flags (default: 48)\n\t\t默认的key+value+flags大小\n-f <factor>\tchunk size growth factor (default: 1.25) chunk增长的倍率\n```\n\n所以启动可以这样\n> memcached -l 127.0.0.1 -P /tmp/memcached.pid -u www -m 100 -d\n\n### 几个名词\nmc内存的几个名词：\nslab：内存块，mc一次申请内存的最小单位，默认1m，可以用-I参数修改\npage: 分配给Slab的内存空间\nchunk: 一个slab会被划分成几个相同大小的chunk\nitem：我们需要保存的数据，一个chunk保存一个item，item主要存储缓存的key、value、key的长度、value的长度、缓存的时间等信息\nslabclass：slab的种类，mc会根据slab划分chunk的大小不一样来分成不同种类的slab\nSlab是一个内存块，它是memcached一次申请内存的最小单位。在启动memcached的时候一般会使用参数-m指定其可用内存，但是并不是在启动的那一刻所有的内存就全部分配出去了，只有在需要的时候才会去申请，而且每次申请一定是一个slab。\n如图：\n{% asset_img mem1.png %}\n图中几个错误的地方：\n在我的机器上chunk size：96*f^(n-1)\nclasses分了42种，item不仅仅存储了key和value\n\n### slab分配的策略\n启动时可以用-vv查看slab的分配策略，例如：\n```\nslab class   1: chunk size        96 perslab   10922\nslab class   2: chunk size       120 perslab    8738\nslab class   3: chunk size       152 perslab    6898\nslab class   4: chunk size       192 perslab    5461\nslab class   5: chunk size       240 perslab    4369\nslab class   6: chunk size       304 perslab    3449\nslab class   7: chunk size       384 perslab    2730\nslab class   8: chunk size       480 perslab    2184\nslab class   9: chunk size       600 perslab    1747\nslab class  10: chunk size       752 perslab    1394\nslab class  11: chunk size       944 perslab    1110\nslab class  12: chunk size      1184 perslab     885\nslab class  13: chunk size      1480 perslab     708\nslab class  14: chunk size      1856 perslab     564\nslab class  15: chunk size      2320 perslab     451\nslab class  16: chunk size      2904 perslab     361\nslab class  17: chunk size      3632 perslab     288\nslab class  18: chunk size      4544 perslab     230\nslab class  19: chunk size      5680 perslab     184\nslab class  20: chunk size      7104 perslab     147\nslab class  21: chunk size      8880 perslab     118\nslab class  22: chunk size     11104 perslab      94\nslab class  23: chunk size     13880 perslab      75\nslab class  24: chunk size     17352 perslab      60\nslab class  25: chunk size     21696 perslab      48\nslab class  26: chunk size     27120 perslab      38\nslab class  27: chunk size     33904 perslab      30\nslab class  28: chunk size     42384 perslab      24\nslab class  29: chunk size     52984 perslab      19\nslab class  30: chunk size     66232 perslab      15\nslab class  31: chunk size     82792 perslab      12\nslab class  32: chunk size    103496 perslab      10\nslab class  33: chunk size    129376 perslab       8\nslab class  34: chunk size    161720 perslab       6\nslab class  35: chunk size    202152 perslab       5\nslab class  36: chunk size    252696 perslab       4\nslab class  37: chunk size    315872 perslab       3\nslab class  38: chunk size    394840 perslab       2\nslab class  39: chunk size    493552 perslab       2\nslab class  40: chunk size    616944 perslab       1\nslab class  41: chunk size    771184 perslab       1\nslab class  42: chunk size   1048576 perslab       1\n```\n这是启动时mc会分配的slab种类，实际上，这只是个分配策略，预定义好可能使用的slab大小，并没有真正去申请内存空间，只有当实际数据添加时，才会有slab的内存申请。当数据进来时Memcached会选择一个大于等于最接近的slab来进行存储。\n比如第一次往mc添加一个10字节item时，mc会根据item大小，选择合适的slab大小如class 1，然后申请内存空间，用去一个chunk，从这可以看出，剩余的86字节确实浪费了。剩下的10921个chunk供下次有适合大小item时使用，当我们用完10922个chunk后，如果再有类似item进来，mc会再申请空间生成一个class 1的slab。\n默认一个slab的大小是1m，也就是1024x1024= 1048576字节，class 1的chunk数是1048576/96= 10922，取整。\n\nchunk的大小计算公式：\n\n\t(default_size+item_size)*f^(i-1) + CHUNK_ALIGN_BYTES\n\ni是分类，比如slab class 1\ndefault_size 是启动时-n参数的值，默认48字节\nitem_type：item结构体的长度，这个版本的是48字节\nf为factor，是增长倍率，默认为1.25 -f参数指定\nCHUNK_ALIGN_BYTES是修正值，为了保证chunk的大小是某个值的整数倍，在64位系统里，该值为8\nslabs.c中slabs_init函数（确定chunk大小，初始化slab class的描述符）的代码：\n\n```\n/* Make sure items are always n-byte aligned */\n        if (size % CHUNK_ALIGN_BYTES)\n            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);\n```\n            \n所以，slab class 1的chunk size = 48 + 48 = 96（8的倍数）\nslab class 2的chunk size = 96 x 1.25 = 120（8的倍数）\nslab class 3的chunk size = 120 x 1.25 = 150（不是8的倍数）则按照上面的公式\nsize += 8 - （150 % 8） 得出size=152\n以此类推\n\n回到开头，为什么mc的内存还有空余，而我设置的key还是会被挤掉呢？因为大量长度不规则的key，导致新申请了很多slab，占满了内存（这里占满，并不是说实实在在的内存使用，而是有点像上自习占座一样，虽然座位上没人，但是座位已经被定了），此时，新来一个item，如果适合的slab已经满了，mc并不会将这个item塞到大一点的slab，而是另外申请一个相同大小的slab，但是分配给mc的内存已经不够了，这时候就会挤掉原来slab中的数据，如果不想挤掉原来的，可以加-M参数。\n[timyang](https://timyang.net/data/memcached-lru-evictions/) 总结了几点：\n> 尽量不用随机字符串作为key，使用定值，这样占用空间大小相对固定。\n> 估算空间大小时候请用slab size计算，不要按value长度去计算。\n> 过期的不要和不过期的数据存在一起，否则不过期的可能被踢。\n\n### mc过期策略\n\nmc的缓存过期机制，并不会将内存释放给系统，而是将该内存标注为可用状态。并且有以下几种策略：\n1. 查询时检查过期\n2. 创建item的时候检查过期\n3. 执行flush命令，将所有item设置为失效\n4. lru爬虫，mc默认时关闭的。一个单独的线程，清理失效的item。（redis也有这种机制）\n5. LRU淘汰。先从LRU链表找有没有恰好过期的空间，有就用这个。如果没有过期空间，则分配新的空间。如果分配失败，那么往往是内存用光，则从LRU链表中把最旧的即使没过期的item淘汰掉，空间分给新的item。LRU链表插入缓存item的时候有先后顺序，所以淘汰一个item也是从尾部进行，也就是淘汰最早的item。\n\n需要注意的一点：如果设置过期时间超过30天，实际效果为1s后过期。\n\n参考资料：\n*https://www.zybuluo.com/phper/note/443547*\n*http://chenzhenianqing.cn/articles/1329.html*\n*http://calixwu.com/2014/11/memcached-yuanmafenxi-neicunguanli.html*\n*http://blog.csdn.net/initphp/article/details/44680115*\n*https://www.dexcoder.com/selfly/article/2248*\n*http://weibo.com/p/230418c019b4be0102w0tj?from=page_100505_profile&wvr=6&mod=wenzhangmod*\n*https://timyang.net/data/memcached-lru-evictions/*","slug":"memcached","published":1,"updated":"2017-09-18T11:36:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7q4ur00001ckkje6hya34ti","content":"<blockquote>\n<p>为什么memcached（文中简写mc）的内存还有空余，而我设置的key还是会被挤掉呢？（文中memcached都指1.4.37版本）<br><a id=\"more\"></a></p>\n</blockquote>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>首先是安装，网上一大堆，需要注意的是依赖libevent</p>\n<h3 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h3><p>memcached -h可以查看对应的启动参数，这里介绍几个常用的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">-p &lt;num&gt;\tTCP port number to listen on (default: 11211)</div><div class=\"line\">\t\t指定端口号，默认是11211</div><div class=\"line\">-l &lt;addr&gt;\tinterface to listen on (default: INADDR_ANY, all addresses)</div><div class=\"line\">         \t&lt;addr&gt; may be specified as host:port. If you don&apos;t specify</div><div class=\"line\">         \ta port number, the value you specified with -p or -U is</div><div class=\"line\">         \tused. You may specify multiple addresses separated by comma</div><div class=\"line\">         \tor by using -l multiple times</div><div class=\"line\">         \t绑定地址，比如只允许本地访问 -l 127.0.0.1</div><div class=\"line\">-d\t\trun as a daemon  守护进程运行</div><div class=\"line\">-u &lt;username&gt;\tassume identity of &lt;username&gt; (only when run as root) 指定用户运行</div><div class=\"line\">-m &lt;num&gt;\tmax memory to use for items in megabytes (default: 64 MB)</div><div class=\"line\">\t\t分配的内存，默认64m</div><div class=\"line\">-M\t\treturn error on memory exhausted (rather than removing items)</div><div class=\"line\">\t\t内存满后是否返回错误或者移除item</div><div class=\"line\">-vv\t\tvery verbose (also print client commands/responses)</div><div class=\"line\">\t\t可以看到slab分配种类</div><div class=\"line\">-I\t\tOverride the size of each slab page. Adjusts max item size</div><div class=\"line\">  \t\t(default: 1mb, min: 1k, max: 128m) 指定slab的大小，默认1m</div><div class=\"line\">-n &lt;bytes&gt;\tminimum space allocated for key+value+flags (default: 48)</div><div class=\"line\">\t\t默认的key+value+flags大小</div><div class=\"line\">-f &lt;factor&gt;\tchunk size growth factor (default: 1.25) chunk增长的倍率</div></pre></td></tr></table></figure>\n<p>所以启动可以这样</p>\n<blockquote>\n<p>memcached -l 127.0.0.1 -P /tmp/memcached.pid -u www -m 100 -d</p>\n</blockquote>\n<h3 id=\"几个名词\"><a href=\"#几个名词\" class=\"headerlink\" title=\"几个名词\"></a>几个名词</h3><p>mc内存的几个名词：<br>slab：内存块，mc一次申请内存的最小单位，默认1m，可以用-I参数修改<br>page: 分配给Slab的内存空间<br>chunk: 一个slab会被划分成几个相同大小的chunk<br>item：我们需要保存的数据，一个chunk保存一个item，item主要存储缓存的key、value、key的长度、value的长度、缓存的时间等信息<br>slabclass：slab的种类，mc会根据slab划分chunk的大小不一样来分成不同种类的slab<br>Slab是一个内存块，它是memcached一次申请内存的最小单位。在启动memcached的时候一般会使用参数-m指定其可用内存，但是并不是在启动的那一刻所有的内存就全部分配出去了，只有在需要的时候才会去申请，而且每次申请一定是一个slab。<br>如图：<br><img src=\"/2017/06/19/memcached/mem1.png\" alt=\"mem1.png\" title=\"\"><br>图中几个错误的地方：<br>在我的机器上chunk size：96*f^(n-1)<br>classes分了42种，item不仅仅存储了key和value</p>\n<h3 id=\"slab分配的策略\"><a href=\"#slab分配的策略\" class=\"headerlink\" title=\"slab分配的策略\"></a>slab分配的策略</h3><p>启动时可以用-vv查看slab的分配策略，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">slab class   1: chunk size        96 perslab   10922</div><div class=\"line\">slab class   2: chunk size       120 perslab    8738</div><div class=\"line\">slab class   3: chunk size       152 perslab    6898</div><div class=\"line\">slab class   4: chunk size       192 perslab    5461</div><div class=\"line\">slab class   5: chunk size       240 perslab    4369</div><div class=\"line\">slab class   6: chunk size       304 perslab    3449</div><div class=\"line\">slab class   7: chunk size       384 perslab    2730</div><div class=\"line\">slab class   8: chunk size       480 perslab    2184</div><div class=\"line\">slab class   9: chunk size       600 perslab    1747</div><div class=\"line\">slab class  10: chunk size       752 perslab    1394</div><div class=\"line\">slab class  11: chunk size       944 perslab    1110</div><div class=\"line\">slab class  12: chunk size      1184 perslab     885</div><div class=\"line\">slab class  13: chunk size      1480 perslab     708</div><div class=\"line\">slab class  14: chunk size      1856 perslab     564</div><div class=\"line\">slab class  15: chunk size      2320 perslab     451</div><div class=\"line\">slab class  16: chunk size      2904 perslab     361</div><div class=\"line\">slab class  17: chunk size      3632 perslab     288</div><div class=\"line\">slab class  18: chunk size      4544 perslab     230</div><div class=\"line\">slab class  19: chunk size      5680 perslab     184</div><div class=\"line\">slab class  20: chunk size      7104 perslab     147</div><div class=\"line\">slab class  21: chunk size      8880 perslab     118</div><div class=\"line\">slab class  22: chunk size     11104 perslab      94</div><div class=\"line\">slab class  23: chunk size     13880 perslab      75</div><div class=\"line\">slab class  24: chunk size     17352 perslab      60</div><div class=\"line\">slab class  25: chunk size     21696 perslab      48</div><div class=\"line\">slab class  26: chunk size     27120 perslab      38</div><div class=\"line\">slab class  27: chunk size     33904 perslab      30</div><div class=\"line\">slab class  28: chunk size     42384 perslab      24</div><div class=\"line\">slab class  29: chunk size     52984 perslab      19</div><div class=\"line\">slab class  30: chunk size     66232 perslab      15</div><div class=\"line\">slab class  31: chunk size     82792 perslab      12</div><div class=\"line\">slab class  32: chunk size    103496 perslab      10</div><div class=\"line\">slab class  33: chunk size    129376 perslab       8</div><div class=\"line\">slab class  34: chunk size    161720 perslab       6</div><div class=\"line\">slab class  35: chunk size    202152 perslab       5</div><div class=\"line\">slab class  36: chunk size    252696 perslab       4</div><div class=\"line\">slab class  37: chunk size    315872 perslab       3</div><div class=\"line\">slab class  38: chunk size    394840 perslab       2</div><div class=\"line\">slab class  39: chunk size    493552 perslab       2</div><div class=\"line\">slab class  40: chunk size    616944 perslab       1</div><div class=\"line\">slab class  41: chunk size    771184 perslab       1</div><div class=\"line\">slab class  42: chunk size   1048576 perslab       1</div></pre></td></tr></table></figure></p>\n<p>这是启动时mc会分配的slab种类，实际上，这只是个分配策略，预定义好可能使用的slab大小，并没有真正去申请内存空间，只有当实际数据添加时，才会有slab的内存申请。当数据进来时Memcached会选择一个大于等于最接近的slab来进行存储。<br>比如第一次往mc添加一个10字节item时，mc会根据item大小，选择合适的slab大小如class 1，然后申请内存空间，用去一个chunk，从这可以看出，剩余的86字节确实浪费了。剩下的10921个chunk供下次有适合大小item时使用，当我们用完10922个chunk后，如果再有类似item进来，mc会再申请空间生成一个class 1的slab。<br>默认一个slab的大小是1m，也就是1024x1024= 1048576字节，class 1的chunk数是1048576/96= 10922，取整。</p>\n<p>chunk的大小计算公式：</p>\n<pre><code>(default_size+item_size)*f^(i-1) + CHUNK_ALIGN_BYTES\n</code></pre><p>i是分类，比如slab class 1<br>default_size 是启动时-n参数的值，默认48字节<br>item_type：item结构体的长度，这个版本的是48字节<br>f为factor，是增长倍率，默认为1.25 -f参数指定<br>CHUNK_ALIGN_BYTES是修正值，为了保证chunk的大小是某个值的整数倍，在64位系统里，该值为8<br>slabs.c中slabs_init函数（确定chunk大小，初始化slab class的描述符）的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* Make sure items are always n-byte aligned */</div><div class=\"line\">        if (size % CHUNK_ALIGN_BYTES)</div><div class=\"line\">            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);</div></pre></td></tr></table></figure>\n<p>所以，slab class 1的chunk size = 48 + 48 = 96（8的倍数）<br>slab class 2的chunk size = 96 x 1.25 = 120（8的倍数）<br>slab class 3的chunk size = 120 x 1.25 = 150（不是8的倍数）则按照上面的公式<br>size += 8 - （150 % 8） 得出size=152<br>以此类推</p>\n<p>回到开头，为什么mc的内存还有空余，而我设置的key还是会被挤掉呢？因为大量长度不规则的key，导致新申请了很多slab，占满了内存（这里占满，并不是说实实在在的内存使用，而是有点像上自习占座一样，虽然座位上没人，但是座位已经被定了），此时，新来一个item，如果适合的slab已经满了，mc并不会将这个item塞到大一点的slab，而是另外申请一个相同大小的slab，但是分配给mc的内存已经不够了，这时候就会挤掉原来slab中的数据，如果不想挤掉原来的，可以加-M参数。<br><a href=\"https://timyang.net/data/memcached-lru-evictions/\" target=\"_blank\" rel=\"external\">timyang</a> 总结了几点：</p>\n<blockquote>\n<p>尽量不用随机字符串作为key，使用定值，这样占用空间大小相对固定。<br>估算空间大小时候请用slab size计算，不要按value长度去计算。<br>过期的不要和不过期的数据存在一起，否则不过期的可能被踢。</p>\n</blockquote>\n<h3 id=\"mc过期策略\"><a href=\"#mc过期策略\" class=\"headerlink\" title=\"mc过期策略\"></a>mc过期策略</h3><p>mc的缓存过期机制，并不会将内存释放给系统，而是将该内存标注为可用状态。并且有以下几种策略：</p>\n<ol>\n<li>查询时检查过期</li>\n<li>创建item的时候检查过期</li>\n<li>执行flush命令，将所有item设置为失效</li>\n<li>lru爬虫，mc默认时关闭的。一个单独的线程，清理失效的item。（redis也有这种机制）</li>\n<li>LRU淘汰。先从LRU链表找有没有恰好过期的空间，有就用这个。如果没有过期空间，则分配新的空间。如果分配失败，那么往往是内存用光，则从LRU链表中把最旧的即使没过期的item淘汰掉，空间分给新的item。LRU链表插入缓存item的时候有先后顺序，所以淘汰一个item也是从尾部进行，也就是淘汰最早的item。</li>\n</ol>\n<p>需要注意的一点：如果设置过期时间超过30天，实际效果为1s后过期。</p>\n<p>参考资料：<br><em><a href=\"https://www.zybuluo.com/phper/note/443547\" target=\"_blank\" rel=\"external\">https://www.zybuluo.com/phper/note/443547</a></em><br><em><a href=\"http://chenzhenianqing.cn/articles/1329.html\" target=\"_blank\" rel=\"external\">http://chenzhenianqing.cn/articles/1329.html</a></em><br><em><a href=\"http://calixwu.com/2014/11/memcached-yuanmafenxi-neicunguanli.html\" target=\"_blank\" rel=\"external\">http://calixwu.com/2014/11/memcached-yuanmafenxi-neicunguanli.html</a></em><br><em><a href=\"http://blog.csdn.net/initphp/article/details/44680115\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/initphp/article/details/44680115</a></em><br><em><a href=\"https://www.dexcoder.com/selfly/article/2248\" target=\"_blank\" rel=\"external\">https://www.dexcoder.com/selfly/article/2248</a></em><br><em><a href=\"http://weibo.com/p/230418c019b4be0102w0tj?from=page_100505_profile&amp;wvr=6&amp;mod=wenzhangmod\" target=\"_blank\" rel=\"external\">http://weibo.com/p/230418c019b4be0102w0tj?from=page_100505_profile&amp;wvr=6&amp;mod=wenzhangmod</a></em><br><em><a href=\"https://timyang.net/data/memcached-lru-evictions/\" target=\"_blank\" rel=\"external\">https://timyang.net/data/memcached-lru-evictions/</a></em></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>为什么memcached（文中简写mc）的内存还有空余，而我设置的key还是会被挤掉呢？（文中memcached都指1.4.37版本）<br>","more":"</p>\n</blockquote>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>首先是安装，网上一大堆，需要注意的是依赖libevent</p>\n<h3 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h3><p>memcached -h可以查看对应的启动参数，这里介绍几个常用的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">-p &lt;num&gt;\tTCP port number to listen on (default: 11211)</div><div class=\"line\">\t\t指定端口号，默认是11211</div><div class=\"line\">-l &lt;addr&gt;\tinterface to listen on (default: INADDR_ANY, all addresses)</div><div class=\"line\">         \t&lt;addr&gt; may be specified as host:port. If you don&apos;t specify</div><div class=\"line\">         \ta port number, the value you specified with -p or -U is</div><div class=\"line\">         \tused. You may specify multiple addresses separated by comma</div><div class=\"line\">         \tor by using -l multiple times</div><div class=\"line\">         \t绑定地址，比如只允许本地访问 -l 127.0.0.1</div><div class=\"line\">-d\t\trun as a daemon  守护进程运行</div><div class=\"line\">-u &lt;username&gt;\tassume identity of &lt;username&gt; (only when run as root) 指定用户运行</div><div class=\"line\">-m &lt;num&gt;\tmax memory to use for items in megabytes (default: 64 MB)</div><div class=\"line\">\t\t分配的内存，默认64m</div><div class=\"line\">-M\t\treturn error on memory exhausted (rather than removing items)</div><div class=\"line\">\t\t内存满后是否返回错误或者移除item</div><div class=\"line\">-vv\t\tvery verbose (also print client commands/responses)</div><div class=\"line\">\t\t可以看到slab分配种类</div><div class=\"line\">-I\t\tOverride the size of each slab page. Adjusts max item size</div><div class=\"line\">  \t\t(default: 1mb, min: 1k, max: 128m) 指定slab的大小，默认1m</div><div class=\"line\">-n &lt;bytes&gt;\tminimum space allocated for key+value+flags (default: 48)</div><div class=\"line\">\t\t默认的key+value+flags大小</div><div class=\"line\">-f &lt;factor&gt;\tchunk size growth factor (default: 1.25) chunk增长的倍率</div></pre></td></tr></table></figure>\n<p>所以启动可以这样</p>\n<blockquote>\n<p>memcached -l 127.0.0.1 -P /tmp/memcached.pid -u www -m 100 -d</p>\n</blockquote>\n<h3 id=\"几个名词\"><a href=\"#几个名词\" class=\"headerlink\" title=\"几个名词\"></a>几个名词</h3><p>mc内存的几个名词：<br>slab：内存块，mc一次申请内存的最小单位，默认1m，可以用-I参数修改<br>page: 分配给Slab的内存空间<br>chunk: 一个slab会被划分成几个相同大小的chunk<br>item：我们需要保存的数据，一个chunk保存一个item，item主要存储缓存的key、value、key的长度、value的长度、缓存的时间等信息<br>slabclass：slab的种类，mc会根据slab划分chunk的大小不一样来分成不同种类的slab<br>Slab是一个内存块，它是memcached一次申请内存的最小单位。在启动memcached的时候一般会使用参数-m指定其可用内存，但是并不是在启动的那一刻所有的内存就全部分配出去了，只有在需要的时候才会去申请，而且每次申请一定是一个slab。<br>如图：<br><img src=\"/2017/06/19/memcached/mem1.png\" alt=\"mem1.png\" title=\"\"><br>图中几个错误的地方：<br>在我的机器上chunk size：96*f^(n-1)<br>classes分了42种，item不仅仅存储了key和value</p>\n<h3 id=\"slab分配的策略\"><a href=\"#slab分配的策略\" class=\"headerlink\" title=\"slab分配的策略\"></a>slab分配的策略</h3><p>启动时可以用-vv查看slab的分配策略，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">slab class   1: chunk size        96 perslab   10922</div><div class=\"line\">slab class   2: chunk size       120 perslab    8738</div><div class=\"line\">slab class   3: chunk size       152 perslab    6898</div><div class=\"line\">slab class   4: chunk size       192 perslab    5461</div><div class=\"line\">slab class   5: chunk size       240 perslab    4369</div><div class=\"line\">slab class   6: chunk size       304 perslab    3449</div><div class=\"line\">slab class   7: chunk size       384 perslab    2730</div><div class=\"line\">slab class   8: chunk size       480 perslab    2184</div><div class=\"line\">slab class   9: chunk size       600 perslab    1747</div><div class=\"line\">slab class  10: chunk size       752 perslab    1394</div><div class=\"line\">slab class  11: chunk size       944 perslab    1110</div><div class=\"line\">slab class  12: chunk size      1184 perslab     885</div><div class=\"line\">slab class  13: chunk size      1480 perslab     708</div><div class=\"line\">slab class  14: chunk size      1856 perslab     564</div><div class=\"line\">slab class  15: chunk size      2320 perslab     451</div><div class=\"line\">slab class  16: chunk size      2904 perslab     361</div><div class=\"line\">slab class  17: chunk size      3632 perslab     288</div><div class=\"line\">slab class  18: chunk size      4544 perslab     230</div><div class=\"line\">slab class  19: chunk size      5680 perslab     184</div><div class=\"line\">slab class  20: chunk size      7104 perslab     147</div><div class=\"line\">slab class  21: chunk size      8880 perslab     118</div><div class=\"line\">slab class  22: chunk size     11104 perslab      94</div><div class=\"line\">slab class  23: chunk size     13880 perslab      75</div><div class=\"line\">slab class  24: chunk size     17352 perslab      60</div><div class=\"line\">slab class  25: chunk size     21696 perslab      48</div><div class=\"line\">slab class  26: chunk size     27120 perslab      38</div><div class=\"line\">slab class  27: chunk size     33904 perslab      30</div><div class=\"line\">slab class  28: chunk size     42384 perslab      24</div><div class=\"line\">slab class  29: chunk size     52984 perslab      19</div><div class=\"line\">slab class  30: chunk size     66232 perslab      15</div><div class=\"line\">slab class  31: chunk size     82792 perslab      12</div><div class=\"line\">slab class  32: chunk size    103496 perslab      10</div><div class=\"line\">slab class  33: chunk size    129376 perslab       8</div><div class=\"line\">slab class  34: chunk size    161720 perslab       6</div><div class=\"line\">slab class  35: chunk size    202152 perslab       5</div><div class=\"line\">slab class  36: chunk size    252696 perslab       4</div><div class=\"line\">slab class  37: chunk size    315872 perslab       3</div><div class=\"line\">slab class  38: chunk size    394840 perslab       2</div><div class=\"line\">slab class  39: chunk size    493552 perslab       2</div><div class=\"line\">slab class  40: chunk size    616944 perslab       1</div><div class=\"line\">slab class  41: chunk size    771184 perslab       1</div><div class=\"line\">slab class  42: chunk size   1048576 perslab       1</div></pre></td></tr></table></figure></p>\n<p>这是启动时mc会分配的slab种类，实际上，这只是个分配策略，预定义好可能使用的slab大小，并没有真正去申请内存空间，只有当实际数据添加时，才会有slab的内存申请。当数据进来时Memcached会选择一个大于等于最接近的slab来进行存储。<br>比如第一次往mc添加一个10字节item时，mc会根据item大小，选择合适的slab大小如class 1，然后申请内存空间，用去一个chunk，从这可以看出，剩余的86字节确实浪费了。剩下的10921个chunk供下次有适合大小item时使用，当我们用完10922个chunk后，如果再有类似item进来，mc会再申请空间生成一个class 1的slab。<br>默认一个slab的大小是1m，也就是1024x1024= 1048576字节，class 1的chunk数是1048576/96= 10922，取整。</p>\n<p>chunk的大小计算公式：</p>\n<pre><code>(default_size+item_size)*f^(i-1) + CHUNK_ALIGN_BYTES\n</code></pre><p>i是分类，比如slab class 1<br>default_size 是启动时-n参数的值，默认48字节<br>item_type：item结构体的长度，这个版本的是48字节<br>f为factor，是增长倍率，默认为1.25 -f参数指定<br>CHUNK_ALIGN_BYTES是修正值，为了保证chunk的大小是某个值的整数倍，在64位系统里，该值为8<br>slabs.c中slabs_init函数（确定chunk大小，初始化slab class的描述符）的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* Make sure items are always n-byte aligned */</div><div class=\"line\">        if (size % CHUNK_ALIGN_BYTES)</div><div class=\"line\">            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);</div></pre></td></tr></table></figure>\n<p>所以，slab class 1的chunk size = 48 + 48 = 96（8的倍数）<br>slab class 2的chunk size = 96 x 1.25 = 120（8的倍数）<br>slab class 3的chunk size = 120 x 1.25 = 150（不是8的倍数）则按照上面的公式<br>size += 8 - （150 % 8） 得出size=152<br>以此类推</p>\n<p>回到开头，为什么mc的内存还有空余，而我设置的key还是会被挤掉呢？因为大量长度不规则的key，导致新申请了很多slab，占满了内存（这里占满，并不是说实实在在的内存使用，而是有点像上自习占座一样，虽然座位上没人，但是座位已经被定了），此时，新来一个item，如果适合的slab已经满了，mc并不会将这个item塞到大一点的slab，而是另外申请一个相同大小的slab，但是分配给mc的内存已经不够了，这时候就会挤掉原来slab中的数据，如果不想挤掉原来的，可以加-M参数。<br><a href=\"https://timyang.net/data/memcached-lru-evictions/\" target=\"_blank\" rel=\"external\">timyang</a> 总结了几点：</p>\n<blockquote>\n<p>尽量不用随机字符串作为key，使用定值，这样占用空间大小相对固定。<br>估算空间大小时候请用slab size计算，不要按value长度去计算。<br>过期的不要和不过期的数据存在一起，否则不过期的可能被踢。</p>\n</blockquote>\n<h3 id=\"mc过期策略\"><a href=\"#mc过期策略\" class=\"headerlink\" title=\"mc过期策略\"></a>mc过期策略</h3><p>mc的缓存过期机制，并不会将内存释放给系统，而是将该内存标注为可用状态。并且有以下几种策略：</p>\n<ol>\n<li>查询时检查过期</li>\n<li>创建item的时候检查过期</li>\n<li>执行flush命令，将所有item设置为失效</li>\n<li>lru爬虫，mc默认时关闭的。一个单独的线程，清理失效的item。（redis也有这种机制）</li>\n<li>LRU淘汰。先从LRU链表找有没有恰好过期的空间，有就用这个。如果没有过期空间，则分配新的空间。如果分配失败，那么往往是内存用光，则从LRU链表中把最旧的即使没过期的item淘汰掉，空间分给新的item。LRU链表插入缓存item的时候有先后顺序，所以淘汰一个item也是从尾部进行，也就是淘汰最早的item。</li>\n</ol>\n<p>需要注意的一点：如果设置过期时间超过30天，实际效果为1s后过期。</p>\n<p>参考资料：<br><em><a href=\"https://www.zybuluo.com/phper/note/443547\" target=\"_blank\" rel=\"external\">https://www.zybuluo.com/phper/note/443547</a></em><br><em><a href=\"http://chenzhenianqing.cn/articles/1329.html\" target=\"_blank\" rel=\"external\">http://chenzhenianqing.cn/articles/1329.html</a></em><br><em><a href=\"http://calixwu.com/2014/11/memcached-yuanmafenxi-neicunguanli.html\" target=\"_blank\" rel=\"external\">http://calixwu.com/2014/11/memcached-yuanmafenxi-neicunguanli.html</a></em><br><em><a href=\"http://blog.csdn.net/initphp/article/details/44680115\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/initphp/article/details/44680115</a></em><br><em><a href=\"https://www.dexcoder.com/selfly/article/2248\" target=\"_blank\" rel=\"external\">https://www.dexcoder.com/selfly/article/2248</a></em><br><em><a href=\"http://weibo.com/p/230418c019b4be0102w0tj?from=page_100505_profile&amp;wvr=6&amp;mod=wenzhangmod\" target=\"_blank\" rel=\"external\">http://weibo.com/p/230418c019b4be0102w0tj?from=page_100505_profile&amp;wvr=6&amp;mod=wenzhangmod</a></em><br><em><a href=\"https://timyang.net/data/memcached-lru-evictions/\" target=\"_blank\" rel=\"external\">https://timyang.net/data/memcached-lru-evictions/</a></em></p>"},{"title":"学会偷懒","date":"2017-07-23T08:01:04.000Z","_content":"\n>我觉得每个工程师都应该学会”偷懒“，通过各种工具来减少很多无意义的步骤或者工作。\n<!-- more -->\n\n公司的mac没货了，好像是入职的应届生太多，只能再等个两三那个月，真是太悲剧了。不过发的Thinkpad也还不错，起码开关机挺快的。触摸板确实没有mac的好用啊。\n\n我们的产品主要是个app，调试测试什么的就需要手机连pc的代理，所以需要机器的ip。windows每次都要打开“运行”，输入“cmd”唤起命令行，然后输入ipconfig，并且在一堆信息中找到ipv4地址（在mac上也一样），比较不方便，所以想着能一键获取ip。\n\n当然写个windows可执行文件应该也行，可是不会，所以就用python吧。\n\n```\nimport socket\nimport time\ndef get_host_ip():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        s.connect(('8.8.8.8', 80))\n        ip = s.getsockname()[0]\n    finally:\n        s.close()\n\n    return ip\n\nip = get_host_ip()\nprint(ip)\ntime.sleep(30)\n```\n装个python，网上一大堆资料，把上面的python脚本放到桌面，执行后就能显示本机内网ip了。\n其实就是利用python创建的socket，获取自身包里面的IP。\n\n","source":"_posts/2017-07-23-lazy.md","raw":"---\ntitle: 学会偷懒\ndate: 2017-07-23 16:01:04\ntags: python\ncategories:\n---\n\n>我觉得每个工程师都应该学会”偷懒“，通过各种工具来减少很多无意义的步骤或者工作。\n<!-- more -->\n\n公司的mac没货了，好像是入职的应届生太多，只能再等个两三那个月，真是太悲剧了。不过发的Thinkpad也还不错，起码开关机挺快的。触摸板确实没有mac的好用啊。\n\n我们的产品主要是个app，调试测试什么的就需要手机连pc的代理，所以需要机器的ip。windows每次都要打开“运行”，输入“cmd”唤起命令行，然后输入ipconfig，并且在一堆信息中找到ipv4地址（在mac上也一样），比较不方便，所以想着能一键获取ip。\n\n当然写个windows可执行文件应该也行，可是不会，所以就用python吧。\n\n```\nimport socket\nimport time\ndef get_host_ip():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        s.connect(('8.8.8.8', 80))\n        ip = s.getsockname()[0]\n    finally:\n        s.close()\n\n    return ip\n\nip = get_host_ip()\nprint(ip)\ntime.sleep(30)\n```\n装个python，网上一大堆资料，把上面的python脚本放到桌面，执行后就能显示本机内网ip了。\n其实就是利用python创建的socket，获取自身包里面的IP。\n\n","slug":"lazy","published":1,"updated":"2017-09-18T11:36:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7q4ur01001fkkjex8t390kg","content":"<blockquote>\n<p>我觉得每个工程师都应该学会”偷懒“，通过各种工具来减少很多无意义的步骤或者工作。<br><a id=\"more\"></a></p>\n</blockquote>\n<p>公司的mac没货了，好像是入职的应届生太多，只能再等个两三那个月，真是太悲剧了。不过发的Thinkpad也还不错，起码开关机挺快的。触摸板确实没有mac的好用啊。</p>\n<p>我们的产品主要是个app，调试测试什么的就需要手机连pc的代理，所以需要机器的ip。windows每次都要打开“运行”，输入“cmd”唤起命令行，然后输入ipconfig，并且在一堆信息中找到ipv4地址（在mac上也一样），比较不方便，所以想着能一键获取ip。</p>\n<p>当然写个windows可执行文件应该也行，可是不会，所以就用python吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">import socket</div><div class=\"line\">import time</div><div class=\"line\">def get_host_ip():</div><div class=\"line\">    try:</div><div class=\"line\">        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</div><div class=\"line\">        s.connect((&apos;8.8.8.8&apos;, 80))</div><div class=\"line\">        ip = s.getsockname()[0]</div><div class=\"line\">    finally:</div><div class=\"line\">        s.close()</div><div class=\"line\"></div><div class=\"line\">    return ip</div><div class=\"line\"></div><div class=\"line\">ip = get_host_ip()</div><div class=\"line\">print(ip)</div><div class=\"line\">time.sleep(30)</div></pre></td></tr></table></figure>\n<p>装个python，网上一大堆资料，把上面的python脚本放到桌面，执行后就能显示本机内网ip了。<br>其实就是利用python创建的socket，获取自身包里面的IP。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>我觉得每个工程师都应该学会”偷懒“，通过各种工具来减少很多无意义的步骤或者工作。<br>","more":"</p>\n</blockquote>\n<p>公司的mac没货了，好像是入职的应届生太多，只能再等个两三那个月，真是太悲剧了。不过发的Thinkpad也还不错，起码开关机挺快的。触摸板确实没有mac的好用啊。</p>\n<p>我们的产品主要是个app，调试测试什么的就需要手机连pc的代理，所以需要机器的ip。windows每次都要打开“运行”，输入“cmd”唤起命令行，然后输入ipconfig，并且在一堆信息中找到ipv4地址（在mac上也一样），比较不方便，所以想着能一键获取ip。</p>\n<p>当然写个windows可执行文件应该也行，可是不会，所以就用python吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">import socket</div><div class=\"line\">import time</div><div class=\"line\">def get_host_ip():</div><div class=\"line\">    try:</div><div class=\"line\">        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</div><div class=\"line\">        s.connect((&apos;8.8.8.8&apos;, 80))</div><div class=\"line\">        ip = s.getsockname()[0]</div><div class=\"line\">    finally:</div><div class=\"line\">        s.close()</div><div class=\"line\"></div><div class=\"line\">    return ip</div><div class=\"line\"></div><div class=\"line\">ip = get_host_ip()</div><div class=\"line\">print(ip)</div><div class=\"line\">time.sleep(30)</div></pre></td></tr></table></figure>\n<p>装个python，网上一大堆资料，把上面的python脚本放到桌面，执行后就能显示本机内网ip了。<br>其实就是利用python创建的socket，获取自身包里面的IP。</p>"},{"title":"mysql字段类型binary和varbinary","date":"2017-09-13T15:09:45.000Z","_content":"\n* 以前都没用过binary和varbinary类型，这边存中文用这两个类型\n* mysql版本为5.7\n* 官网地址：https://dev.mysql.com/doc/refman/5.7/en/binary-varbinary.html\n\n<!--more-->\n\nbinary、varbinary类型和char、varchar类似，除了它们是存储二进制数据，而不是非二进制字符串。也就是说它们包含字节而不是字符串。这意味着，它们有二进制字符集和校对规则，并且基于值中的字节数值比较和排序。\n\n允许的最大长度和char、varchar一样，除了一个是字节长度，一个是字符长度。\n\nbinary和varbinary数据类型与char binary和varchar binary数据类型不同。对于后一种，binary属性不会把列当成二进制字符列。相反，它会使用列字符集的二进制(_bin)校对规则，列本身存储非二进制字符串而不是二进制字节串。比如，char(5) binary是char(5) CHARACTER SET latin1 COLLATE latin1_bin，假设默认的字符集为latin1。区别于binary(5)，存储的是5字节二进制字符，二进制字符集和校对规则。关于更多二进制字符和非二进制字符串有二进制校对规则的区别，查看[Section 10.1.8.5, “The binary Collation Compared to _bin Collations”](https://dev.mysql.com/doc/refman/5.7/en/charset-binary-collations.html)。\n\n如果严格sql模式没有开启，并且你还给binary或varbinary列设置了超出列最大长度的值，则值会被截断至合适长度并且产生一个警告。对于缩减的例子，你可以通过开启严格sql模式来禁止插入值，从而产生一个错误（而不是一个警告）。可以查看[Section 5.1.8, “Server SQL Modes”](https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html)。\n\n当存储binary值时，它们会被填充值右填充到指定长度。填充值为0x00(0字节)。插入时右填充0x00，查询时不删除尾随字节。所有字节在比较时都有意义，包括order by和distinct操作。0x00字节和空格在比较时是不同的，0x00小于空格。\n\n比如：对于binary(3)列，插入'a '时会变成'a \\0'。插入'a\\0'会变成'a\\0\\0'。查询时插入的值保持不变。\n\n对于varbinary，插入不会填充，查询时不会去除任何字节。所有字节在比较时都有意义，包括order by和distinct操作。0x00字节和空格在比较时是不同的，0x00小于空格。\n\n还有尾随的填充字节被删掉或者比较时忽略它们的例子，如果列有个唯一索引，插入的列值只有尾随字节数不同才会导致重复键错误。比如，如果表包含'a'，则尝试存储'a\\0'将会引发一个重复键错误。\n\n如果你打算用binary类型存储二进制数据，应该仔细考虑上面说的填充和删除特性，确保你检索的值和存储的值完全一样。下面的例子说明binary值的0x00填充是如何影响列值比较：\n\n\tmysql> CREATE TABLE t (c BINARY(3));\n\tQuery OK, 0 rows affected (0.01 sec)\n\t\n\tmysql> INSERT INTO t SET c = 'a';\n\tQuery OK, 1 row affected (0.01 sec)\n\t\n\tmysql> SELECT HEX(c), c = 'a', c = 'a\\0\\0' from t;\n\t+--------+---------+-------------+\n\t| HEX(c) | c = 'a' | c = 'a\\0\\0' |\n\t+--------+---------+-------------+\n\t| 610000 |       0 |           1 |\n\t+--------+---------+-------------+\n\t1 row in set (0.09 sec)\n\n如果检索的值必须和没有填充存储的值一样，那么可能用varbinary或者blog数据类型的一种比较合适。","source":"_posts/2017-09-13-mysql-binary.md","raw":"---\ntitle: mysql字段类型binary和varbinary\ndate: 2017-09-13 23:09:45\ntags: mysql\ncategories: 数据库\n---\n\n* 以前都没用过binary和varbinary类型，这边存中文用这两个类型\n* mysql版本为5.7\n* 官网地址：https://dev.mysql.com/doc/refman/5.7/en/binary-varbinary.html\n\n<!--more-->\n\nbinary、varbinary类型和char、varchar类似，除了它们是存储二进制数据，而不是非二进制字符串。也就是说它们包含字节而不是字符串。这意味着，它们有二进制字符集和校对规则，并且基于值中的字节数值比较和排序。\n\n允许的最大长度和char、varchar一样，除了一个是字节长度，一个是字符长度。\n\nbinary和varbinary数据类型与char binary和varchar binary数据类型不同。对于后一种，binary属性不会把列当成二进制字符列。相反，它会使用列字符集的二进制(_bin)校对规则，列本身存储非二进制字符串而不是二进制字节串。比如，char(5) binary是char(5) CHARACTER SET latin1 COLLATE latin1_bin，假设默认的字符集为latin1。区别于binary(5)，存储的是5字节二进制字符，二进制字符集和校对规则。关于更多二进制字符和非二进制字符串有二进制校对规则的区别，查看[Section 10.1.8.5, “The binary Collation Compared to _bin Collations”](https://dev.mysql.com/doc/refman/5.7/en/charset-binary-collations.html)。\n\n如果严格sql模式没有开启，并且你还给binary或varbinary列设置了超出列最大长度的值，则值会被截断至合适长度并且产生一个警告。对于缩减的例子，你可以通过开启严格sql模式来禁止插入值，从而产生一个错误（而不是一个警告）。可以查看[Section 5.1.8, “Server SQL Modes”](https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html)。\n\n当存储binary值时，它们会被填充值右填充到指定长度。填充值为0x00(0字节)。插入时右填充0x00，查询时不删除尾随字节。所有字节在比较时都有意义，包括order by和distinct操作。0x00字节和空格在比较时是不同的，0x00小于空格。\n\n比如：对于binary(3)列，插入'a '时会变成'a \\0'。插入'a\\0'会变成'a\\0\\0'。查询时插入的值保持不变。\n\n对于varbinary，插入不会填充，查询时不会去除任何字节。所有字节在比较时都有意义，包括order by和distinct操作。0x00字节和空格在比较时是不同的，0x00小于空格。\n\n还有尾随的填充字节被删掉或者比较时忽略它们的例子，如果列有个唯一索引，插入的列值只有尾随字节数不同才会导致重复键错误。比如，如果表包含'a'，则尝试存储'a\\0'将会引发一个重复键错误。\n\n如果你打算用binary类型存储二进制数据，应该仔细考虑上面说的填充和删除特性，确保你检索的值和存储的值完全一样。下面的例子说明binary值的0x00填充是如何影响列值比较：\n\n\tmysql> CREATE TABLE t (c BINARY(3));\n\tQuery OK, 0 rows affected (0.01 sec)\n\t\n\tmysql> INSERT INTO t SET c = 'a';\n\tQuery OK, 1 row affected (0.01 sec)\n\t\n\tmysql> SELECT HEX(c), c = 'a', c = 'a\\0\\0' from t;\n\t+--------+---------+-------------+\n\t| HEX(c) | c = 'a' | c = 'a\\0\\0' |\n\t+--------+---------+-------------+\n\t| 610000 |       0 |           1 |\n\t+--------+---------+-------------+\n\t1 row in set (0.09 sec)\n\n如果检索的值必须和没有填充存储的值一样，那么可能用varbinary或者blog数据类型的一种比较合适。","slug":"mysql-binary","published":1,"updated":"2017-09-18T11:36:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7q4ur02001kkkjesri3lz6k","content":"<ul>\n<li>以前都没用过binary和varbinary类型，这边存中文用这两个类型</li>\n<li>mysql版本为5.7</li>\n<li>官网地址：<a href=\"https://dev.mysql.com/doc/refman/5.7/en/binary-varbinary.html\" target=\"_blank\" rel=\"external\">https://dev.mysql.com/doc/refman/5.7/en/binary-varbinary.html</a></li>\n</ul>\n<a id=\"more\"></a>\n<p>binary、varbinary类型和char、varchar类似，除了它们是存储二进制数据，而不是非二进制字符串。也就是说它们包含字节而不是字符串。这意味着，它们有二进制字符集和校对规则，并且基于值中的字节数值比较和排序。</p>\n<p>允许的最大长度和char、varchar一样，除了一个是字节长度，一个是字符长度。</p>\n<p>binary和varbinary数据类型与char binary和varchar binary数据类型不同。对于后一种，binary属性不会把列当成二进制字符列。相反，它会使用列字符集的二进制(_bin)校对规则，列本身存储非二进制字符串而不是二进制字节串。比如，char(5) binary是char(5) CHARACTER SET latin1 COLLATE latin1_bin，假设默认的字符集为latin1。区别于binary(5)，存储的是5字节二进制字符，二进制字符集和校对规则。关于更多二进制字符和非二进制字符串有二进制校对规则的区别，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/charset-binary-collations.html\" target=\"_blank\" rel=\"external\">Section 10.1.8.5, “The binary Collation Compared to _bin Collations”</a>。</p>\n<p>如果严格sql模式没有开启，并且你还给binary或varbinary列设置了超出列最大长度的值，则值会被截断至合适长度并且产生一个警告。对于缩减的例子，你可以通过开启严格sql模式来禁止插入值，从而产生一个错误（而不是一个警告）。可以查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html\" target=\"_blank\" rel=\"external\">Section 5.1.8, “Server SQL Modes”</a>。</p>\n<p>当存储binary值时，它们会被填充值右填充到指定长度。填充值为0x00(0字节)。插入时右填充0x00，查询时不删除尾随字节。所有字节在比较时都有意义，包括order by和distinct操作。0x00字节和空格在比较时是不同的，0x00小于空格。</p>\n<p>比如：对于binary(3)列，插入’a ‘时会变成’a \\0’。插入’a\\0’会变成’a\\0\\0’。查询时插入的值保持不变。</p>\n<p>对于varbinary，插入不会填充，查询时不会去除任何字节。所有字节在比较时都有意义，包括order by和distinct操作。0x00字节和空格在比较时是不同的，0x00小于空格。</p>\n<p>还有尾随的填充字节被删掉或者比较时忽略它们的例子，如果列有个唯一索引，插入的列值只有尾随字节数不同才会导致重复键错误。比如，如果表包含’a’，则尝试存储’a\\0’将会引发一个重复键错误。</p>\n<p>如果你打算用binary类型存储二进制数据，应该仔细考虑上面说的填充和删除特性，确保你检索的值和存储的值完全一样。下面的例子说明binary值的0x00填充是如何影响列值比较：</p>\n<pre><code>mysql&gt; CREATE TABLE t (c BINARY(3));\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; INSERT INTO t SET c = &apos;a&apos;;\nQuery OK, 1 row affected (0.01 sec)\n\nmysql&gt; SELECT HEX(c), c = &apos;a&apos;, c = &apos;a\\0\\0&apos; from t;\n+--------+---------+-------------+\n| HEX(c) | c = &apos;a&apos; | c = &apos;a\\0\\0&apos; |\n+--------+---------+-------------+\n| 610000 |       0 |           1 |\n+--------+---------+-------------+\n1 row in set (0.09 sec)\n</code></pre><p>如果检索的值必须和没有填充存储的值一样，那么可能用varbinary或者blog数据类型的一种比较合适。</p>\n","site":{"data":{}},"excerpt":"<ul>\n<li>以前都没用过binary和varbinary类型，这边存中文用这两个类型</li>\n<li>mysql版本为5.7</li>\n<li>官网地址：<a href=\"https://dev.mysql.com/doc/refman/5.7/en/binary-varbinary.html\" target=\"_blank\" rel=\"external\">https://dev.mysql.com/doc/refman/5.7/en/binary-varbinary.html</a></li>\n</ul>","more":"<p>binary、varbinary类型和char、varchar类似，除了它们是存储二进制数据，而不是非二进制字符串。也就是说它们包含字节而不是字符串。这意味着，它们有二进制字符集和校对规则，并且基于值中的字节数值比较和排序。</p>\n<p>允许的最大长度和char、varchar一样，除了一个是字节长度，一个是字符长度。</p>\n<p>binary和varbinary数据类型与char binary和varchar binary数据类型不同。对于后一种，binary属性不会把列当成二进制字符列。相反，它会使用列字符集的二进制(_bin)校对规则，列本身存储非二进制字符串而不是二进制字节串。比如，char(5) binary是char(5) CHARACTER SET latin1 COLLATE latin1_bin，假设默认的字符集为latin1。区别于binary(5)，存储的是5字节二进制字符，二进制字符集和校对规则。关于更多二进制字符和非二进制字符串有二进制校对规则的区别，查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/charset-binary-collations.html\" target=\"_blank\" rel=\"external\">Section 10.1.8.5, “The binary Collation Compared to _bin Collations”</a>。</p>\n<p>如果严格sql模式没有开启，并且你还给binary或varbinary列设置了超出列最大长度的值，则值会被截断至合适长度并且产生一个警告。对于缩减的例子，你可以通过开启严格sql模式来禁止插入值，从而产生一个错误（而不是一个警告）。可以查看<a href=\"https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html\" target=\"_blank\" rel=\"external\">Section 5.1.8, “Server SQL Modes”</a>。</p>\n<p>当存储binary值时，它们会被填充值右填充到指定长度。填充值为0x00(0字节)。插入时右填充0x00，查询时不删除尾随字节。所有字节在比较时都有意义，包括order by和distinct操作。0x00字节和空格在比较时是不同的，0x00小于空格。</p>\n<p>比如：对于binary(3)列，插入’a ‘时会变成’a \\0’。插入’a\\0’会变成’a\\0\\0’。查询时插入的值保持不变。</p>\n<p>对于varbinary，插入不会填充，查询时不会去除任何字节。所有字节在比较时都有意义，包括order by和distinct操作。0x00字节和空格在比较时是不同的，0x00小于空格。</p>\n<p>还有尾随的填充字节被删掉或者比较时忽略它们的例子，如果列有个唯一索引，插入的列值只有尾随字节数不同才会导致重复键错误。比如，如果表包含’a’，则尝试存储’a\\0’将会引发一个重复键错误。</p>\n<p>如果你打算用binary类型存储二进制数据，应该仔细考虑上面说的填充和删除特性，确保你检索的值和存储的值完全一样。下面的例子说明binary值的0x00填充是如何影响列值比较：</p>\n<pre><code>mysql&gt; CREATE TABLE t (c BINARY(3));\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; INSERT INTO t SET c = &apos;a&apos;;\nQuery OK, 1 row affected (0.01 sec)\n\nmysql&gt; SELECT HEX(c), c = &apos;a&apos;, c = &apos;a\\0\\0&apos; from t;\n+--------+---------+-------------+\n| HEX(c) | c = &apos;a&apos; | c = &apos;a\\0\\0&apos; |\n+--------+---------+-------------+\n| 610000 |       0 |           1 |\n+--------+---------+-------------+\n1 row in set (0.09 sec)\n</code></pre><p>如果检索的值必须和没有填充存储的值一样，那么可能用varbinary或者blog数据类型的一种比较合适。</p>"}],"PostAsset":[{"_id":"source/_posts/2016-03-25-mysql-int/2.jpg","slug":"2.jpg","post":"cj7q4uqz10001kkjelesv356b","modified":0,"renderable":0},{"_id":"source/_posts/2016-03-25-mysql-int/1.jpg","slug":"1.jpg","post":"cj7q4uqz10001kkjelesv356b","modified":0,"renderable":0},{"_id":"source/_posts/2016-06-24-ctags/1.jpg","slug":"1.jpg","post":"cj7q4uqzf000ikkjeex2qrc3f","modified":0,"renderable":0},{"_id":"source/_posts/2017-06-07-memcached/mem1.png","slug":"mem1.png","post":"cj7q4ur00001ckkje6hya34ti","modified":0,"renderable":0},{"_id":"source/_posts/2016-05-10-mysql-driver/5.3.png","slug":"5.3.png","post":"cj7q4uqze000gkkjelcia5pp7","modified":0,"renderable":0},{"_id":"source/_posts/2016-05-10-mysql-driver/5.4.png","slug":"5.4.png","post":"cj7q4uqze000gkkjelcia5pp7","modified":0,"renderable":0},{"_id":"source/_posts/2016-06-12-greatWall/chrome.png","slug":"chrome.png","post":"cj7q4uqzd000ckkjetxx5ye2f","modified":0,"renderable":0},{"_id":"source/_posts/2016-06-12-greatWall/issh.jpeg","slug":"issh.jpeg","post":"cj7q4uqzd000ckkjetxx5ye2f","modified":0,"renderable":0},{"_id":"source/_posts/2016-03-23-kafka-0-9-0/consumer-groups.png","slug":"consumer-groups.png","post":"cj7q4uqz80005kkjefvashcbz","modified":0,"renderable":0},{"_id":"source/_posts/2016-03-23-kafka-0-9-0/log_anatomy.png","slug":"log_anatomy.png","post":"cj7q4uqz80005kkjefvashcbz","modified":0,"renderable":0},{"_id":"source/_posts/2016-03-23-kafka-0-9-0/producer_consumer.png","slug":"producer_consumer.png","post":"cj7q4uqz80005kkjefvashcbz","modified":0,"renderable":0},{"_id":"source/_posts/2017-05-27-curl/1.png","slug":"1.png","post":"cj7q4uqzu0010kkjedxxmo3mk","modified":0,"renderable":0},{"_id":"source/_posts/2017-05-27-curl/2.png","slug":"2.png","post":"cj7q4uqzu0010kkjedxxmo3mk","modified":0,"renderable":0},{"_id":"source/_posts/2017-05-27-curl/3.png","slug":"3.png","post":"cj7q4uqzu0010kkjedxxmo3mk","modified":0,"renderable":0},{"_id":"source/_posts/2017-05-27-curl/4.png","slug":"4.png","post":"cj7q4uqzu0010kkjedxxmo3mk","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cj7q4uqz10001kkjelesv356b","category_id":"cj7q4uqz60003kkjepuri48yx","_id":"cj7q4uqzd000dkkje3avfwnm3"},{"post_id":"cj7q4uqzb000bkkjessyjt17l","category_id":"cj7q4uqz60003kkjepuri48yx","_id":"cj7q4uqzf000jkkjelm8h589s"},{"post_id":"cj7q4uqz40002kkjej99rhnzd","category_id":"cj7q4uqza0008kkje90h1q36r","_id":"cj7q4uqzh000okkje90hzyyx7"},{"post_id":"cj7q4uqze000gkkjelcia5pp7","category_id":"cj7q4uqz60003kkjepuri48yx","_id":"cj7q4uqzl000qkkjett9323ye"},{"post_id":"cj7q4uqz80005kkjefvashcbz","category_id":"cj7q4uqzd000ekkjejqad6utv","_id":"cj7q4uqzs000vkkjefrdap37i"},{"post_id":"cj7q4uqz90006kkjez3mjgzxw","category_id":"cj7q4uqzg000kkkje5dlhmuw8","_id":"cj7q4uqzu000zkkjegpja13kr"},{"post_id":"cj7q4uqzr000ukkje8fya8stg","category_id":"cj7q4uqz60003kkjepuri48yx","_id":"cj7q4uqzx0015kkje79hgx8in"},{"post_id":"cj7q4uqzt000xkkje9maij0oq","category_id":"cj7q4uqzg000kkkje5dlhmuw8","_id":"cj7q4uqzz0018kkjeh9pnbnir"},{"post_id":"cj7q4uqza0007kkjehb2lanfe","category_id":"cj7q4uqzq000skkje53o0i6dv","_id":"cj7q4ur00001dkkjertjt8ghz"},{"post_id":"cj7q4uqzw0014kkjen3p7qamu","category_id":"cj7q4uqzg000kkkje5dlhmuw8","_id":"cj7q4ur01001gkkjeujehf4kk"},{"post_id":"cj7q4uqzd000ckkjetxx5ye2f","category_id":"cj7q4uqzv0011kkje9nsofrnb","_id":"cj7q4ur03001lkkjel8h9w31z"},{"post_id":"cj7q4uqzy0017kkjee8xcq8ce","category_id":"cj7q4uqz60003kkjepuri48yx","_id":"cj7q4ur03001nkkje4uwcn3sg"},{"post_id":"cj7q4uqzf000ikkjeex2qrc3f","category_id":"cj7q4uqzz0019kkjeq660818q","_id":"cj7q4ur04001rkkjemc9w36ej"},{"post_id":"cj7q4ur02001kkkjesri3lz6k","category_id":"cj7q4uqz60003kkjepuri48yx","_id":"cj7q4ur04001tkkjefxs4r96u"},{"post_id":"cj7q4uqzg000nkkjezmha5xyv","category_id":"cj7q4uqzz0019kkjeq660818q","_id":"cj7q4ur05001xkkjeebfqul32"},{"post_id":"cj7q4uqzk000pkkje0g53sdl3","category_id":"cj7q4ur03001okkjet1qwz43m","_id":"cj7q4ur050021kkje24is7fk5"},{"post_id":"cj7q4uqzu0010kkjedxxmo3mk","category_id":"cj7q4uqzz0019kkjeq660818q","_id":"cj7q4ur060025kkjef5jyf443"},{"post_id":"cj7q4ur00001ckkje6hya34ti","category_id":"cj7q4ur050020kkje37ng7fnc","_id":"cj7q4ur060029kkjexcnypwx8"}],"PostTag":[{"post_id":"cj7q4uqz10001kkjelesv356b","tag_id":"cj7q4uqz80004kkjes5ps8hiu","_id":"cj7q4uqzb000akkje463byhuh"},{"post_id":"cj7q4uqz40002kkjej99rhnzd","tag_id":"cj7q4uqzb0009kkjedjp9voat","_id":"cj7q4uqzf000hkkje7yyfzxc2"},{"post_id":"cj7q4uqze000gkkjelcia5pp7","tag_id":"cj7q4uqz80004kkjes5ps8hiu","_id":"cj7q4uqzg000mkkjegfdsluc8"},{"post_id":"cj7q4uqzg000nkkjezmha5xyv","tag_id":"cj7q4uqzb0009kkjedjp9voat","_id":"cj7q4uqzq000rkkje4g5kjchs"},{"post_id":"cj7q4uqz80005kkjefvashcbz","tag_id":"cj7q4uqze000fkkjebg0f5ea5","_id":"cj7q4uqzt000wkkjeze79mei9"},{"post_id":"cj7q4uqz80005kkjefvashcbz","tag_id":"cj7q4uqzg000lkkjesfe0b6lp","_id":"cj7q4uqzu000ykkjev5gopvm9"},{"post_id":"cj7q4uqzk000pkkje0g53sdl3","tag_id":"cj7q4uqzg000lkkjesfe0b6lp","_id":"cj7q4uqzw0013kkje4wki6pi2"},{"post_id":"cj7q4uqzr000ukkje8fya8stg","tag_id":"cj7q4uqz80004kkjes5ps8hiu","_id":"cj7q4uqzy0016kkjeth209rmn"},{"post_id":"cj7q4uqz90006kkjez3mjgzxw","tag_id":"cj7q4uqzq000tkkje3nixu5qu","_id":"cj7q4ur00001bkkjesou3f09t"},{"post_id":"cj7q4uqzu0010kkjedxxmo3mk","tag_id":"cj7q4uqzb0009kkjedjp9voat","_id":"cj7q4ur01001ekkjemvh5sj6u"},{"post_id":"cj7q4uqzu0010kkjedxxmo3mk","tag_id":"cj7q4uqzq000tkkje3nixu5qu","_id":"cj7q4ur02001jkkjej5heauaf"},{"post_id":"cj7q4uqzw0014kkjen3p7qamu","tag_id":"cj7q4uqzq000tkkje3nixu5qu","_id":"cj7q4ur03001mkkjeworat53t"},{"post_id":"cj7q4uqza0007kkjehb2lanfe","tag_id":"cj7q4uqzv0012kkjecc88al90","_id":"cj7q4ur04001qkkje5m5riucl"},{"post_id":"cj7q4uqzy0017kkjee8xcq8ce","tag_id":"cj7q4uqz80004kkjes5ps8hiu","_id":"cj7q4ur04001skkjei1d0a3gc"},{"post_id":"cj7q4uqzb000bkkjessyjt17l","tag_id":"cj7q4uqz80004kkjes5ps8hiu","_id":"cj7q4ur04001ukkjet2btjznw"},{"post_id":"cj7q4uqzb000bkkjessyjt17l","tag_id":"cj7q4uqzg000lkkjesfe0b6lp","_id":"cj7q4ur05001ykkjem16q39ar"},{"post_id":"cj7q4ur02001kkkjesri3lz6k","tag_id":"cj7q4uqz80004kkjes5ps8hiu","_id":"cj7q4ur05001zkkjey0bmwbhv"},{"post_id":"cj7q4uqzd000ckkjetxx5ye2f","tag_id":"cj7q4ur02001hkkjee5ca5aes","_id":"cj7q4ur060023kkjeqvc3iixp"},{"post_id":"cj7q4uqzf000ikkjeex2qrc3f","tag_id":"cj7q4ur04001pkkjehr2067dm","_id":"cj7q4ur060024kkjer1a9xk12"},{"post_id":"cj7q4uqzt000xkkje9maij0oq","tag_id":"cj7q4ur04001wkkjeml85lltq","_id":"cj7q4ur060027kkjeeraqfmav"},{"post_id":"cj7q4ur00001ckkje6hya34ti","tag_id":"cj7q4ur050022kkje2dznbrxe","_id":"cj7q4ur060028kkje0qu31d61"},{"post_id":"cj7q4ur01001fkkjex8t390kg","tag_id":"cj7q4ur060026kkjeuc6gdflk","_id":"cj7q4ur06002akkjeit7bhggl"}],"Tag":[{"name":"mysql","_id":"cj7q4uqz80004kkjes5ps8hiu"},{"name":"linux","_id":"cj7q4uqzb0009kkjedjp9voat"},{"name":"kafka","_id":"cj7q4uqze000fkkjebg0f5ea5"},{"name":"翻译","_id":"cj7q4uqzg000lkkjesfe0b6lp"},{"name":"php","_id":"cj7q4uqzq000tkkje3nixu5qu"},{"name":"排序","_id":"cj7q4uqzv0012kkjecc88al90"},{"name":"mac","_id":"cj7q4ur02001hkkjee5ca5aes"},{"name":"vim","_id":"cj7q4ur04001pkkjehr2067dm"},{"name":"mysql php","_id":"cj7q4ur04001wkkjeml85lltq"},{"name":"memcached","_id":"cj7q4ur050022kkje2dznbrxe"},{"name":"python","_id":"cj7q4ur060026kkjeuc6gdflk"}]}}